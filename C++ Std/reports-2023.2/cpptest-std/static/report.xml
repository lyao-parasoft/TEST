<?xml version='1.0' encoding='UTF-8' standalone='no'?><ResultsSession buildId="FlowAnalysisCpp-2024-07-04" climode="true" endTime="2024-07-04T20:06:22+08:00" execEnv="win32_x86_64" hasViols="true" id="1720084671901" lang="en_US" machine="CD-LYAO-02" prjModule="division, ..." project="FlowAnalysisCpp" tag="cpptest_settings-division, ...-${scontrol_branch}-win32_x86_64" time="2024-07-04T20:03:01+08:00" toolDispName="C/C++test" toolId="c++test" toolName="DTP Engine for C/C++" toolVer="2023.2.0" user="lyao">
   <TestConfig machine="CD-LYAO-02" name="cpptest_settings" pseudoUrl="../cpptest_settings.properties" user="lyao"/>
   <Authors>
      <Author id="dev1" name="lyao"/>
   </Authors>
   <Analyzers>
      <Analyzer id="com.parasoft.xtest.scope.analyzer" name="Scope Analyzer" ver="10.6.3.20231116"/>
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.code" name="Parasoft C/C++ Code Analyzer" ver="10.6.3.20231201B2232"/>
      <Analyzer id="com.parasoft.xtest.dupcode.parser" name="Code Duplication Parser" ver="10.6.3.20231116"/>
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.pattern" name="Parasoft C/C++ Static Analyzer" ver="10.6.3.20231201B2232"/>
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.flow" name="Parasoft C/C++ Flow Analyzer" ver="10.6.3.20231114B4458"/>
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.metrics" name="Parasoft C/C++ Metrics Analyzer" ver="10.6.3.20231201B2232"/>
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.dupcode" name="Code Duplication Detector" ver="10.6.3.20231116"/>
      <Analyzer id="com.parasoft.xtest.cpp.analyzer.static.global" name="Parasoft C/C++ Global Static Analyzer" ver="10.6.3.20231201B2232"/>
   </Analyzers>
   <VersionInfos>
      <StorageInfo ownerId="" resultId="ISetupResult" ver="1" ver10x="1"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IMetricsViolation" ver="2" ver10x="1"/>
      <StorageInfo ownerId="" resultId="IExecutionViolation" ver="1" ver10x="1"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IDupCodeViolation" ver="2" ver10x="1"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="IFlowAnalysisViolation" ver="2" ver10x="1"/>
      <StorageInfo ownerId="" resultId="IFunctionalViolation" ver="1" ver10x="1"/>
      <StorageInfo ownerId="" resultId="IChangeImpactViolation" ver="1" ver10x="1"/>
      <StorageInfo ownerId="com.parasoft.xtest.checkers.api.standards" resultId="ICodingStandardsViolation" ver="2" ver10x="1"/>
      <StorageInfo ownerId="" resultId="IUnitTestViolation" ver="1" ver10x="1"/>
   </VersionInfos>
   <Goals tsks="50">
      
   </Goals>
   <Metrics>
      <Metric avg="2.167" disp="true" id="METRIC.CBO" max="7" min="0" name="Coupling Between Objects" noi="6" stddev="3.078">
         <Info avg="2.167" disp="true" elem="test" max="7" min="0" noi="6" stddev="3.078"/>
      </Metric>
      <Metric avg="1.444" disp="true" id="METRIC.CC" max="4" min="1" name="McCabe Cyclomatic Complexity" noi="18" stddev="0.896">
         <Info avg="2" disp="true" elem="division" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="googlemock" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="gtest" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="src" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="1.357" disp="true" elem="test" max="4" min="1" noi="14" stddev="0.895"/>
      </Metric>
      <Metric avg="3.883" disp="true" id="METRIC.CLLOCRIF" max="13" min="0" name="Comment/Logical Lines in Files" noi="6" stddev="5.264">
         <Info avg="0.75" disp="true" elem="division" max="0.75" min="0.75" noi="1" stddev="0"/>
         <Info avg="13" disp="true" elem="googlemock" max="13" min="13" noi="1" stddev="0"/>
         <Info avg="9.333" disp="true" elem="gtest" max="9.333" min="9.333" noi="1" stddev="0"/>
         <Info avg="0.071" disp="true" elem="src" max="0.071" min="0.071" noi="1" stddev="0"/>
         <Info avg="0.071" disp="true" elem="test" max="0.143" min="0" noi="2" stddev="0.071"/>
      </Metric>
      <Metric avg="0.045" disp="true" id="METRIC.CLLOCRIM" max="0.357" min="0" name="Comment/Logical Lines in Methods" noi="8" stddev="0.118">
         <Info avg="0" disp="true" elem="division" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="0.357" disp="true" elem="gtest" max="0.357" min="0.357" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="test" max="0" min="0" noi="6" stddev="0"/>
      </Metric>
      <Metric avg="0" disp="true" id="METRIC.CLLOCRIT" max="0" min="0" name="Comment/Logical Lines in Types" noi="6" stddev="0">
         <Info avg="0" disp="true" elem="test" max="0" min="0" noi="6" stddev="0"/>
      </Metric>
      <Metric avg="0.222" disp="true" id="METRIC.DIF" max="1" min="0" name="Depth of Nested 'if' Statements" noi="18" stddev="0.416">
         <Info avg="1" disp="true" elem="division" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="googlemock" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="gtest" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="src" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="0.143" disp="true" elem="test" max="1" min="0" noi="14" stddev="0.35"/>
      </Metric>
      <Metric avg="1" disp="true" id="METRIC.ECC" max="1" min="1" name="Essential Cyclomatic Complexity" noi="18" stddev="0">
         <Info avg="1" disp="true" elem="division" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="googlemock" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="gtest" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="src" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="test" max="1" min="1" noi="14" stddev="0"/>
      </Metric>
      <Metric avg="3.5" disp="true" id="METRIC.FO" max="9" min="1" name="Fan Out" noi="6" stddev="3.547">
         <Info avg="3.5" disp="true" elem="test" max="9" min="1" noi="6" stddev="3.547"/>
      </Metric>
      <Metric avg="3.31" disp="true" id="METRIC.HDIFM" max="11.984" min="1" name="Halstead Difficulty" noi="18" stddev="3.505">
         <Info avg="11.611" disp="true" elem="division" max="11.611" min="11.611" noi="1" stddev="0"/>
         <Info avg="5" disp="true" elem="googlemock" max="5" min="5" noi="1" stddev="0"/>
         <Info avg="3.75" disp="true" elem="gtest" max="3.75" min="3.75" noi="1" stddev="0"/>
         <Info avg="11.984" disp="true" elem="src" max="11.984" min="11.984" noi="1" stddev="0"/>
         <Info avg="1.946" disp="true" elem="test" max="6.562" min="1" noi="14" stddev="1.85"/>
      </Metric>
      <Metric avg="739.354" disp="true" id="METRIC.HEFM" max="7108.174" min="8" name="Halstead Effort" noi="18" stddev="1641.293">
         <Info avg="1806.566" disp="true" elem="division" max="1806.566" min="1806.566" noi="1" stddev="0"/>
         <Info avg="605.07" disp="true" elem="googlemock" max="605.07" min="605.07" noi="1" stddev="0"/>
         <Info avg="422.205" disp="true" elem="gtest" max="422.205" min="422.205" noi="1" stddev="0"/>
         <Info avg="7108.174" disp="true" elem="src" max="7108.174" min="7108.174" noi="1" stddev="0"/>
         <Info avg="240.454" disp="true" elem="test" max="1406.256" min="8" noi="14" stddev="476.98"/>
      </Metric>
      <Metric avg="23.057" disp="true" id="METRIC.HICM" max="59.332" min="8" name="Halstead Intelligent Content" noi="18" stddev="13.312">
         <Info avg="13.4" disp="true" elem="division" max="13.4" min="13.4" noi="1" stddev="0"/>
         <Info avg="24.203" disp="true" elem="googlemock" max="24.203" min="24.203" noi="1" stddev="0"/>
         <Info avg="30.023" disp="true" elem="gtest" max="30.023" min="30.023" noi="1" stddev="0"/>
         <Info avg="49.491" disp="true" elem="src" max="49.491" min="49.491" noi="1" stddev="0"/>
         <Info avg="21.28" disp="true" elem="test" max="59.332" min="8" noi="14" stddev="12.827"/>
      </Metric>
      <Metric avg="22.167" disp="true" id="METRIC.HLENM" max="108" min="4" name="Halstead Program Length" noi="18" stddev="26.368">
         <Info avg="36" disp="true" elem="division" max="36" min="36" noi="1" stddev="0"/>
         <Info avg="28" disp="true" elem="googlemock" max="28" min="28" noi="1" stddev="0"/>
         <Info avg="27" disp="true" elem="gtest" max="27" min="27" noi="1" stddev="0"/>
         <Info avg="108" disp="true" elem="src" max="108" min="108" noi="1" stddev="0"/>
         <Info avg="14.286" disp="true" elem="test" max="63" min="4" noi="14" stddev="16.964"/>
      </Metric>
      <Metric avg="0.678" disp="true" id="METRIC.HLEVM" max="1" min="0.083" name="Halstead Program Level" noi="18" stddev="0.406">
         <Info avg="0.086" disp="true" elem="division" max="0.086" min="0.086" noi="1" stddev="0"/>
         <Info avg="0.2" disp="true" elem="googlemock" max="0.2" min="0.2" noi="1" stddev="0"/>
         <Info avg="0.267" disp="true" elem="gtest" max="0.267" min="0.267" noi="1" stddev="0"/>
         <Info avg="0.083" disp="true" elem="src" max="0.083" min="0.083" noi="1" stddev="0"/>
         <Info avg="0.826" disp="true" elem="test" max="1" min="0.152" noi="14" stddev="0.333"/>
      </Metric>
      <Metric avg="0.019" disp="true" id="METRIC.HNOBM" max="0.123" min="0.001" name="Halstead Number of Bugs" noi="18" stddev="0.03">
         <Info avg="0.049" disp="true" elem="division" max="0.049" min="0.049" noi="1" stddev="0"/>
         <Info avg="0.024" disp="true" elem="googlemock" max="0.024" min="0.024" noi="1" stddev="0"/>
         <Info avg="0.019" disp="true" elem="gtest" max="0.019" min="0.019" noi="1" stddev="0"/>
         <Info avg="0.123" disp="true" elem="src" max="0.123" min="0.123" noi="1" stddev="0"/>
         <Info avg="0.009" disp="true" elem="test" max="0.042" min="0.001" noi="14" stddev="0.014"/>
      </Metric>
      <Metric avg="41.075" disp="true" id="METRIC.HTTPM" max="394.899" min="0.444" name="Halstead Time to Program" noi="18" stddev="91.183">
         <Info avg="100.365" disp="true" elem="division" max="100.365" min="100.365" noi="1" stddev="0"/>
         <Info avg="33.615" disp="true" elem="googlemock" max="33.615" min="33.615" noi="1" stddev="0"/>
         <Info avg="23.456" disp="true" elem="gtest" max="23.456" min="23.456" noi="1" stddev="0"/>
         <Info avg="394.899" disp="true" elem="src" max="394.899" min="394.899" noi="1" stddev="0"/>
         <Info avg="13.359" disp="true" elem="test" max="78.125" min="0.444" noi="14" stddev="26.499"/>
      </Metric>
      <Metric avg="13.056" disp="true" id="METRIC.HVOCM" max="45" min="4" name="Halstead Program Vocabulary" noi="18" stddev="10.512">
         <Info avg="20" disp="true" elem="division" max="20" min="20" noi="1" stddev="0"/>
         <Info avg="20" disp="true" elem="googlemock" max="20" min="20" noi="1" stddev="0"/>
         <Info avg="18" disp="true" elem="gtest" max="18" min="18" noi="1" stddev="0"/>
         <Info avg="45" disp="true" elem="src" max="45" min="45" noi="1" stddev="0"/>
         <Info avg="9.429" disp="true" elem="test" max="26" min="4" noi="14" stddev="6.884"/>
      </Metric>
      <Metric avg="97.397" disp="true" id="METRIC.HVOLM" max="593.12" min="8" name="Halstead Program Volume" noi="18" stddev="143.368">
         <Info avg="155.589" disp="true" elem="division" max="155.589" min="155.589" noi="1" stddev="0"/>
         <Info avg="121.014" disp="true" elem="googlemock" max="121.014" min="121.014" noi="1" stddev="0"/>
         <Info avg="112.588" disp="true" elem="gtest" max="112.588" min="112.588" noi="1" stddev="0"/>
         <Info avg="593.12" disp="true" elem="src" max="593.12" min="593.12" noi="1" stddev="0"/>
         <Info avg="55.059" disp="true" elem="test" max="288.853" min="8" noi="14" stddev="82.361"/>
      </Metric>
      <Metric avg="1.833" disp="true" id="METRIC.IDOC" max="2" min="1" name="Inheritance Depth of Class" noi="6" stddev="0.373">
         <Info avg="1.833" disp="true" elem="test" max="2" min="1" noi="6" stddev="0.373"/>
      </Metric>
      <Metric avg="0" disp="true" id="METRIC.LCOM" max="0" min="0" name="Lack of Cohesion" noi="6" stddev="0">
         <Info avg="0" disp="true" elem="test" max="0" min="0" noi="6" stddev="0"/>
      </Metric>
      <Metric avg="1.611" disp="true" id="METRIC.MCC" max="5" min="1" name="Modified Cyclomatic Complexity" noi="18" stddev="1.297">
         <Info avg="2" disp="true" elem="division" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="googlemock" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="gtest" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="src" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="1.571" disp="true" elem="test" max="5" min="1" noi="14" stddev="1.4"/>
      </Metric>
      <Metric avg="133.507" disp="true" id="METRIC.MI" max="141.183" min="114.381" name="Maintainability Index" noi="6" stddev="10.152">
         <Info avg="133.507" disp="true" elem="test" max="141.183" min="114.381" noi="6" stddev="10.152"/>
      </Metric>
      <Metric avg="0.111" disp="true" id="METRIC.NBD" max="1" min="0" name="Nested Blocks Depth" noi="18" stddev="0.314">
         <Info avg="0" disp="true" elem="division" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="googlemock" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="gtest" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="src" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="0.071" disp="true" elem="test" max="1" min="0" noi="14" stddev="0.258"/>
      </Metric>
      <Metric avg="4.875" disp="true" id="METRIC.NOBLIF" max="14" min="1" name="Blank Lines in Files" noi="8" stddev="3.951">
         <Info avg="4" disp="true" elem="division" max="4" min="4" noi="1" stddev="0"/>
         <Info avg="3.5" disp="true" elem="googlemock" max="4" min="3" noi="2" stddev="0.5"/>
         <Info avg="2.5" disp="true" elem="gtest" max="3" min="2" noi="2" stddev="0.5"/>
         <Info avg="8" disp="true" elem="src" max="8" min="8" noi="1" stddev="0"/>
         <Info avg="7.5" disp="true" elem="test" max="14" min="1" noi="2" stddev="6.5"/>
      </Metric>
      <Metric avg="0.467" disp="true" id="METRIC.NOBLIM" max="5" min="0" name="Blank Lines in Methods" noi="15" stddev="1.31">
         <Info avg="2" disp="true" elem="division" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="5" disp="true" elem="gtest" max="5" min="5" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="test" max="0" min="0" noi="13" stddev="0"/>
      </Metric>
      <Metric avg="0.667" disp="true" id="METRIC.NOBLIT" max="4" min="0" name="Blank Lines in Types" noi="6" stddev="1.491">
         <Info avg="0.667" disp="true" elem="test" max="4" min="0" noi="6" stddev="1.491"/>
      </Metric>
      <Metric avg="1" disp="true" id="METRIC.NOC" max="1" min="1" name="Number of Classes" noi="6" stddev="0">
         <Info avg="1" disp="true" elem="test" max="1" min="1" noi="6" stddev="0"/>
      </Metric>
      <Metric avg="18.375" disp="true" id="METRIC.NOCLIF" max="39" min="0" name="Comment Lines in Files" noi="8" stddev="16.911">
         <Info avg="3" disp="true" elem="division" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="38" disp="true" elem="googlemock" max="39" min="37" noi="2" stddev="1"/>
         <Info avg="32" disp="true" elem="gtest" max="36" min="28" noi="2" stddev="4"/>
         <Info avg="1" disp="true" elem="src" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1.5" disp="true" elem="test" max="3" min="0" noi="2" stddev="1.5"/>
      </Metric>
      <Metric avg="0.333" disp="true" id="METRIC.NOCLIM" max="5" min="0" name="Comment Lines in Methods" noi="15" stddev="1.247">
         <Info avg="0" disp="true" elem="division" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="5" disp="true" elem="gtest" max="5" min="5" noi="1" stddev="0"/>
         <Info avg="0" disp="true" elem="test" max="0" min="0" noi="13" stddev="0"/>
      </Metric>
      <Metric avg="0" disp="true" id="METRIC.NOCLIT" max="0" min="0" name="Comment Lines in Types" noi="6" stddev="0">
         <Info avg="0" disp="true" elem="test" max="0" min="0" noi="6" stddev="0"/>
      </Metric>
      <Metric avg="1" disp="true" id="METRIC.NOF" max="1" min="1" name="Number of Files" noi="8" stddev="0">
         <Info avg="1" disp="true" elem="division" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="googlemock" max="1" min="1" noi="2" stddev="0"/>
         <Info avg="1" disp="true" elem="gtest" max="1" min="1" noi="2" stddev="0"/>
         <Info avg="1" disp="true" elem="src" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="test" max="1" min="1" noi="2" stddev="0"/>
      </Metric>
      <Metric avg="7.833" disp="true" id="METRIC.NOLLOCIF" max="21" min="2" name="Logical Lines in Files" noi="6" stddev="7.151">
         <Info avg="4" disp="true" elem="division" max="4" min="4" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="googlemock" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="gtest" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="14" disp="true" elem="src" max="14" min="14" noi="1" stddev="0"/>
         <Info avg="11.5" disp="true" elem="test" max="21" min="2" noi="2" stddev="9.5"/>
      </Metric>
      <Metric avg="2.611" disp="true" id="METRIC.NOLLOCIM" max="14" min="0" name="Logical Lines in Methods" noi="18" stddev="3.803">
         <Info avg="4" disp="true" elem="division" max="4" min="4" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="googlemock" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="gtest" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="14" disp="true" elem="src" max="14" min="14" noi="1" stddev="0"/>
         <Info avg="1.643" disp="true" elem="test" max="9" min="0" noi="14" stddev="2.869"/>
      </Metric>
      <Metric avg="3.5" disp="true" id="METRIC.NOLLOCIT" max="9" min="1" name="Logical Lines in Types" noi="6" stddev="3.547">
         <Info avg="3.5" disp="true" elem="test" max="9" min="1" noi="6" stddev="3.547"/>
      </Metric>
      <Metric avg="1.722" disp="true" id="METRIC.NOMCIM" max="11" min="0" name="Method Calls In Methods" noi="18" stddev="2.724">
         <Info avg="0" disp="true" elem="division" max="0" min="0" noi="1" stddev="0"/>
         <Info avg="2" disp="true" elem="googlemock" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="gtest" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="src" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="1.643" disp="true" elem="test" max="11" min="0" noi="14" stddev="3.014"/>
      </Metric>
      <Metric avg="3.833" disp="true" id="METRIC.NOMIT" max="4" min="3" name="Number of Methods in Types" noi="6" stddev="0.373">
         <Info avg="3.833" disp="true" elem="test" max="4" min="3" noi="6" stddev="0.373"/>
      </Metric>
      <Metric avg="0.704" disp="true" id="METRIC.NOPAR" max="2" min="0" name="Parameters of Methods" noi="27" stddev="0.71">
         <Info avg="2" disp="true" elem="googlemock" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="2" disp="true" elem="gtest" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="2" disp="true" elem="src" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="0.542" disp="true" elem="test" max="2" min="0" noi="24" stddev="0.576"/>
      </Metric>
      <Metric avg="37.75" disp="true" id="METRIC.NOPLIF" max="63" min="6" name="Physical Lines in Files" noi="8" stddev="17.887">
         <Info avg="16" disp="true" elem="division" max="16" min="16" noi="1" stddev="0"/>
         <Info avg="50" disp="true" elem="googlemock" max="54" min="46" noi="2" stddev="4"/>
         <Info avg="42" disp="true" elem="gtest" max="47" min="37" noi="2" stddev="5"/>
         <Info avg="33" disp="true" elem="src" max="33" min="33" noi="1" stddev="0"/>
         <Info avg="34.5" disp="true" elem="test" max="63" min="6" noi="2" stddev="28.5"/>
      </Metric>
      <Metric avg="6.533" disp="true" id="METRIC.NOPLIM" max="43" min="1" name="Physical Lines in Methods" noi="15" stddev="10.34">
         <Info avg="10" disp="true" elem="division" max="10" min="10" noi="1" stddev="0"/>
         <Info avg="43" disp="true" elem="gtest" max="43" min="43" noi="1" stddev="0"/>
         <Info avg="3.462" disp="true" elem="test" max="13" min="1" noi="13" stddev="3.273"/>
      </Metric>
      <Metric avg="8.5" disp="true" id="METRIC.NOPLIT" max="22" min="4" name="Physical Lines in Types" noi="6" stddev="6.874">
         <Info avg="8.5" disp="true" elem="test" max="22" min="4" noi="6" stddev="6.874"/>
      </Metric>
      <Metric avg="3.333" disp="true" id="METRIC.NOPRIVMIT" max="4" min="0" name="Private Members of Types" noi="6" stddev="1.491">
         <Info avg="3.333" disp="true" elem="test" max="4" min="0" noi="6" stddev="1.491"/>
      </Metric>
      <Metric avg="1.167" disp="true" id="METRIC.NOPROTMIT" max="7" min="0" name="Protected Members of Types" noi="6" stddev="2.609">
         <Info avg="1.167" disp="true" elem="test" max="7" min="0" noi="6" stddev="2.609"/>
      </Metric>
      <Metric avg="0.833" disp="true" id="METRIC.NOPUBMIT" max="1" min="0" name="Public Members of Types" noi="6" stddev="0.373">
         <Info avg="0.833" disp="true" elem="test" max="1" min="0" noi="6" stddev="0.373"/>
      </Metric>
      <Metric avg="0.444" disp="true" id="METRIC.NORET" max="2" min="0" name="Number of Returns in Methods" noi="18" stddev="0.685">
         <Info avg="1" disp="true" elem="division" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="googlemock" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="gtest" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="2" disp="true" elem="src" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="0.214" disp="true" elem="test" max="2" min="0" noi="14" stddev="0.558"/>
      </Metric>
      <Metric avg="14.75" disp="true" id="METRIC.NOSLIF" max="46" min="5" name="Source Lines in Files" noi="8" stddev="13.112">
         <Info avg="9" disp="true" elem="division" max="9" min="9" noi="1" stddev="0"/>
         <Info avg="9.5" disp="true" elem="googlemock" max="13" min="6" noi="2" stddev="3.5"/>
         <Info avg="7.5" disp="true" elem="gtest" max="8" min="7" noi="2" stddev="0.5"/>
         <Info avg="24" disp="true" elem="src" max="24" min="24" noi="1" stddev="0"/>
         <Info avg="25.5" disp="true" elem="test" max="46" min="5" noi="2" stddev="20.5"/>
      </Metric>
      <Metric avg="5.8" disp="true" id="METRIC.NOSLIM" max="34" min="1" name="Source Lines in Methods" noi="15" stddev="8.207">
         <Info avg="8" disp="true" elem="division" max="8" min="8" noi="1" stddev="0"/>
         <Info avg="34" disp="true" elem="gtest" max="34" min="34" noi="1" stddev="0"/>
         <Info avg="3.462" disp="true" elem="test" max="13" min="1" noi="13" stddev="3.273"/>
      </Metric>
      <Metric avg="7.833" disp="true" id="METRIC.NOSLIT" max="18" min="4" name="Source Lines in Types" noi="6" stddev="5.61">
         <Info avg="7.833" disp="true" elem="test" max="18" min="4" noi="6" stddev="5.61"/>
      </Metric>
      <Metric avg="1" disp="true" id="METRIC.NOT" max="1" min="1" name="Number of Types" noi="6" stddev="0">
         <Info avg="1" disp="true" elem="test" max="1" min="1" noi="6" stddev="0"/>
      </Metric>
      <Metric avg="7.333" disp="true" id="METRIC.RFC" max="15" min="4" name="Response for Class" noi="6" stddev="4.749">
         <Info avg="7.333" disp="true" elem="test" max="15" min="4" noi="6" stddev="4.749"/>
      </Metric>
      <Metric avg="1.611" disp="true" id="METRIC.SCC" max="5" min="1" name="Strict Cyclomatic Complexity" noi="18" stddev="1.297">
         <Info avg="2" disp="true" elem="division" max="2" min="2" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="googlemock" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="1" disp="true" elem="gtest" max="1" min="1" noi="1" stddev="0"/>
         <Info avg="3" disp="true" elem="src" max="3" min="3" noi="1" stddev="0"/>
         <Info avg="1.571" disp="true" elem="test" max="5" min="1" noi="14" stddev="1.4"/>
      </Metric>
      <Metric avg="3.5" disp="true" id="METRIC.WMC" max="7" min="2" name="Weighted Methods of Class" noi="6" stddev="2.141">
         <Info avg="3.5" disp="true" elem="test" max="7" min="2" noi="6" stddev="2.141"/>
      </Metric>
   </Metrics>
   <Scope>
      <Repositories/>
      <Locations>
         <Loc auth="lyao" hash="1535005727" locRef="1" projId="src" projPath="/src" project="src" resProjPath="../../../../../../../../src/main.cpp" totLns="33" uri="file:/D:/reports/projects/cppprojecttemplate/src/main.cpp"/>
         <Loc auth="lyao" hash="2105514256" locRef="2" projId="division" projPath="/division" project="division" resProjPath="../../../../../../../../src/division/division.cpp" totLns="16" uri="file:/D:/reports/projects/cppprojecttemplate/src/division/division.cpp"/>
         <Loc auth="lyao" hash="1598712918" locRef="3" projId="test" projPath="/test" project="test" resProjPath="../../../../../../../../test/main.cpp" totLns="6" uri="file:/D:/reports/projects/cppprojecttemplate/test/main.cpp"/>
         <Loc auth="lyao" hash="-69735008" locRef="4" projId="test" projPath="/test" project="test" resProjPath="../../../../../../../../test/src/divider_tests.cpp" totLns="63" uri="file:/D:/reports/projects/cppprojecttemplate/test/src/divider_tests.cpp"/>
         <Loc auth="lyao" hash="1220095087" locRef="5" projId="googlemock" projPath="/googlemock" project="googlemock" resProjPath="../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" totLns="46" uri="file:/D:/reports/projects/cppprojecttemplate/test/lib/googletest/googlemock/src/gmock-all.cc"/>
         <Loc auth="lyao" hash="1953665929" locRef="6" projId="googlemock" projPath="/googlemock" project="googlemock" resProjPath="../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" totLns="54" uri="file:/D:/reports/projects/cppprojecttemplate/test/lib/googletest/googlemock/src/gmock_main.cc"/>
         <Loc auth="lyao" hash="662837937" locRef="7" projId="gtest" projPath="/gtest" project="gtest" resProjPath="../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" totLns="47" uri="file:/D:/reports/projects/cppprojecttemplate/test/lib/googletest/googletest/src/gtest-all.cc"/>
         <Loc auth="lyao" hash="-1256976007" locRef="8" projId="gtest" projPath="/gtest" project="gtest" resProjPath="../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" totLns="37" uri="file:/D:/reports/projects/cppprojecttemplate/test/lib/googletest/googletest/src/gtest_main.cc"/>
      </Locations>
   </Scope>
   
  <SetupProblems/>

   <CodingStandards ownerId="com.parasoft.xtest.checkers.api.standards" time="0:03:08">
      <Projects>
         <Project bdCheckedFiles="0" bdTotalFiles="0" checkedFiles="1" checkedLns="33" id="src" name="src" qfixErrs="0" suppErrs="0" totErrs="301" totFiles="1" totLns="33"/>
         <Project bdCheckedFiles="0" bdTotalFiles="0" checkedFiles="2" checkedLns="84" id="gtest" name="gtest" qfixErrs="0" suppErrs="0" totErrs="155" totFiles="2" totLns="84"/>
         <Project bdCheckedFiles="0" bdTotalFiles="0" checkedFiles="1" checkedLns="16" id="division" name="division" qfixErrs="0" suppErrs="0" totErrs="55" totFiles="1" totLns="16"/>
         <Project bdCheckedFiles="0" bdTotalFiles="0" checkedFiles="2" checkedLns="69" id="test" name="test" qfixErrs="0" suppErrs="0" totErrs="538" totFiles="2" totLns="69"/>
         <Project bdCheckedFiles="0" bdTotalFiles="0" checkedFiles="2" checkedLns="100" id="googlemock" name="googlemock" qfixErrs="0" suppErrs="0" totErrs="155" totFiles="2" totLns="100"/>
      </Projects>
      
      
      <Rules>
         <CategoriesList>
            <Category authTot="0;" authUrg="0;" desc="DISA ASD STIG" name="APSC_DV" rules="105" total="0">
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001850 The application must not display passwords/PINs as clear text." name="APSC_DV-001850" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001750 The application must transmit only cryptographically-protected passwords." name="APSC_DV-001750" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-000480 The application must enforce approved authorizations for controlling the flow of information within the system based on organization-defined information flow control policies." name="APSC_DV-000480" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-000160 The application must implement DoD-approved encryption to protect the confidentiality of remote access sessions." name="APSC_DV-000160" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002460 The application must maintain the confidentiality and integrity of information during preparation for transmission." name="APSC_DV-002460" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002560 The application must not be subject to input handling vulnerabilities." name="APSC_DV-002560" rules="11" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="APSC_DV-003110 The application must not contain embedded authentication data." name="APSC_DV-003110" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002000 The application must terminate all network connections associated with a communications session at the end of the session." name="APSC_DV-002000" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002440 The application must protect the confidentiality and integrity of transmitted information." name="APSC_DV-002440" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002540 The application must not be vulnerable to SQL Injection." name="APSC_DV-002540" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-000500 The application must prevent non-privileged users from executing privileged functions to include disabling, circumventing, or altering implemented security safeguards/countermeasures." name="APSC_DV-000500" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001995 The application must not be vulnerable to race conditions." name="APSC_DV-001995" rules="9" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002520 The application must protect from canonical representation vulnerabilities." name="APSC_DV-002520" rules="11" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-003235 The application must not be subject to error handling vulnerabilities." name="APSC_DV-003235" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002400 The application must restrict the ability to launch Denial of Service (DoS) attacks against itself or other information systems." name="APSC_DV-002400" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002290 The application must use the Federal Information Processing Standard (FIPS) 140-2-validated cryptographic modules and random number generator if the application implements encryption, key exchange, digital signature, and hash functionality." name="APSC_DV-002290" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002390 XML-based applications must mitigate DoS attacks by using XML filters, parser options, or gateways." name="APSC_DV-002390" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002590 The application must not be vulnerable to overflow attacks." name="APSC_DV-002590" rules="12" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-000170 The application must implement cryptographic mechanisms to protect the integrity of remote access sessions." name="APSC_DV-000170" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001300 The application must protect audit information from unauthorized deletion." name="APSC_DV-001300" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001740 The application must only store cryptographic representations of passwords." name="APSC_DV-001740" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="APSC_DV-000650 The application must not write sensitive data into the application logs." name="APSC_DV-000650" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001860 The application must use mechanisms meeting the requirements of applicable federal laws, Executive Orders, directives, policies, regulations, standards, and guidance for authentication to a cryptographic module." name="APSC_DV-001860" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002470 The application must maintain the confidentiality and integrity of information during reception." name="APSC_DV-002470" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002350 The application must use appropriate cryptography in order to protect stored DoD information when required by the information owner or DoD policy." name="APSC_DV-002350" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="APSC_DV-002570 The application must generate error messages that provide information necessary for corrective actions without revealing information that could be exploited by adversaries." name="APSC_DV-002570" rules="2" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002010 The application must implement NSA-approved cryptography to protect classified information in accordance with applicable federal laws, Executive Orders, directives, policies, regulations, and standards." name="APSC_DV-002010" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002550 The application must not be vulnerable to XML-oriented attacks." name="APSC_DV-002550" rules="11" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002530 The application must validate all input." name="APSC_DV-002530" rules="11" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-002510 The application must protect from command injection." name="APSC_DV-002510" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="APSC_DV-002480 The application must not disclose unnecessary information to users." name="APSC_DV-002480" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="APSC_DV-001290 The application must protect audit information from unauthorized modification." name="APSC_DV-001290" rules="4" total="0"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="AUTOSAR C++14 Coding Guidelines" name="AUTOSAR" rules="567" total="0">
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A16-6-1 #error directive shall not be used" name="AUTOSAR-A16_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-3-1 All overloads of a function shall be visible from where it is called" name="AUTOSAR-A7_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M8-5-2 Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures" name="AUTOSAR-M8_5_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-5-1 A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" name="AUTOSAR-A6_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A25-4-1 Ordering predicates used with associative containers and STL sorting and related algorithms shall adhere to a strict weak ordering relation" name="AUTOSAR-A25_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-1-1 The assignment-expression of a throw statement shall not itself cause an exception to be thrown" name="AUTOSAR-M15_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-1-3 An empty throw (throw;) shall only be used in the compound statement of a catch handler" name="AUTOSAR-M15_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-1-2 NULL shall not be thrown explicitly" name="AUTOSAR-M15_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-7-1 If the behavior of a user-defined special member function is identical to implicitly defined special member function, then it shall be defined &quot;=default&quot; or be left undefined" name="AUTOSAR-A12_7_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-3-2 The unary minus operator shall not be applied to an expression whose underlying type is unsigned" name="AUTOSAR-M5_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-3-1 Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" name="AUTOSAR-M5_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-3-4 Evaluation of the operand to the sizeof operator shall not contain side effects" name="AUTOSAR-M5_3_4" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-3-3 The unary &amp; operator shall not be overloaded" name="AUTOSAR-M5_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-5-2 All user-defined conversion operators shall be defined explicit" name="AUTOSAR-A13_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-5-3 User-defined conversion operators should not be used" name="AUTOSAR-A13_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-6-1 The goto statement shall not be used" name="AUTOSAR-A6_6_1" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR M27-0-1 The stream input/output library &lt;cstdio> shall not be used" name="AUTOSAR-M27_0_1" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-5-1 If &quot;operator[]&quot; is to be overloaded with a non-const version, const version shall also be implemented" name="AUTOSAR-A13_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-16-1 The ternary conditional operator shall not be used as a sub-expression" name="AUTOSAR-A5_16_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-5-4 If two opposite operators are defined, one shall be defined in terms of the other" name="AUTOSAR-A13_5_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-5-5 Comparison operators shall be non-member functions with identical parameter types and noexcept" name="AUTOSAR-A13_5_5" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A23-0-2 Elements of a container shall only be accessed via valid references, iterators, and pointers" name="AUTOSAR-A23_0_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-1-4 If a function exits with an exception, then before a throw, the function shall place all objects/resources that the function constructed in valid states or it shall delete them" name="AUTOSAR-A15_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A23-0-1 An iterator shall not be implicitly converted to const_iterator" name="AUTOSAR-A23_0_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M4-5-3 Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator =, the equality operators == and !=, and the unary &amp; operator" name="AUTOSAR-M4_5_3" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="AUTOSAR A15-1-5 Exceptions shall not be thrown across execution boundaries" name="AUTOSAR-A15_1_5" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-17-1 The semantic equivalence between a binary operator and its assignment operator form shall be preserved" name="AUTOSAR-M5_17_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-1-2 An exception object shall not be a pointer" name="AUTOSAR-A15_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M4-5-1 Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator" name="AUTOSAR-M4_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-1-10 Every defined function should be called at least once" name="AUTOSAR-M0_1_10" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-1-1 Only instances of types derived from std::exception shall be thrown" name="AUTOSAR-A15_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A10-4-1 Hierarchies should be based on interface classes" name="AUTOSAR-A10_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A16-7-1 The #pragma directive shall not be used" name="AUTOSAR-A16_7_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A11-0-1 A non-POD type should be defined as class" name="AUTOSAR-A11_0_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A11-0-2 A type defined as struct shall: (1) provide only public data members, (2) not provide any special member functions or methods, (3) not be a base of another struct or class, (4) not inherit from another struct or class" name="AUTOSAR-A11_0_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-2-3 Enumerations shall be declared as scoped enum classes" name="AUTOSAR-A7_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M8-4-4 A function identifier shall either be used to call the function or it shall be preceded by &amp;" name="AUTOSAR-M8_4_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-2-2 Enumeration underlying base type shall be explicitly defined" name="AUTOSAR-A7_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-2-1 An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" name="AUTOSAR-A7_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M8-4-2 The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration" name="AUTOSAR-M8_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-7-1 The character \ shall not occur as a last character of a C++ comment" name="AUTOSAR-A2_7_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M3-9-1 The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" name="AUTOSAR-M3_9_1" rules="1" total="0"/>
               <Category authTot="27;" authUrg="2;" desc="AUTOSAR A2-7-3 All declarations of &quot;user-defined&quot; types, static and non-static data members, functions and methods shall be preceded by documentation using &quot;///&quot; comments and &quot;@tag&quot; tags" name="AUTOSAR-A2_7_3" rules="2" total="27"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-7-2 Sections of code shall not be &quot;commented out&quot;" name="AUTOSAR-A2_7_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M12-1-1 An object's dynamic type shall not be used from the body of its constructor or destructor" name="AUTOSAR-M12_1_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M3-9-3 The underlying bit representations of floating-point values shall not be used" name="AUTOSAR-M3_9_3" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR A1-1-1 All code shall conform to ISO/IEC 14882:2014 - Programming Language C++ and shall not use deprecated features" name="AUTOSAR-A1_1_1" rules="11" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M3-1-2 Functions shall not be declared at block scope" name="AUTOSAR-M3_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-4-1 A switch statement shall have at least two case-clauses, distinct from the default label" name="AUTOSAR-A6_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-6-1 All class data members that are initialized by the constructor shall be initialized using member initializers" name="AUTOSAR-A12_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-0-3 Control shall not be transferred into a try or catch block using a goto or a switch statement" name="AUTOSAR-M15_0_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-6 A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" name="AUTOSAR-M5_2_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-9 A cast shall not convert a pointer type to an integral type" name="AUTOSAR-M5_2_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M14-5-3 A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" name="AUTOSAR-M14_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M18-2-1 The macro offsetof shall not be used" name="AUTOSAR-M18_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-8 An object with integer type or pointer to void type shall not be converted to an object with pointer type" name="AUTOSAR-M5_2_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-6-1 The right hand operand of the integer division or remainder operators shall not be equal to zero" name="AUTOSAR-A5_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-3 Casts from a base class to a derived class should not be performed on polymorphic types" name="AUTOSAR-M5_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-2 A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" name="AUTOSAR-M5_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-5-3 Do statements should not be used" name="AUTOSAR-A6_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-5-2 A for loop shall contain a single loop-counter which shall not have floating-point type" name="AUTOSAR-A6_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-13-5 Hexadecimal constants should be upper case" name="AUTOSAR-A2_13_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-13-6 Universal character names shall be used only inside character or string literals" name="AUTOSAR-A2_13_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-5-4 For-init-statement and expression should not perform actions other than loop-counter initialization and modification" name="AUTOSAR-A6_5_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-13-3 Type wchar_t shall not be used" name="AUTOSAR-A2_13_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-13-4 String literals shall not be assigned to non-constant pointers" name="AUTOSAR-A2_13_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-13-1 Only those escape sequences that are defined in ISO/IEC 14882:2014 shall be used" name="AUTOSAR-A2_13_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-13-2 String literals with different encoding prefixes shall not be concatenated" name="AUTOSAR-A2_13_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-15 Array indexing shall be the only form of pointer arithmetic" name="AUTOSAR-M5_0_15" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-16 A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" name="AUTOSAR-M5_0_16" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-17 Subtraction between pointers shall only be applied to pointers that address elements of the same array" name="AUTOSAR-M5_0_17" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-18 >, >=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array" name="AUTOSAR-M5_0_18" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-0-2 At least the basic guarantee for exception safety shall be provided for all operations. In addition, each function may offer either the strong guarantee or the nothrow guarantee" name="AUTOSAR-A15_0_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M9-3-1 Const member functions shall not return non-const pointers or references to class-data" name="AUTOSAR-M9_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-10 If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" name="AUTOSAR-M5_0_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M9-3-3 If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" name="AUTOSAR-M9_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-11 The plain char type shall only be used for the storage and use of character values" name="AUTOSAR-M5_0_11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-12 Signed char and unsigned char type shall only be used for the storage and use of numeric values" name="AUTOSAR-M5_0_12" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-14 The first operand of a conditional-operator shall have type bool" name="AUTOSAR-M5_0_14" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-1-2 A pointer or reference parameter in a function shall be declared as pointer to const or reference to const if the corresponding object is not modified" name="AUTOSAR-M7_1_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-4 The register keyword shall not be used" name="AUTOSAR-A7_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-3 CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name" name="AUTOSAR-A7_1_3" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="AUTOSAR A7-1-2 The constexpr specifier shall be used for values that can be determined at compile time" name="AUTOSAR-A7_1_2" rules="2" total="2"/>
               <Category authTot="3;" authUrg="1;" desc="AUTOSAR A7-1-1 Constexpr or const specifiers shall be used for immutable data declaration" name="AUTOSAR-A7_1_1" rules="2" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-8-1 A header file name shall be identical to a type name declared in it if it declares a type" name="AUTOSAR-A2_8_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-11-1 Volatile keyword shall not be used" name="AUTOSAR-A2_11_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A9-5-1 Unions shall not be used" name="AUTOSAR-A9_5_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-3-1 The statement forming the body of a switch, while, do ... while or for statement shall be a compound statement" name="AUTOSAR-M6_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-20 Non-constant operands to a binary bitwise operator shall have the same underlying type" name="AUTOSAR-M5_0_20" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-21 Bitwise operators shall only be applied to operands of unsigned underlying type" name="AUTOSAR-M5_0_21" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR A18-0-1 The C library facilities shall only be accessed through C++ library headers" name="AUTOSAR-A18_0_1" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-0-3 The library &lt;clocale> (locale.h) and the setlocale function shall not be used" name="AUTOSAR-A18_0_3" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-4-2 Use of floating-point arithmetic shall be documented" name="AUTOSAR-M0_4_2" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A18-0-2 The error state of a conversion from string to a numeric value shall be checked" name="AUTOSAR-A18_0_2" rules="2" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-3-1 A function that contains &quot;forwarding reference&quot; as its argument shall not be overloaded" name="AUTOSAR-A13_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-5-1 A pointer to member shall not access non-existent class members" name="AUTOSAR-A5_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M14-6-1 In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" name="AUTOSAR-M14_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-4-2 Type long double shall not be used" name="AUTOSAR-A0_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-4-4 Range, domain and pole errors shall be checked when using math functions" name="AUTOSAR-A0_4_4" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A4-7-1 An integer expression shall not lead to data loss" name="AUTOSAR-A4_7_1" rules="11" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-2-5 Enumerations should be used to represent sets of related named constants" name="AUTOSAR-A7_2_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-2-4 In an enumeration, either (1) none, (2) the first or (3) all enumerators shall be initialized" name="AUTOSAR-A7_2_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-6 std::make_shared shall be used to construct objects owned by std::shared_ptr" name="AUTOSAR-A20_8_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-5 std::make_unique shall be used to construct objects owned by std::unique_ptr" name="AUTOSAR-A20_8_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-7 A std::weak_ptr shall be used to represent temporary shared ownership" name="AUTOSAR-A20_8_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-2 A std::unique_ptr shall be used to represent exclusive ownership" name="AUTOSAR-A20_8_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-1 An already-owned pointer value shall not be stored in an unrelated smart pointer" name="AUTOSAR-A20_8_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-4 A std::unique_ptr shall be used over std::shared_ptr if ownership sharing is not required" name="AUTOSAR-A20_8_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A20-8-3 A std::shared_ptr shall be used to represent shared ownership" name="AUTOSAR-A20_8_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A9-6-1 Data types used for interfacing with hardware or conforming to communication protocols shall be trivial, standard-layout and only contain members of types with defined sizes" name="AUTOSAR-A9_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-2-3 Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character" name="AUTOSAR-M6_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-2-2 Floating-point expressions shall not be directly or indirectly tested for equality or inequality" name="AUTOSAR-M6_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-4-1 Destructor of a base class shall be public virtual, public override or protected non-virtual" name="AUTOSAR-A12_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-10-1 An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" name="AUTOSAR-A2_10_1" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-2-1 Assignment operators shall not be used in sub-expressions" name="AUTOSAR-M6_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-2-2 Expression statements shall not be explicit calls to constructors of temporary objects only" name="AUTOSAR-A6_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A6-2-1 Move and copy assignment operators shall either move or respectively copy base classes and data members of a class, without any side effects" name="AUTOSAR-A6_2_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A9-6-2 Bit-fields shall be used only when interfacing to hardware or conforming to communication protocols" name="AUTOSAR-A9_6_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-4-2 If a public destructor of a class is non-virtual, then the class should be declared final" name="AUTOSAR-A12_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-11 &quot;operator new&quot; and &quot;operator delete&quot; shall be defined together" name="AUTOSAR-A18_5_11" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-11 A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" name="AUTOSAR-A8_4_11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-10 Placement new shall be used only with properly aligned pointers to sufficient storage capacity" name="AUTOSAR-A18_5_10" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-10 A parameter shall be passed by reference if it can't be NULL" name="AUTOSAR-A8_4_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-13 A std::shared_ptr shall be passed to a function as: (1) a copy to express the function shares ownership (2) an lvalue reference to express that the function replaces the managed object (3) a const lvalue reference to express that the function retains a reference count" name="AUTOSAR-A8_4_13" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-12 A std::unique_ptr shall be passed to a function as: (1) a copy to express the function assumes ownership (2) an lvalue reference to express that the function replaces the managed object" name="AUTOSAR-A8_4_12" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-1-2 The std::vector&lt;bool> specialization shall not be used" name="AUTOSAR-A18_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-1-1 C-style arrays shall not be used" name="AUTOSAR-A18_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-2-1 An assignment operator shall return a reference to &quot;this&quot;" name="AUTOSAR-A13_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-1-4 A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" name="AUTOSAR-A18_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M18-0-3 The library functions abort, exit, getenv and system from library &lt;cstdlib> shall not be used" name="AUTOSAR-M18_0_3" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-2-2 A binary arithmetic operator and a bitwise operator shall return a &quot;prvalue&quot;" name="AUTOSAR-A13_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-1-3 The std::auto_ptr type shall not be used" name="AUTOSAR-A18_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-1-6 All std::hash specializations for user-defined types shall have a noexcept function call operator" name="AUTOSAR-A18_1_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-2-3 A relational operator shall return a boolean value" name="AUTOSAR-A13_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M18-0-5 The unbounded functions of library &lt;cstring> shall not be used" name="AUTOSAR-M18_0_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M18-0-4 The time handling functions of library &lt;ctime> shall not be used" name="AUTOSAR-M18_0_4" rules="3" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR M2-10-1 Different identifiers shall be typographically unambiguous" name="AUTOSAR-M2_10_1" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-14-1 The right hand operand of a logical &amp;&amp;, || operators shall not contain side effects" name="AUTOSAR-M5_14_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-9 A class, structure, or enumeration shall not be declared in the definition of its type" name="AUTOSAR-A7_1_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-8 A non-type specifier shall be placed before a type specifier in a declaration" name="AUTOSAR-A7_1_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-7 Each expression statement and identifier declaration shall be placed on a separate line" name="AUTOSAR-A7_1_7" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-6 The typedef specifier shall not be used" name="AUTOSAR-A7_1_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-1-5 The auto specifier shall not be used apart from following cases: (1) to declare that a variable has the same type as return type of a function call, (2) to declare that a variable has the same type as initializer of non-fundamental type, (3) to declare parameters of a generic lambda expression, (4) to declare a function template using trailing return type syntax" name="AUTOSAR-A7_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-9-2 Forwarding values to other functions shall be done via: (1) std::move if the value is an rvalue reference, (2) std::forward if the value is forwarding reference" name="AUTOSAR-A18_9_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-9-1 The std::bind shall not be used" name="AUTOSAR-A18_9_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-9-4 An argument to std::forward shall not be subsequently used" name="AUTOSAR-A18_9_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-9-3 The std::move shall not be used on objects declared const or const&amp;" name="AUTOSAR-A18_9_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A14-8-2 Explicit specializations of function templates shall not be used" name="AUTOSAR-A14_8_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-8-1 An object shall not be accessed outside of its lifetime" name="AUTOSAR-A3_8_1" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-3-2 The # and ## operators should not be used" name="AUTOSAR-M16_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-5-4 If a class has a user-declared constructor that takes a parameter of type std::initializer_list, then it shall be the only constructor apart from special member function constructors" name="AUTOSAR-A8_5_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-3-1 There shall be at most one occurrence of the # or ## operators in a single macro definition" name="AUTOSAR-M16_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-3-2 The identifier main shall not be used for a function other than the global function main" name="AUTOSAR-M7_3_2" rules="1" total="0"/>
               <Category authTot="3;" authUrg="0;" desc="AUTOSAR M7-3-1 The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" name="AUTOSAR-M7_3_1" rules="1" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A16-2-1 The ', &quot;, /*, //, \ characters shall not occur in a header file name or in #include directive" name="AUTOSAR-A16_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-5-1 In an initialization list, the order of initialization shall be following: (1) virtual base classes in depth and left to right order of the inheritance graph, (2) direct base classes in left to right order of inheritance list, (3) non-static data members in the order they were declared in the class definition" name="AUTOSAR-A8_5_1" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="AUTOSAR M7-3-4 Using-directives shall not be used" name="AUTOSAR-M7_3_4" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-5-0 All memory shall be initialized before it is read" name="AUTOSAR-A8_5_0" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-3-3 There shall be no unnamed namespaces in header files" name="AUTOSAR-M7_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-5-3 A variable of type auto shall not be initialized using {} or ={} braced-initialization" name="AUTOSAR-A8_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-3-6 Using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" name="AUTOSAR-M7_3_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A16-2-2 There shall be no unused include directives" name="AUTOSAR-A16_2_2" rules="1" total="0"/>
               <Category authTot="13;" authUrg="1;" desc="AUTOSAR A8-5-2 Braced-initialization {}, without equals sign, shall be used for variable initialization" name="AUTOSAR-A8_5_2" rules="1" total="13"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A17-0-1 Reserved identifiers, macros and functions in the C++ standard library shall not be defined, redefined or undefined" name="AUTOSAR-A17_0_1" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A9-3-1 Member functions shall not return non-const &quot;raw&quot; pointers or references to private or protected data owned by the class" name="AUTOSAR-A9_3_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-5-5 A loop-control-variable other than the loop-counter shall not be modified within condition or expression" name="AUTOSAR-M6_5_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-5-4 The loop-counter shall be modified by one of: --, ++, -= n, or += n; where n remains constant for the duration of the loop" name="AUTOSAR-M6_5_4" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR M3-4-1 An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" name="AUTOSAR-M3_4_1" rules="2" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-5-3 The loop-counter shall not be modified within condition or statement" name="AUTOSAR-M6_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-5-2 If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" name="AUTOSAR-M6_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-5-6 A loop-control-variable other than the loop-counter which is modified in statement shall have type bool" name="AUTOSAR-M6_5_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-1-2 User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" name="AUTOSAR-A13_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-2-1 An object shall not be assigned to an overlapping object" name="AUTOSAR-M0_2_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M4-10-1 NULL shall not be used as an integer value" name="AUTOSAR-M4_10_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-1-3 User defined literals operators shall only perform conversion of passed parameters" name="AUTOSAR-A13_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-3-3 Pointers to incomplete class types shall not be deleted" name="AUTOSAR-A5_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-3-2 Null pointers shall not be dereferenced" name="AUTOSAR-A5_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-3-1 Evaluation of the operand to the typeid operator shall not contain side effects" name="AUTOSAR-A5_3_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M18-7-1 The signal handling facilities of &lt;csignal> shall not be used" name="AUTOSAR-M18_7_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A26-5-1 Pseudorandom numbers shall not be generated using std::rand()" name="AUTOSAR-A26_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M4-10-2 Literal zero (0) shall not be used as the null-pointer-constant" name="AUTOSAR-M4_10_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-10-6 A class or enumeration name shall not be hidden by a variable, function or enumerator declaration in the same scope" name="AUTOSAR-A2_10_6" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A26-5-2 Random number engines shall not be default-initialized" name="AUTOSAR-A26_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-10-4 The identifier name of a non-member object with static storage duration or static function shall not be reused within a namespace" name="AUTOSAR-A2_10_4" rules="2" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A2-10-5 An identifier name of a function with static storage duration or a non-member object with external or internal linkage should not be reused" name="AUTOSAR-A2_10_5" rules="4" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A4-5-1 Expressions with type enum or enum class shall not be used as operands to built-in and overloaded operators other than the subscript operator [ ], the assignment operator =, the equality operators == and !=, the unary &amp; operator, and the relational operators &lt;, &lt;=, >, >=" name="AUTOSAR-A4_5_1" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A15-5-3 The std::terminate() function shall not be called implicitly" name="AUTOSAR-A15_5_3" rules="11" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-5-2 Program shall not be abruptly terminated. In particular, an implicit or explicit invocation of std::abort(), std::quick_exit(), std::_Exit(), std::terminate() shall not be done" name="AUTOSAR-A15_5_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-5-1 All user-provided class destructors, deallocation functions, move constructors, move assignment operators and swap functions shall not exit with an exception. A noexcept exception specification shall be added to these functions as appropriate" name="AUTOSAR-A15_5_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M9-6-4 Named bit-fields with signed integer type shall have a length of more than one bit" name="AUTOSAR-M9_6_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-10 The increment (++) and decrement (--) operators shall not be mixed with other operators in an expression" name="AUTOSAR-M5_2_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-12 An identifier with array type passed as a function argument shall not decay to a pointer" name="AUTOSAR-M5_2_12" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-2-11 The comma operator, &amp;&amp; operator and the || operator shall not be overloaded" name="AUTOSAR-M5_2_11" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A14-7-2 Template specialization shall be declared in the same file (1) as the primary template (2) as a user-defined type, for which the specialization is declared" name="AUTOSAR-A14_7_2" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A3-9-1 Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" name="AUTOSAR-A3_9_1" rules="2" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-2-3 Include guards shall be provided" name="AUTOSAR-M16_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-1-6 Trivial accessor and mutator functions should be inlined" name="AUTOSAR-A3_1_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-1-5 A function definition shall only be placed in a class definition if (1) the function is intended to be inlined (2) it is a member function template (3) it is a member function of a class template" name="AUTOSAR-A3_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-1-4 When an array with external linkage is declared, its size shall be stated explicitly" name="AUTOSAR-A3_1_4" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A3-1-3 Implementation files, that are defined locally in the project, should have a file name extension of &quot;.cpp&quot;" name="AUTOSAR-A3_1_3" rules="1" total="4"/>
               <Category authTot="12;" authUrg="0;" desc="AUTOSAR A3-1-2 Header files, that are defined locally in the project, shall have a file name extension of one of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" name="AUTOSAR-A3_1_2" rules="1" total="12"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-1-1 It shall be possible to include any header file in multiple translation units without violating the One Definition Rule" name="AUTOSAR-A3_1_1" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR A2-3-1 Only those characters specified in the C++ Language Standard basic source character set shall be used in the source code" name="AUTOSAR-A2_3_1" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M10-1-2 A base class shall only be declared virtual if it is used in a diamond hierarchy" name="AUTOSAR-M10_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M10-1-1 Classes should not be derived from virtual bases" name="AUTOSAR-M10_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M8-0-1 An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively" name="AUTOSAR-M8_0_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-4-2 All if ... else if constructs shall be terminated with an else clause" name="AUTOSAR-M6_4_2" rules="1" total="0"/>
               <Category authTot="1;" authUrg="1;" desc="AUTOSAR M6-4-1 An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement" name="AUTOSAR-M6_4_1" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A17-1-1 Use of the C Standard Library shall be encapsulated and isolated" name="AUTOSAR-A17_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A21-8-1 Arguments to character-handling functions shall be representable as an unsigned char" name="AUTOSAR-A21_8_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M10-1-3 An accessible base class shall not be both virtual and non-virtual in the same hierarchy" name="AUTOSAR-M10_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-4-6 The final clause of a switch statement shall be the default-clause" name="AUTOSAR-M6_4_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A25-1-1 Non-static data members or captured values of predicate function objects that are state related to this object's identity shall not be copied" name="AUTOSAR-A25_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-4-5 An unconditional throw or break statement shall terminate every non-empty switch-clause" name="AUTOSAR-M6_4_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-4-4 A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" name="AUTOSAR-M6_4_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-4-3 A switch statement shall be a well-formed switch statement" name="AUTOSAR-M6_4_3" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M2-7-1 The character sequence /* shall not be used within a C-style comment" name="AUTOSAR-M2_7_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-4-7 The condition of a switch statement shall not have bool type" name="AUTOSAR-M6_4_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-2-1 dynamic_cast should not be used" name="AUTOSAR-A5_2_1" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR M0-3-2 If a function generates error information, then that error information shall be tested" name="AUTOSAR-M0_3_2" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-2-5 An array or container shall not be accessed beyond its range" name="AUTOSAR-A5_2_5" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-3-1 Minimization of run-time failures shall be ensured by the use of at least one of: (a) static analysis tools/techniques; (b) dynamic analysis tools/techniques; (c) explicit coding of checks to handle run-time faults" name="AUTOSAR-M0_3_1" rules="10" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-2-4 reinterpret_cast shall not be used" name="AUTOSAR-A5_2_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-2-3 A cast shall not remove any const or volatile qualification from the type of a pointer or reference" name="AUTOSAR-A5_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-2-2 Traditional C-style casts shall not be used" name="AUTOSAR-A5_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-4-5 Checked exceptions that could be thrown from a function shall be specified together with the function declaration and they shall be identical in all function declarations and for all its overriders" name="AUTOSAR-A15_4_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M17-0-2 The names of standard library macros and objects shall not be reused" name="AUTOSAR-M17_0_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-4-3 The noexcept specification of a function shall either be identical across all translation units, or identical or more restrictive between a virtual member function and an overrider" name="AUTOSAR-A15_4_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-4-4 A declaration of non-throwing function shall contain noexcept specification" name="AUTOSAR-A15_4_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M17-0-3 The names of standard library functions shall not be overridden" name="AUTOSAR-M17_0_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-4-1 Dynamic exception-specification shall not be used" name="AUTOSAR-A15_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-4-2 If a function is declared to be noexcept, noexcept(true) or noexcept(&lt;true condition>), then it shall not exit with an exception" name="AUTOSAR-A15_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A10-1-1 Class shall not be derived from more than one base class which is not an interface class" name="AUTOSAR-A10_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M17-0-5 The setjmp macro and the longjmp function shall not be used" name="AUTOSAR-M17_0_5" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-1-2 All #else, #elif and #endif pre-processor directives shall reside in the same file as the #if or #ifdef directive to which they are related" name="AUTOSAR-M16_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A11-3-1 Friend declarations shall not be used" name="AUTOSAR-A11_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-1-1 The defined pre-processor operator shall only be used in one of the two standard forms" name="AUTOSAR-M16_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-5-2 The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" name="AUTOSAR-M7_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-5-1 A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function" name="AUTOSAR-M7_5_1" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR M3-2-4 An identifier with external linkage shall have exactly one definition" name="AUTOSAR-M3_2_4" rules="2" total="4"/>
               <Category authTot="3;" authUrg="0;" desc="AUTOSAR A16-0-1 The pre-processor shall only be used for unconditional and conditional file inclusion and include guards, and using the following directives: (1) #ifndef, (2) #ifdef, (3) #if, (4) #if defined, (5) #elif, (6) #else, (7) #define, (8) #endif, (9) #include" name="AUTOSAR-A16_0_1" rules="5" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M10-2-1 All accessible entity names within a multiple inheritance hierarchy should be unique" name="AUTOSAR-M10_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M8-3-1 Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments" name="AUTOSAR-M8_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-1-1 Constructors shall explicitly initialize all virtual base classes, all direct non-virtual base classes and all non-static data members" name="AUTOSAR-A12_1_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-1-2 Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type" name="AUTOSAR-A12_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-3-4 Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" name="AUTOSAR-M15_3_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-1-3 If all user-defined constructors of a class initialize data members with constant values that are the same across all constructors, then data members shall be initialized using NSDMI instead" name="AUTOSAR-A12_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-3-7 Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last" name="AUTOSAR-M15_3_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-1-4 All constructors that are callable with a single argument of fundamental type shall be declared explicit" name="AUTOSAR-A12_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-3-6 Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" name="AUTOSAR-M15_3_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M3-2-1 All declarations of an object or function shall have compatible types" name="AUTOSAR-M3_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A17-6-1 Non-standard entities shall not be added to standard namespaces" name="AUTOSAR-A17_6_1" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR M3-2-3 A type, object or function that is used in multiple translation units shall be declared in one and only one file" name="AUTOSAR-M3_2_3" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-10-1 A pointer to member virtual function shall only be tested for equality with null-pointer-constant" name="AUTOSAR-A5_10_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M3-2-2 The One Definition Rule shall not be violated" name="AUTOSAR-M3_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-2-6 The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" name="AUTOSAR-A5_2_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-1-5 Common class initialization for non-constant members shall be done by a delegating constructor" name="AUTOSAR-A12_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-3-1 Exceptions shall be raised only after start-up and before termination" name="AUTOSAR-M15_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-1-6 Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors" name="AUTOSAR-A12_1_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M15-3-3 Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases" name="AUTOSAR-M15_3_3" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR M11-0-1 Member data in non-POD class types shall be private" name="AUTOSAR-M11_0_1" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-1-2 Variables shall not be implicitly captured in a lambda expression" name="AUTOSAR-A5_1_2" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A5-1-1 Literal values shall not be used apart from type initialization, otherwise symbolic names shall be used instead" name="AUTOSAR-A5_1_1" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A4-10-1 Only nullptr literal shall be used as the null-pointer-constant" name="AUTOSAR-A4_10_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-1-6 Return type of a non-void return type lambda expression should be explicitly specified" name="AUTOSAR-A5_1_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-1-4 A lambda expression object shall not outlive any of its reference-captured objects" name="AUTOSAR-A5_1_4" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-1-3 Parameter list (possibly empty) shall be included in every lambda expression" name="AUTOSAR-A5_1_3" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR A15-3-4 Catch-all (ellipsis and std::exception) handlers shall be used only in (a) main, (b) task main functions, (c) in functions that are supposed to isolate independent components and (d) when calling third-party code that uses exceptions not according to AUTOSAR C++14 guidelines" name="AUTOSAR-A15_3_4" rules="1" total="1"/>
               <Category authTot="1;" authUrg="0;" desc="AUTOSAR A15-3-5 A class type exception shall be caught by reference or const reference" name="AUTOSAR-A15_3_5" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-3-2 If a function throws an exception, it shall be handled when meaningful actions can be taken, otherwise it shall be propagated" name="AUTOSAR-A15_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M2-13-2 Octal constants (other than zero) and octal escape sequences (other than &quot;\0&quot; ) shall not be used" name="AUTOSAR-M2_13_2" rules="2" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR A15-3-3 Main function and a task main function shall catch at least: base class exceptions from all third-party libraries used, std::exception and all otherwise unhandled exceptions" name="AUTOSAR-A15_3_3" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-6-1 Functions declared with the [[noreturn]] attribute shall not return" name="AUTOSAR-A7_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M2-13-4 Literal suffixes shall be upper case" name="AUTOSAR-M2_13_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M2-13-3 A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" name="AUTOSAR-M2_13_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-19-1 Evaluation of constant unsigned integer expressions shall not lead to wrap-around" name="AUTOSAR-M5_19_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A14-5-1 A template constructor shall not participate in overload resolution for a single argument of the enclosing class type" name="AUTOSAR-A14_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A10-2-1 Non-virtual member functions shall not be redefined in derived classes" name="AUTOSAR-A10_2_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-2-1 When declaring function templates, the trailing return type syntax shall be used if the return type depends on the type of parameters" name="AUTOSAR-A8_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A14-5-3 A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations." name="AUTOSAR-A14_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-6 &quot;forward&quot; parameters declared as T &amp;&amp; shall always be forwarded" name="AUTOSAR-A8_4_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-0-5 Arguments to a function-like macro shall not contain tokens that look like pre-processing directives" name="AUTOSAR-M16_0_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-5 &quot;consume&quot; parameters declared as X &amp;&amp; shall always be moved from" name="AUTOSAR-A8_4_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-8 Output parameters shall not be used" name="AUTOSAR-A8_4_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-4-1 All usage of assembler shall be documented" name="AUTOSAR-M7_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-7 &quot;in&quot; parameters for &quot;cheap to copy&quot; types shall be passed by value" name="AUTOSAR-A8_4_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-0-2 Macros shall only be #define'd or #undef'd in the global namespace" name="AUTOSAR-M16_0_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-6 Copy and move constructors and copy assignment and move assignment operators shall be declared protected or defined &quot;=delete&quot; in base class" name="AUTOSAR-A12_8_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-3-2 Static and thread-local objects shall be constant-initialized" name="AUTOSAR-A3_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-2 All exit paths from a function with non-void return type shall have an explicit return statement with an expression" name="AUTOSAR-A8_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-0-1 #include directives in a file shall only be preceded by other pre-processor directives or comments" name="AUTOSAR-M16_0_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-4-3 Assembly language shall be encapsulated and isolated" name="AUTOSAR-M7_4_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-7 Assignment operators should be declared with the ref-qualifier &amp;" name="AUTOSAR-A12_8_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A3-3-1 Objects or functions with external linkage (including members of named namespaces) shall be declared in a header file" name="AUTOSAR-A3_3_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-1 Functions shall not be defined using the ellipsis notation" name="AUTOSAR-A8_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M7-4-2 Assembler instructions shall only be introduced using the asm declaration" name="AUTOSAR-M7_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-4 Multiple output values from a function should be returned as a struct or tuple" name="AUTOSAR-A8_4_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-3 Common ways of passing parameters should be used" name="AUTOSAR-A8_4_3" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-4-1 The asm declaration shall not be used" name="AUTOSAR-A7_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-5-1 Trigraphs shall not be used" name="AUTOSAR-A2_5_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A2-5-2 Digraphs shall not be used" name="AUTOSAR-A2_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A8-4-9 &quot;in-out&quot; parameters declared as T &amp; shall be modified" name="AUTOSAR-A8_4_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-0-8 If the # token appears as the first token on a line, then it shall be immediately followed by a pre-processing token" name="AUTOSAR-M16_0_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-0-7 Undefined macro identifiers shall not be used in #if or #elif pre-processor directives, except as operands to the defined operator" name="AUTOSAR-M16_0_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M16-0-6 In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ##" name="AUTOSAR-M16_0_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-0-2 Bitwise operations and operations that assume data representation in memory shall not be performed on objects" name="AUTOSAR-A12_0_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M10-3-3 A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" name="AUTOSAR-M10_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-6-3 The continue statement shall only be used within a well-formed for loop" name="AUTOSAR-M6_6_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M3-3-2 If a function has internal linkage then all re-declarations shall include the static storage class specifier" name="AUTOSAR-M3_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-6-2 The goto statement shall jump to a label declared later in the same function body" name="AUTOSAR-M6_6_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-0-1 If a class declares a copy or move operation, or a destructor, either via &quot;=default&quot;, &quot;=delete&quot;, or via a user-provided declaration, then all others of these five special member functions shall be declared as well" name="AUTOSAR-A12_0_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M6-6-1 Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" name="AUTOSAR-M6_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-2 User-defined copy and move assignment operators should use user-defined no-throw swap function" name="AUTOSAR-A12_8_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-3 Moved-from object shall not be read-accessed" name="AUTOSAR-A12_8_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-4 Move constructor shall not initialize its class members and base classes using copy semantics" name="AUTOSAR-A12_8_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-1-8 Lambda expressions should not be defined inside another lambda expression" name="AUTOSAR-A5_1_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-5 A copy assignment and a move assignment operators shall handle self-assignment" name="AUTOSAR-A12_8_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-1-7 A lambda shall not be an operand to decltype or typeid" name="AUTOSAR-A5_1_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M19-3-1 The error indicator errno shall not be used" name="AUTOSAR-M19_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A12-8-1 Move and copy constructors shall move and respectively copy base classes and data members of a class, without any side effects" name="AUTOSAR-A12_8_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-0-3 The declaration of objects shall contain no more than two levels of pointer indirection" name="AUTOSAR-A5_0_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-9 An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression" name="AUTOSAR-M5_0_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-8-1 The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand" name="AUTOSAR-M5_8_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-1-1 A project shall not contain instances of non-volatile variables being given values that are not subsequently used" name="AUTOSAR-A0_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-0-2 The condition of an if-statement and the condition of an iteration statement shall have type bool" name="AUTOSAR-A5_0_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-8 An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression" name="AUTOSAR-M5_0_8" rules="2" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="AUTOSAR A0-1-2 The value returned by a function having a non-void return type that is not an overloaded operator shall be used" name="AUTOSAR-A0_1_2" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-0-1 The value of an expression shall be the same under any order of evaluation that the standard permits" name="AUTOSAR-A5_0_1" rules="7" total="0"/>
               <Category authTot="5;" authUrg="0;" desc="AUTOSAR M0-1-4 A project shall not contain non-volatile POD variables having only one use" name="AUTOSAR-M0_1_4" rules="1" total="5"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-1-3 Every function defined in an anonymous namespace, or static function with internal linkage, or private member function shall be used" name="AUTOSAR-A0_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-1-2 A project shall not contain infeasible paths" name="AUTOSAR-M0_1_2" rules="29" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-5 There shall be no implicit floating-integral conversions" name="AUTOSAR-M5_0_5" rules="2" total="0"/>
               <Category authTot="3;" authUrg="0;" desc="AUTOSAR A27-0-4 C-style strings shall not be used" name="AUTOSAR-A27_0_4" rules="5" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-1-3 A project shall not contain unused variables" name="AUTOSAR-M0_1_3" rules="4" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="AUTOSAR M5-0-4 An implicit integral conversion shall not change the signedness of the underlying type" name="AUTOSAR-M5_0_4" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-2 Non-placement new or delete expressions shall not be used" name="AUTOSAR-A18_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A27-0-3 Alternate input and output operations on a file stream shall not be used without an intervening flush or positioning call" name="AUTOSAR-A27_0_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-7 There shall be no explicit floating-integral conversions of a cvalue expression" name="AUTOSAR-M5_0_7" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-1 Functions malloc, calloc, realloc and free shall not be used" name="AUTOSAR-A18_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A27-0-2 A C-style string shall guarantee sufficient space for data and the null terminator" name="AUTOSAR-A27_0_2" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A5-0-4 Pointer arithmetic shall not be used with pointers to non-final classes" name="AUTOSAR-A5_0_4" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-1-1 A project shall not contain unreachable code" name="AUTOSAR-M0_1_1" rules="7" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-6 An implicit integral or floating-point conversion shall not reduce the size of the underlying type" name="AUTOSAR-M5_0_6" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A13-6-1 Digit sequences separators ' shall only be used as follows: (1) for decimal, every 3 digits, (2) for hexadecimal, every 2 digits, (3) for binary, every 4 digits" name="AUTOSAR-A13_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A27-0-1 Inputs from independent components shall be validated" name="AUTOSAR-A27_0_1" rules="8" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-1-4 There shall be no unused named parameters in non-virtual functions" name="AUTOSAR-A0_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-1-5 There shall be no unused named parameters in the set of parameters for a virtual function and all the functions that override it" name="AUTOSAR-A0_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A0-1-6 There should be no unused type declarations" name="AUTOSAR-A0_1_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A10-3-5 A user-defined assignment operator shall not be virtual" name="AUTOSAR-A10_3_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A15-2-1 Constructors that are not noexcept shall not be invoked before program startup" name="AUTOSAR-A15_2_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-5-2 Functions shall not call themselves, either directly or indirectly" name="AUTOSAR-A7_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-18-1 The comma operator shall not be used" name="AUTOSAR-M5_18_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A7-5-1 A function shall not return a reference or a pointer to a parameter that is passed by reference to const" name="AUTOSAR-A7_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-4 If a project has sized or unsized version of operator &quot;delete&quot; globally defined, then both sized and unsized versions shall be defined" name="AUTOSAR-A18_5_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-3 The form of the delete expression shall match the form of the new expression used to allocate the memory" name="AUTOSAR-A18_5_3" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-3 A cvalue expression shall not be implicitly converted to a different underlying type" name="AUTOSAR-M5_0_3" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-5 Memory management functions shall ensure the following: (a) deterministic behavior resulting with the existence of worst-case execution time, (b) avoiding memory fragmentation, (c) avoid running out of memory, (d) avoiding mismatched allocations or deallocations, (e) no dependence on non-deterministic calls to kernel" name="AUTOSAR-A18_5_5" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M5-0-2 Limited dependence should be placed on C++ operator precedence rules in expressions" name="AUTOSAR-M5_0_2" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A10-3-1 Virtual function declaration shall contain exactly one of the three specifiers:" name="AUTOSAR-A10_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-8 Objects that do not outlive a function shall have automatic storage duration" name="AUTOSAR-A18_5_8" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="AUTOSAR A10-3-2 Each overriding virtual function shall be declared with the override or final specifier" name="AUTOSAR-A10_3_2" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A10-3-3 Virtual functions shall not be introduced in a final class" name="AUTOSAR-A10_3_3" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="AUTOSAR M0-1-8 All functions with void return type shall have external side effect(s)" name="AUTOSAR-M0_1_8" rules="2" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR A18-5-9 Custom implementations of dynamic memory allocation and deallocation functions shall meet the semantic requirements specified in the corresponding &quot;Required behaviour&quot; clause from the C++ Standard" name="AUTOSAR-A18_5_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="AUTOSAR M0-1-9 There shall be no dead code" name="AUTOSAR-M0_1_9" rules="1" total="0"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="Flow Analysis" name="BD" rules="138" total="0">
               <Category authTot="0;" authUrg="0;" desc="Incorrect API usage" name="BD-API" rules="7" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Miscellaneous" name="BD-MISC" rules="2" total="0"/>
               <Category authTot="8;" authUrg="0;" desc="Possible Bugs" name="BD-PB" rules="76" total="8"/>
               <Category authTot="0;" authUrg="0;" desc="Resources" name="BD-RES" rules="8" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Security" name="BD-SECURITY" rules="19" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Containers" name="BD-CO" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Threads &amp; Synchronization" name="BD-TRS" rules="21" total="0"/>
            </Category>
            <Category authTot="9;" authUrg="9;" desc="Code Duplication Detection" name="CDD" rules="4" total="9"/>
            <Category authTot="0;" authUrg="0;" desc="SEI CERT C" name="CERT_C" rules="367" total="0">
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC12_C (REC) Detect and remove code that has no effect or is never executed" name="CERT_C-MSC12" rules="11" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC11_C (REC) Incorporate diagnostic tests using assertions" name="CERT_C-MSC11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC14_C (REC) Do not introduce unnecessary platform dependencies" name="CERT_C-MSC14" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC13_C (REC) Detect and remove unused values" name="CERT_C-MSC13" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC15_C (REC) Do not depend on undefined behavior" name="CERT_C-MSC15" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-WIN00_C (REC) Be specific when dynamically loading libraries" name="CERT_C-WIN00" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP03_C (REC) Detect and handle floating-point errors" name="CERT_C-FLP03" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC17_C (REC) Finish every set of statements associated with a case label with a break statement" name="CERT_C-MSC17" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP02_C (REC) Avoid using floating-point numbers when precise computation is needed" name="CERT_C-FLP02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC19_C (REC) For functions that return an array, prefer returning an empty array over a null value" name="CERT_C-MSC19" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP06_C (REC) Convert integers to floating point for floating-point operations" name="CERT_C-FLP06" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT02_C (REC) Understand integer conversion rules" name="CERT_C-INT02" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP00_C (REC) Understand the limitations of floating-point numbers" name="CERT_C-FLP00" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-API01_C (REC) Avoid laying out strings in memory directly before sensitive data" name="CERT_C-API01" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-API02_C (REC) Functions that read or write to or from an array should take an argument to specify the source or target size" name="CERT_C-API02" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT08_C (REC) Verify that all integer values are in range" name="CERT_C-INT08" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT09_C (REC) Ensure enumeration constants map to unique values" name="CERT_C-INT09" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT07_C (REC) Use only explicitly signed or unsigned char type for numeric values" name="CERT_C-INT07" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT04_C (REC) Enforce limits on integer values originating from tainted sources" name="CERT_C-INT04" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT05_C (REC) Do not use input functions to convert character data if they cannot handle all possible inputs" name="CERT_C-INT05" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV30_C (RULE) Do not modify the object referenced by the return value of certain functions" name="CERT_C-ENV30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC22_C (REC) Use the setjmp(), longjmp() facility securely" name="CERT_C-MSC22" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-MSC24_C (REC) Do not use deprecated or obsolescent functions" name="CERT_C-MSC24" rules="4" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT13_C (REC) Use bitwise operators only on unsigned operands" name="CERT_C-INT13" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT12_C (REC) Do not make assumptions about the type of a plain int bit-field when used in an expression" name="CERT_C-INT12" rules="1" total="0"/>
               <Category authTot="2;" authUrg="2;" desc="CERT-INT10_C (REC) Do not assume a positive remainder when using the % operator" name="CERT_C-INT10" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV33_C (RULE) Do not call system()" name="CERT_C-ENV33" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV34_C (RULE) Do not store pointers returned by certain functions" name="CERT_C-ENV34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT18_C (REC) Evaluate integer expressions in a larger size before comparing or assigning to that size" name="CERT_C-INT18" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV31_C (RULE) Do not rely on an environment pointer following an operation that may invalidate it" name="CERT_C-ENV31" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT15_C (REC) Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" name="CERT_C-INT15" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC30_C (RULE) Do not use the rand() function for generating pseudorandom numbers" name="CERT_C-MSC30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV32_C (RULE) All exit handlers must return normally" name="CERT_C-ENV32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT16_C (REC) Do not make assumptions about representation of signed integers" name="CERT_C-INT16" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM00_C (REC) Allocate and free memory in the same module, at the same level of abstraction" name="CERT_C-MEM00" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM01_C (REC) Store a new value in pointers immediately after free()" name="CERT_C-MEM01" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG30_C (RULE) Call only asynchronous-safe functions within signal handlers" name="CERT_C-SIG30" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-MEM04_C (REC) Beware of zero-length allocations" name="CERT_C-MEM04" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM05_C (REC) Avoid large stack allocations" name="CERT_C-MEM05" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG31_C (RULE) Do not access shared objects in signal handlers" name="CERT_C-SIG31" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM02_C (REC) Immediately cast the result of a memory allocation function call into a pointer to the allocated type" name="CERT_C-MEM02" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG34_C (RULE) Do not call signal() from within interruptible signal handlers" name="CERT_C-SIG34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM03_C (REC) Clear sensitive information stored in reusable resources" name="CERT_C-MEM03" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG35_C (RULE) Do not return from a computational exception signal handler" name="CERT_C-SIG35" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE31_C (RULE) Avoid side effects in arguments to unsafe macros" name="CERT_C-PRE31" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE32_C (RULE) Do not use preprocessor directives in invocations of function-like macros" name="CERT_C-PRE32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE30_C (RULE) Do not create a universal character name through concatenation" name="CERT_C-PRE30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV02_C (REC) Beware of multiple environment variables with the same effective name" name="CERT_C-ENV02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ENV01_C (REC) Do not make assumptions about the size of an environment variable" name="CERT_C-ENV01" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC01_C (REC) Strive for logical completeness" name="CERT_C-MSC01" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC04_C (REC) Use comments consistently and in a readable fashion" name="CERT_C-MSC04" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC07_C (REC) Detect and remove dead code" name="CERT_C-MSC07" rules="9" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="CERT-MSC09_C (REC) Character encoding: Use subset of ASCII for safety" name="CERT_C-MSC09" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT35_C (RULE) Use correct integer precisions" name="CERT_C-INT35" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT36_C (RULE) Converting a pointer to integer or integer to pointer" name="CERT_C-INT36" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT33_C (RULE) Ensure that division and remainder operations do not result in divide-by-zero errors" name="CERT_C-INT33" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT34_C (RULE) Do not shift an expression by a negative number of bits or by greater than or equal to the number of bits that exist in the operand" name="CERT_C-INT34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT31_C (RULE) Ensure that integer conversions do not result in lost or misinterpreted data" name="CERT_C-INT31" rules="16" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT32_C (RULE) Ensure that operations on signed integers do not result in overflow" name="CERT_C-INT32" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT30_C (RULE) Ensure that unsigned integer operations do not wrap" name="CERT_C-INT30" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO34_C (RULE) Distinguish between characters read from a file and EOF or WEOF" name="CERT_C-FIO34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO32_C (RULE) Do not perform operations on devices that are only appropriate for files" name="CERT_C-FIO32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO38_C (RULE) Do not copy a FILE object" name="CERT_C-FIO38" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO39_C (RULE) Do not alternately input and output from a stream without an intervening flush or positioning call" name="CERT_C-FIO39" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO37_C (RULE) Do not assume that fgets() or fgetws() returns a nonempty string when successful" name="CERT_C-FIO37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP44_C (RULE) Do not rely on side effects in operands to sizeof, _Alignof, or _Generic" name="CERT_C-EXP44" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP45_C (RULE) Do not perform assignments in selection statements" name="CERT_C-EXP45" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP42_C (RULE) Do not compare padding data" name="CERT_C-EXP42" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP43_C (RULE) Avoid undefined behavior when using restrict-qualified pointers" name="CERT_C-EXP43" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO30_C (RULE) Exclude user input from format strings" name="CERT_C-FIO30" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP46_C (RULE) Do not use a bitwise operator with a Boolean-like operand" name="CERT_C-EXP46" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP47_C (RULE) Do not call va_arg with an argument of the incorrect type" name="CERT_C-EXP47" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM12_C (REC) Consider using a goto chain when leaving a function on error when using and releasing resources" name="CERT_C-MEM12" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR34_C (RULE) Cast characters to unsigned char before converting to larger integer sizes" name="CERT_C-STR34" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR31_C (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator" name="CERT_C-STR31" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR32_C (RULE) Do not pass a non-null-terminated character sequence to a library function that expects a string" name="CERT_C-STR32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR30_C (RULE) Do not attempt to modify string literals" name="CERT_C-STR30" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO45_C (RULE) Avoid TOCTOU race conditions while accessing files" name="CERT_C-FIO45" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO46_C (RULE) Do not access a closed file" name="CERT_C-FIO46" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO44_C (RULE) Only use values for fsetpos() that are returned from fgetpos()" name="CERT_C-FIO44" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR37_C (RULE) Arguments to character-handling functions must be representable as an unsigned char" name="CERT_C-STR37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR38_C (RULE) Do not confuse narrow and wide character strings and functions" name="CERT_C-STR38" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO47_C (RULE) Use valid format strings" name="CERT_C-FIO47" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO41_C (RULE) Do not call getc(), putc(), getwc(), or putwc() with a stream argument that has side effects" name="CERT_C-FIO41" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO42_C (RULE) Close files when they are no longer needed" name="CERT_C-FIO42" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO40_C (RULE) Reset strings on fgets() or fgetws() failure" name="CERT_C-FIO40" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-MEM07_C (REC) Ensure that the arguments to calloc(), when multiplied, do not wrap" name="CERT_C-MEM07" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC32_C (RULE) Properly seed pseudorandom number generators" name="CERT_C-MSC32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC33_C (RULE) Do not pass invalid data to the asctime() function" name="CERT_C-MSC33" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC38_C (RULE) Do not treat a predefined identifier as an object if it might only be implemented as a macro" name="CERT_C-MSC38" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC37_C (RULE) Ensure that control never reaches the end of a non-void function" name="CERT_C-MSC37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC39_C (RULE) Do not call va_arg() on a va_list that has an indeterminate value" name="CERT_C-MSC39" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP30_C (RULE) Do not depend on the order of evaluation for side effects" name="CERT_C-EXP30" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON40_C (RULE) Do not refer to an atomic variable twice in an expression" name="CERT_C-CON40" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP20_C (REC) Perform explicit tests to determine success, true and false, and equality" name="CERT_C-EXP20" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON43_C (RULE) Do not allow data races in multithreaded code" name="CERT_C-CON43" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON41_C (RULE) Wrap functions that can fail spuriously in a loop" name="CERT_C-CON41" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-MSC41_C (RULE) Never hard code sensitive information" name="CERT_C-MSC41" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC40_C (RULE) Do not violate constraints" name="CERT_C-MSC40" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM33_C (RULE) Allocate and copy structures containing a flexible array member dynamically" name="CERT_C-MEM33" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM34_C (RULE) Only free memory allocated dynamically" name="CERT_C-MEM34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM31_C (RULE) Free dynamically allocated memory when no longer needed" name="CERT_C-MEM31" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM35_C (RULE) Allocate sufficient memory for an object" name="CERT_C-MEM35" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG01_C (REC) Understand implementation-specific details regarding signal handler persistence" name="CERT_C-SIG01" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM36_C (RULE) Do not modify the alignment of objects by calling realloc()" name="CERT_C-MEM36" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG00_C (REC) Mask signals handled by noninterruptible signal handlers" name="CERT_C-SIG00" rules="1" total="0"/>
               <Category authTot="8;" authUrg="0;" desc="CERT-API00_C (REC) Functions should validate their parameters" name="CERT_C-API00" rules="1" total="8"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO24_C (REC) Do not open a file that is already open" name="CERT_C-FIO24" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-SIG02_C (REC) Avoid using signals to implement normal functionality" name="CERT_C-SIG02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO21_C (REC) Do not create temporary files in shared directories" name="CERT_C-FIO21" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO22_C (REC) Close files before spawning processes" name="CERT_C-FIO22" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP40_C (RULE) Do not modify constant objects" name="CERT_C-EXP40" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM30_C (RULE) Do not access freed memory" name="CERT_C-MEM30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP33_C (RULE) Do not read uninitialized memory" name="CERT_C-EXP33" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP34_C (RULE) Do not dereference null pointers" name="CERT_C-EXP34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP32_C (RULE) Do not access a volatile object through a nonvolatile reference" name="CERT_C-EXP32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON32_C (RULE) Prevent data races when accessing bit-fields from multiple threads" name="CERT_C-CON32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP37_C (RULE) Call functions with the correct number and type of arguments" name="CERT_C-EXP37" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON33_C (RULE) Avoid race conditions when using library functions" name="CERT_C-CON33" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON30_C (RULE) Clean up thread-specific storage" name="CERT_C-CON30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP35_C (RULE) Do not modify objects with temporary lifetime" name="CERT_C-EXP35" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON31_C (RULE) Do not destroy a mutex while it is locked" name="CERT_C-CON31" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP36_C (RULE) Do not cast pointers into more strictly aligned pointer types" name="CERT_C-EXP36" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON36_C (RULE) Wrap functions that can spuriously wake up in a loop" name="CERT_C-CON36" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON37_C (RULE) Do not call signal() in a multithreaded program" name="CERT_C-CON37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON34_C (RULE) Declare objects shared between threads with appropriate storage durations" name="CERT_C-CON34" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP39_C (RULE) Do not access a variable through a pointer of an incompatible type" name="CERT_C-EXP39" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON35_C (RULE) Avoid deadlock by locking in a predefined order" name="CERT_C-CON35" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON38_C (RULE) Preserve thread safety and liveness when using condition variables" name="CERT_C-CON38" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON39_C (RULE) Do not join or detach a thread that was previously joined or detached" name="CERT_C-CON39" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL22_C (REC) Use volatile for data that cannot be cached" name="CERT_C-DCL22" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL20_C (REC) Explicitly specify void when a function accepts no arguments" name="CERT_C-DCL20" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP00_C (REC) Use parentheses for precedence of operation" name="CERT_C-EXP00" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP05_C (REC) Do not cast away a const qualification" name="CERT_C-EXP05" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP02_C (REC) Be aware of the short-circuit behavior of the logical AND and OR operators" name="CERT_C-EXP02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP08_C (REC) Ensure pointer arithmetic is used correctly" name="CERT_C-EXP08" rules="2" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="CERT-DCL19_C (REC) Minimize the scope of variables and functions" name="CERT_C-DCL19" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL18_C (REC) Do not begin integer constants with 0 when specifying a decimal value" name="CERT_C-DCL18" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL12_C (REC) Implement abstract data types using opaque types" name="CERT_C-DCL12" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO01_C (REC) Be careful using functions that use file names for identification" name="CERT_C-FIO01" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL11_C (REC) Understand the type issues associated with variadic functions" name="CERT_C-DCL11" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL10_C (REC) Maintain the contract between the writer and caller of variadic functions" name="CERT_C-DCL10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL16_C (REC) Use &quot;L,&quot; not &quot;l,&quot; to indicate a long value" name="CERT_C-DCL16" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL15_C (REC) Declare file-scope objects or functions that do not need external linkage as static" name="CERT_C-DCL15" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL13_C (REC) Declare function parameters that are pointers to values not changed by the function as const" name="CERT_C-DCL13" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-EXP12_C (REC) Do not ignore values returned by functions" name="CERT_C-EXP12" rules="2" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP10_C (REC) Do not depend on the order of evaluation of subexpressions or the order in which side effects take place" name="CERT_C-EXP10" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP15_C (REC) Do not place a semicolon on the same line as an if, for, or while statement" name="CERT_C-EXP15" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP16_C (REC) Do not compare function pointers to constant values" name="CERT_C-EXP16" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP14_C (REC) Beware of integer promotion when performing bitwise operations on integer types smaller than int" name="CERT_C-EXP14" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP19_C (REC) Use braces for the body of an if, for, or while statement" name="CERT_C-EXP19" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR00_C (REC) Represent characters using an appropriate type" name="CERT_C-STR00" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR09_C (REC) Don't assume numeric values for expressions with type plain character" name="CERT_C-STR09" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR07_C (REC) Use the bounds-checking interfaces for string manipulation" name="CERT_C-STR07" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR04_C (REC) Use plain char for characters in the basic character set" name="CERT_C-STR04" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR05_C (REC) Use pointers to const when referring to string literals" name="CERT_C-STR05" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR02_C (REC) Sanitize data passed to complex subsystems" name="CERT_C-STR02" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR03_C (REC) Do not inadvertently truncate a string" name="CERT_C-STR03" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL41_C (RULE) Do not declare variables inside a switch statement before the first case label" name="CERT_C-DCL41" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL40_C (RULE) Do not create incompatible declarations of the same function or object" name="CERT_C-DCL40" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON01_C (REC) Acquire and release synchronization primitives in the same module, at the same level of abstraction" name="CERT_C-CON01" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON02_C (REC) Do not use volatile as a synchronization primitive" name="CERT_C-CON02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON05_C (REC) Do not perform operations that can block while holding a lock" name="CERT_C-CON05" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR11_C (REC) Do not specify the bound of a character array initialized with a string literal" name="CERT_C-STR11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL39_C (RULE) Avoid information leakage when passing a structure across a trust boundary" name="CERT_C-DCL39" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR10_C (REC) Do not concatenate different type of string literals" name="CERT_C-STR10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL31_C (RULE) Declare identifiers before using them" name="CERT_C-DCL31" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL38_C (RULE) Use the correct syntax when declaring a flexible array member" name="CERT_C-DCL38" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL37_C (RULE) Do not declare or define a reserved identifier" name="CERT_C-DCL37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL36_C (RULE) Do not declare an identifier with conflicting linkage classifications" name="CERT_C-DCL36" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL30_C (RULE) Declare objects with appropriate storage durations" name="CERT_C-DCL30" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR01_C (REC) Do not apply the sizeof operator to a pointer when taking the size of an array" name="CERT_C-ARR01" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR02_C (REC) Explicitly specify array bounds, even if implicitly defined by an initializer" name="CERT_C-ARR02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE02_C (REC) Macro replacement lists should be parenthesized" name="CERT_C-PRE02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE00_C (REC) Prefer inline or static functions to function-like macros" name="CERT_C-PRE00" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE01_C (REC) Use parentheses within macros around parameter names" name="CERT_C-PRE01" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE06_C (REC) Enclose header files in an include guard" name="CERT_C-PRE06" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-PRE07_C (REC) Avoid using repeated question marks" name="CERT_C-PRE07" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS54_C (RULE) Detect and handle POSIX library errors" name="CERT_C-POS54" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR30_C (RULE) Set errno to zero before calling a library function known to set errno, and check errno only after the function returns a value indicating failure" name="CERT_C-ERR30" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR32_C (RULE) Do not rely on indeterminate values of errno" name="CERT_C-ERR32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR33_C (RULE) Detect and handle standard library errors" name="CERT_C-ERR33" rules="2" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-ERR34_C (RULE) Detect errors when converting a string to a number" name="CERT_C-ERR34" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS51_C (RULE) Avoid deadlock with POSIX threads by locking in predefined order" name="CERT_C-POS51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS50_C (RULE) Declare objects shared between POSIX threads with appropriate storage durations" name="CERT_C-POS50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS53_C (RULE) Do not use more than one mutex for concurrent waiting operations on a condition variable" name="CERT_C-POS53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS52_C (RULE) Do not perform operations that can block while holding a POSIX lock" name="CERT_C-POS52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR06_C (REC) Understand the termination behavior of assert() and abort()" name="CERT_C-ERR06" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-ERR07_C (REC) Prefer functions that support error checking over equivalent functions that don't" name="CERT_C-ERR07" rules="2" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL06_C (REC) Use meaningful symbolic constants to represent literal values" name="CERT_C-DCL06" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL01_C (REC) Do not reuse variable names in subscopes" name="CERT_C-DCL01" rules="2" total="0"/>
               <Category authTot="3;" authUrg="1;" desc="CERT-DCL00_C (REC) Const-qualify immutable objects" name="CERT_C-DCL00" rules="2" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL05_C (REC) Use typedefs of non-pointer types only" name="CERT_C-DCL05" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL04_C (REC) Do not declare more than one variable per declaration" name="CERT_C-DCL04" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL02_C (REC) Use visually distinct identifiers" name="CERT_C-DCL02" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS44_C (RULE) Do not use signals to terminate threads" name="CERT_C-POS44" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS48_C (RULE) Do not unlock or destroy another POSIX thread's mutex" name="CERT_C-POS48" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS47_C (RULE) Do not use threads that can be canceled asynchronously" name="CERT_C-POS47" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS49_C (RULE) When data must be accessed by multiple threads, provide a mutex and guarantee no adjacent data is also accessed" name="CERT_C-POS49" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-WIN30_C (RULE) Properly pair allocation and deallocation functions" name="CERT_C-WIN30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR01_C (REC) Use ferror() rather than errno to check for FILE stream errors" name="CERT_C-ERR01" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="CERT-ERR02_C (REC) Avoid in-band error indicators" name="CERT_C-ERR02" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR04_C (REC) Choose an appropriate termination strategy" name="CERT_C-ERR04" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR05_C (REC) Application-independent code should provide error detection without dictating error handling" name="CERT_C-ERR05" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP37_C (RULE) Do not use object representations to compare floating-point values" name="CERT_C-FLP37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP36_C (RULE) Preserve precision when converting integral values to floating-point type" name="CERT_C-FLP36" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP34_C (RULE) Ensure that floating-point conversions are within range of the new type" name="CERT_C-FLP34" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS33_C (RULE) Do not use vfork()" name="CERT_C-POS33" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR32_C (RULE) Ensure size arguments for variable length arrays are in a valid range" name="CERT_C-ARR32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS35_C (RULE) Avoid race conditions while checking for the existence of a symbolic link" name="CERT_C-POS35" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS34_C (RULE) Do not call putenv() with a pointer to an automatic variable as the argument" name="CERT_C-POS34" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR30_C (RULE) Do not form or use out-of-bounds pointers or array subscripts" name="CERT_C-ARR30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS37_C (RULE) Ensure that privilege relinquishment is successful" name="CERT_C-POS37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP32_C (RULE) Prevent or detect domain and range errors in math functions" name="CERT_C-FLP32" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS36_C (RULE) Observe correct revocation order while relinquishing privileges" name="CERT_C-POS36" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS39_C (RULE) Use the correct byte ordering when transferring data between systems" name="CERT_C-POS39" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FLP30_C (RULE) Do not use floating-point variables as loop counters" name="CERT_C-FLP30" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS38_C (RULE) Beware of race conditions when using fork and file descriptors" name="CERT_C-POS38" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR39_C (RULE) Do not add or subtract a scaled integer to a pointer" name="CERT_C-ARR39" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR38_C (RULE) Guarantee that library functions do not form invalid pointers" name="CERT_C-ARR38" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR37_C (RULE) Do not add or subtract an integer to a pointer to a non-array object" name="CERT_C-ARR37" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ARR36_C (RULE) Do not subtract or compare two pointers that do not refer to the same array" name="CERT_C-ARR36" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-POS30_C (RULE) Use the readlink() function properly" name="CERT_C-POS30" rules="3" total="0"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="SEI CERT C++" name="CERT_CPP" rules="143" total="0">
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL55_CPP (RULE) Avoid information leakage when passing a class object across a trust boundary" name="CERT_CPP-DCL55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR52_CPP (RULE) Do not use setjmp() or longjmp()" name="CERT_CPP-ERR52" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL56_CPP (RULE) Avoid cycles during initialization of static objects" name="CERT_CPP-DCL56" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR51_CPP (RULE) Handle all exceptions" name="CERT_CPP-ERR51" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON56_CPP (RULE) Do not speculatively lock a non-recursive mutex that is already owned by the calling thread" name="CERT_CPP-CON56" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL53_CPP (RULE) Do not write syntactically ambiguous declarations" name="CERT_CPP-DCL53" rules="3" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="CERT-ERR50_CPP (RULE) Do not abruptly terminate the program" name="CERT_CPP-ERR50" rules="14" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL54_CPP (RULE) Overload allocation and deallocation functions as a pair in the same scope" name="CERT_CPP-DCL54" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL59_CPP (RULE) Do not define an unnamed namespace in a header file" name="CERT_CPP-DCL59" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM51_CPP (RULE) Properly deallocate dynamically allocated resources" name="CERT_CPP-MEM51" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM52_CPP (RULE) Detect and handle memory allocation errors" name="CERT_CPP-MEM52" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL57_CPP (RULE) Do not let exceptions escape from destructors or deallocation functions" name="CERT_CPP-DCL57" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL58_CPP (RULE) Do not modify the standard namespaces" name="CERT_CPP-DCL58" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM50_CPP (RULE) Do not access freed memory" name="CERT_CPP-MEM50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON50_CPP (RULE) Do not destroy a mutex while it is locked" name="CERT_CPP-CON50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM55_CPP (RULE) Honor replacement dynamic storage management requirements" name="CERT_CPP-MEM55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON51_CPP (RULE) Ensure actively held locks are released on exceptional conditions" name="CERT_CPP-CON51" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-ERR59_CPP (RULE) Do not throw an exception across execution boundaries" name="CERT_CPP-ERR59" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM56_CPP (RULE) Do not store an already-owned pointer value in an unrelated smart pointer" name="CERT_CPP-MEM56" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR58_CPP (RULE) Handle all exceptions thrown before main() begins executing" name="CERT_CPP-ERR58" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM53_CPP (RULE) Explicitly construct and destruct objects when manually managing object lifetime" name="CERT_CPP-MEM53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR57_CPP (RULE) Do not leak resources when handling exceptions" name="CERT_CPP-ERR57" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM54_CPP (RULE) Provide placement new with properly aligned pointers to sufficient storage capacity" name="CERT_CPP-MEM54" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON54_CPP (RULE) Wrap functions that can spuriously wake up in a loop" name="CERT_CPP-CON54" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR56_CPP (RULE) Guarantee exception safety" name="CERT_CPP-ERR56" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON55_CPP (RULE) Preserve thread safety and liveness when using condition variables" name="CERT_CPP-CON55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR55_CPP (RULE) Honor exception specifications" name="CERT_CPP-ERR55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON52_CPP (RULE) Prevent data races when accessing bit-fields from multiple threads" name="CERT_CPP-CON52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR54_CPP (RULE) Catch handlers should order their parameter types from most derived to least derived" name="CERT_CPP-ERR54" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MEM57_CPP (RULE) Avoid using default operator new for over-aligned types" name="CERT_CPP-MEM57" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CON53_CPP (RULE) Avoid deadlock by locking in a predefined order" name="CERT_CPP-CON53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR53_CPP (RULE) Do not reference base classes or class data members in a constructor or destructor function-try-block handler" name="CERT_CPP-ERR53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR53_CPP (RULE) Range check element access" name="CERT_CPP-STR53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL51_CPP (RULE) Do not declare or define a reserved identifier" name="CERT_CPP-DCL51" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR50_CPP (RULE) Guarantee that storage for strings has sufficient space for character data and the null terminator" name="CERT_CPP-STR50" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL52_CPP (RULE) Never qualify a reference type with const or volatile" name="CERT_CPP-DCL52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR52_CPP (RULE) Use valid references, pointers, and iterators to reference elements of a basic_string" name="CERT_CPP-STR52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL50_CPP (RULE) Do not define a C-style variadic function" name="CERT_CPP-DCL50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-STR51_CPP (RULE) Do not attempt to create a std::string from a null pointer" name="CERT_CPP-STR51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP53_CPP (RULE) Write constructor member initializers in the canonical order" name="CERT_CPP-OOP53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP52_CPP (RULE) Do not delete a polymorphic object without a virtual destructor" name="CERT_CPP-OOP52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP51_CPP (RULE) Do not slice derived objects" name="CERT_CPP-OOP51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP50_CPP (RULE) Do not invoke virtual functions from constructors or destructors" name="CERT_CPP-OOP50" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP57_CPP (RULE) Prefer special member functions and overloaded operators to C Standard Library functions" name="CERT_CPP-OOP57" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC50_CPP (RULE) Do not use std::rand() for generating pseudorandom numbers" name="CERT_CPP-MSC50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP56_CPP (RULE) Honor replacement handler requirements" name="CERT_CPP-OOP56" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC51_CPP (RULE) Ensure your random number generator is properly seeded" name="CERT_CPP-MSC51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP55_CPP (RULE) Do not use pointer-to-member operators to access nonexistent members" name="CERT_CPP-OOP55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC52_CPP (RULE) Value-returning functions must return a value from all exit paths" name="CERT_CPP-MSC52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP54_CPP (RULE) Gracefully handle self-copy assignment" name="CERT_CPP-OOP54" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-OOP58_CPP (RULE) Copy operations must not mutate the source object" name="CERT_CPP-OOP58" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO51_CPP (RULE) Close files when they are no longer needed" name="CERT_CPP-FIO51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-FIO50_CPP (RULE) Do not alternately input and output from a file stream without an intervening positioning call" name="CERT_CPP-FIO50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-DCL60_CPP (RULE) Obey the one-definition rule" name="CERT_CPP-DCL60" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP55_CPP (RULE) Do not access a cv-qualified object through a cv-unqualified type" name="CERT_CPP-EXP55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP56_CPP (RULE) Do not call a function with a mismatched language linkage" name="CERT_CPP-EXP56" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP53_CPP (RULE) Do not read uninitialized memory" name="CERT_CPP-EXP53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP54_CPP (RULE) Do not access an object outside of its lifetime" name="CERT_CPP-EXP54" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP59_CPP (RULE) Use offsetof() on valid types and members" name="CERT_CPP-EXP59" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP57_CPP (RULE) Do not cast or delete pointers to incomplete classes" name="CERT_CPP-EXP57" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP58_CPP (RULE) Pass an object of the correct type to va_start" name="CERT_CPP-EXP58" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP62_CPP (RULE) Do not access the bits of an object representation that are not part of the object's value representation" name="CERT_CPP-EXP62" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP63_CPP (RULE) Do not rely on the value of a moved-from object" name="CERT_CPP-EXP63" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP60_CPP (RULE) Do not pass a nonstandard-layout type object across execution boundaries" name="CERT_CPP-EXP60" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP61_CPP (RULE) A lambda object must not outlive any of its reference captured objects" name="CERT_CPP-EXP61" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC53_CPP (RULE) Do not return from a function declared [[noreturn]]" name="CERT_CPP-MSC53" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-MSC54_CPP (RULE) A signal handler must be a plain old function" name="CERT_CPP-MSC54" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-ERR62_CPP (RULE) Detect errors when converting a string to a number" name="CERT_CPP-ERR62" rules="1" total="2"/>
               <Category authTot="2;" authUrg="0;" desc="CERT-ERR61_CPP (RULE) Catch exceptions by lvalue reference" name="CERT_CPP-ERR61" rules="2" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-ERR60_CPP (RULE) Exception objects must be nothrow copy constructible" name="CERT_CPP-ERR60" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR57_CPP (RULE) Provide a valid ordering predicate" name="CERT_CPP-CTR57" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR58_CPP (RULE) Predicate function objects should not be mutable" name="CERT_CPP-CTR58" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR53_CPP (RULE) Use valid iterator ranges" name="CERT_CPP-CTR53" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR54_CPP (RULE) Do not subtract iterators that do not refer to the same container" name="CERT_CPP-CTR54" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR55_CPP (RULE) Do not use an additive operator on an iterator if the result would overflow" name="CERT_CPP-CTR55" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR56_CPP (RULE) Do not use pointer arithmetic on polymorphic objects" name="CERT_CPP-CTR56" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR50_CPP (RULE) Guarantee that container indices and iterators are within the valid range" name="CERT_CPP-CTR50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR51_CPP (RULE) Use valid references, pointers, and iterators to reference elements of a container" name="CERT_CPP-CTR51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-CTR52_CPP (RULE) Guarantee that library functions do not overflow" name="CERT_CPP-CTR52" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-INT50_CPP (RULE) Do not cast to an out-of-range enumeration value" name="CERT_CPP-INT50" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP51_CPP (RULE) Do not delete an array through a pointer of the incorrect type" name="CERT_CPP-EXP51" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP52_CPP (RULE) Do not rely on side effects in unevaluated operands" name="CERT_CPP-EXP52" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CERT-EXP50_CPP (RULE) Do not depend on the order of evaluation for side effects" name="CERT_CPP-EXP50" rules="6" total="0"/>
            </Category>
            <Category authTot="37;" authUrg="1;" desc="Coding Conventions" name="CODSTA" rules="550" total="37">
               <Category authTot="23;" authUrg="1;" desc="Coding Conventions for C++" name="CODSTA-CPP" rules="133" total="23"/>
               <Category authTot="22;" authUrg="3;" desc="Coding Conventions for Modern C++" name="CODSTA-MCPP" rules="81" total="22"/>
            </Category>
            <Category authTot="54;" authUrg="2;" desc="Comments" name="COMMENT" rules="17" total="54"/>
            <Category authTot="0;" authUrg="0;" desc="Common Weakness Enumeration" name="CWE" rules="92" total="0">
               <Category authTot="0;" authUrg="0;" desc="CWE-532 Inclusion of Sensitive Information in Log Files" name="CWE-532" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-772 Missing Release of Resource after Effective Lifetime" name="CWE-772" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-476 NULL Pointer Dereference" name="CWE-476" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-770 Allocation of Resources Without Limits or Throttling" name="CWE-770" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-190 Integer Overflow or Wraparound" name="CWE-190" rules="9" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-78 Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" name="CWE-78" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-617 Reachable Assertion" name="CWE-617" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-835 Loop with Unreachable Exit Condition ('Infinite Loop')" name="CWE-835" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-415 Double Free" name="CWE-415" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-119 Improper Restriction of Operations within the Bounds of a Memory Buffer" name="CWE-119" rules="11" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-416 Use After Free" name="CWE-416" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-611 Improper Restriction of XML External Entity Reference" name="CWE-611" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-732 Incorrect Permission Assignment for Critical Resource" name="CWE-732" rules="2" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="CWE-798 Use of Hard-coded Credentials" name="CWE-798" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-125 Out-of-bounds Read" name="CWE-125" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-400 Uncontrolled Resource Consumption" name="CWE-400" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-269 Improper Privilege Management" name="CWE-269" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-863 Incorrect Authorization" name="CWE-863" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="CWE-200 Information Exposure" name="CWE-200" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-287 Improper Authentication" name="CWE-287" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-362 Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')" name="CWE-362" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-20 Improper Input Validation" name="CWE-20" rules="10" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-22 Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')" name="CWE-22" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-89 Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" name="CWE-89" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-704 Incorrect Type Conversion or Cast" name="CWE-704" rules="12" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-426 Untrusted Search Path" name="CWE-426" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-787 Out-of-bounds Write" name="CWE-787" rules="7" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="CWE-326 Inadequate Encryption Strength" name="CWE-326" rules="1" total="0"/>
            </Category>
            <Category authTot="15;" authUrg="1;" desc="Exceptions" name="EXCEPT" rules="27" total="15"/>
            <Category authTot="164;" authUrg="3;" desc="Formatting" name="FORMAT" rules="52" total="164"/>
            <Category authTot="13;" authUrg="0;" desc="Global Static Analysis" name="GLOBAL" rules="30" total="13"/>
            <Category authTot="0;" authUrg="0;" desc="High Integrity C++" name="HICPP" rules="239" total="0">
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.2.2 Initialize none, the first only or all enumerators in an enumeration" name="HICPP-7_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.1.1 Do not use tab characters in source files" name="HICPP-2_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.5.3 Use nullptr for the null pointer constant" name="HICPP-2_5_3" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="HIC++ 15.1.1 Only use instances of std::exception for exceptions" name="HICPP-15_1_1" rules="2" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.5.2 Do not use octal constants (other than zero)" name="HICPP-2_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.5.1 Do not concatenate strings with different encoding prefixes" name="HICPP-2_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.4.4 Write members in an initialization list in the order in which they are declared" name="HICPP-12_4_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.2.1 Use an explicit enumeration base and ensure that it is large enough to store all enumerators" name="HICPP-7_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.4.5 Use delegating constructors to reduce code duplication" name="HICPP-12_4_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 3.3.1 Do not use variables with static storage duration" name="HICPP-3_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.5.1 Do not ignore the result of std::remove, std::remove if or std::unique" name="HICPP-17_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.2.5 Implement a minimal set of operators and use them to implement all other related operators" name="HICPP-13_2_5" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="HIC++ 4.1.1 Ensure that a function argument does not undergo an array-to-pointer conversion" name="HICPP-4_1_1" rules="2" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.4.2 Ensure that a braced aggregate initializer matches the layout of the aggregate object" name="HICPP-8_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.4.1 Do not access an invalid object or an object with indeterminate value" name="HICPP-8_4_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.1.2 If a member of a set of callable functions includes a universal reference parameter, ensure that one appears in the same position for all other members" name="HICPP-13_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.3.1 Within the scope of a lock, ensure that no static path results in a lock of the same mutex" name="HICPP-18_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.3.2 Ensure that order of nesting of locks in a project forms a DAG" name="HICPP-18_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.3.5 Do not access the members of std::mutex directly" name="HICPP-18_3_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.3.6 Do not use relaxed atomics" name="HICPP-18_3_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.3.3 Ensure that the form of delete matches the form of new used to allocate the memory" name="HICPP-5_3_3" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.3.3 Do not use std::recursive mutex" name="HICPP-18_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.7.2 Ensure that a pointer to member that is a virtual function is only compared (==) with nullptr" name="HICPP-5_7_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.1.1 Ensure that all overloads of a function are visible from where it is called" name="HICPP-13_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.3.4 Only use std::unique lock when std::lock guard cannot be used" name="HICPP-18_3_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.7.1 Do not write code that expects floating point calculations to yield exact results" name="HICPP-5_7_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.3.2 Allocate memory using new and release it using delete" name="HICPP-5_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.3.1 Do not apply unary minus to operands of unsigned type" name="HICPP-5_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 9.2.1 Declare bit-fields with an explicitly unsigned integral or enumeration type" name="HICPP-9_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.3.1 Correctly declare overloads for operator new and delete" name="HICPP-12_3_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.1.4 Ensure that a switch statement has at least two case labels, distinct from the default label" name="HICPP-6_1_4" rules="2" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="HIC++ 11.1.1 Declare all data members private" name="HICPP-11_1_1" rules="2" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.1.3 Ensure that a non-empty case statement block does not fall through to the next label" name="HICPP-6_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.1.2 Explicitly cover all paths through multi-way selection statements" name="HICPP-6_1_2" rules="2" total="0"/>
               <Category authTot="1;" authUrg="1;" desc="HIC++ 6.1.1 Enclose the body of a selection or an iteration statement in a compound statement" name="HICPP-6_1_1" rules="2" total="1"/>
               <Category authTot="2;" authUrg="0;" desc="HIC++ 7.3.1 Do not use using directives" name="HICPP-7_3_1" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 15.2.1 Do not throw an exception from a destructor" name="HICPP-15_2_1" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="HIC++ 2.4.1 Ensure that each identifier is distinct from any other visible identifier" name="HICPP-2_4_1" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.5.7 Declare assignment operators with the ref-qualifier &amp;" name="HICPP-12_5_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 10.3.1 Ensure that a derived class has at most one base class which is not an interface class" name="HICPP-10_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.5.8 Make the copy assignment operator of an abstract class protected or define it =delete" name="HICPP-12_5_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.5.6 Use an atomic, non-throwing swap operation to implement the copy and move assignment operators" name="HICPP-12_5_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.5.3 Ensure that a user defined move/copy constructor only moves/copies base and member objects" name="HICPP-12_5_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.5.4 Declare noexcept the move constructor and move assignment operator" name="HICPP-12_5_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.1.1 Do not use multiple levels of pointer indirection" name="HICPP-8_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 3.2.1 Do not declare functions at block scope" name="HICPP-3_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.4.1 Use const container calls when result is immediately converted to a const iterator" name="HICPP-17_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.4.2 Use API calls that construct objects in place" name="HICPP-17_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 4.4.1 Do not convert floating values to integral types except through use of standard library functions" name="HICPP-4_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.2.1 Do not overload operators with special semantics" name="HICPP-13_2_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.2.2 Synchronize access to data shared between threads using a single lock" name="HICPP-18_2_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.2.2 Ensure that the return type of an overloaded binary operator matches the built-in counterparts" name="HICPP-13_2_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.2.3 Do not share volatile data between threads" name="HICPP-18_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.2.3 Declare binary arithmetic and bitwise operators as non-members" name="HICPP-13_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 13.2.4 When overloading the subscript operator (operator[]) implement both const and non-const versions" name="HICPP-13_2_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.2.1 Use high integrity::thread in place of std::thread" name="HICPP-18_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.6.1 Do not use bitwise operators with signed operands" name="HICPP-5_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.2.4 Use std::call_once rather than the Double-Checked Locking pattern" name="HICPP-18_2_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.2.1 Ensure that pointer or array access is demonstrably within bounds of a valid object" name="HICPP-5_2_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.2.2 Ensure that functions do not call themselves, either directly or indirectly" name="HICPP-5_2_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.4.2 Ensure that a constructor initializes explicitly all base classes and non-static data members" name="HICPP-12_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.4.3 Do not specify both an NSDMI and a member initializer in a constructor for the same non static member" name="HICPP-12_4_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.4.1 Do not use the dynamic type of an object unless the object is fully constructed" name="HICPP-12_4_1" rules="2" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="HIC++ 6.4.1 Postpone variable definitions as long as possible" name="HICPP-6_4_1" rules="2" total="2"/>
               <Category authTot="4;" authUrg="0;" desc="HIC++ 15.3.2 Ensure that a program does not result in a call to std::terminate" name="HICPP-15_3_2" rules="3" total="4"/>
               <Category authTot="4;" authUrg="0;" desc="HIC++ 16.1.1 Use the preprocessor only for implementing include guards, and including header files with include guards" name="HICPP-16_1_1" rules="9" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 16.1.2 Do not include a path specifier in filenames supplied in #include directives" name="HICPP-16_1_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 11.2.1 Do not use friend declarations" name="HICPP-11_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.3.1 Do not use the C comment delimiters /* ... */" name="HICPP-2_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.4.1 Ensure that any objects, functions or types to be used from a single translation unit are defined in an unnamed namespace in the main source file" name="HICPP-7_4_1" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="HIC++ 7.4.3 Ensure that an object or a function used from multiple translation units is declared in a single header file" name="HICPP-7_4_3" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.4.2 Ensure that an inline function, a function template, or a type used from multiple translation units is defined in a single header file" name="HICPP-7_4_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 16.1.5 Include directly the minimum number of headers required for compilation" name="HICPP-16_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 16.1.3 Match the filename in a #include directive to the one on the filesystem" name="HICPP-16_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 15.3.1 Do not access non-static members from a catch handler of constructor/destructor function try block" name="HICPP-15_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 16.1.4 Use &lt;> brackets for system and standard library headers. Use quotes for all other headers" name="HICPP-16_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.3.2 Do not comment out code" name="HICPP-2_3_2" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="HIC++ 10.2.1 Use the override special identifier when overriding a virtual function" name="HICPP-10_2_1" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.3.4 Do not create smart pointers of array type" name="HICPP-17_3_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.3.5 Do not create an rvalue reference of std::array" name="HICPP-17_3_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 3.1.1 Do not hide declarations" name="HICPP-3_1_1" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.3.1 Do not use std::move on objects declared with const or const &amp; type" name="HICPP-17_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 14.1.1 Use variadic templates rather than an ellipsis" name="HICPP-14_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.3.2 Use std::forward to forward universal references" name="HICPP-17_3_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.3.3 Do not subsequently use the argument to std::forward" name="HICPP-17_3_3" rules="1" total="0"/>
               <Category authTot="3;" authUrg="0;" desc="HIC++ 3.5.1 Do not make any assumptions about the internal representation of a value or object" name="HICPP-3_5_1" rules="4" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 4.3.1 Do not convert an expression of wider floating point type to a narrower floating point type" name="HICPP-4_3_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.1.10 Use static assert for assertions involving compile time constants" name="HICPP-7_1_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.2.4 Do not pass std::unique ptr by const reference" name="HICPP-8_2_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.2.3 Pass small objects with a trivial copy constructor by value" name="HICPP-8_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.2.2 Do not declare functions with an excessive number of parameters" name="HICPP-8_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.2.1 Make parameter names absent or identical in all declarations" name="HICPP-8_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.1.1 Do not use platform specific multi-threading facilities" name="HICPP-18_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.1.6 Do not code side effects into the right-hand operands of: &amp;&amp;, ||, sizeof, typeid or a function passed to condition variable::wait" name="HICPP-5_1_6" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.1.5 Include a (possibly empty) parameter list in every lambda expression" name="HICPP-5_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.5.1 Ensure that the right hand operand of the division or remainder operators is demonstrably non-zero" name="HICPP-5_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.1.2 Do not rely on the sequence of evaluation within an expression" name="HICPP-5_1_2" rules="10" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="HIC++ 5.1.1 Use symbolic names instead of literal values in code" name="HICPP-5_1_1" rules="1" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.1.4 Do not capture variables implicitly in a lambda" name="HICPP-5_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.1.3 Use parentheses in expressions to specify the intent of the expression" name="HICPP-5_1_3" rules="2" total="0"/>
               <Category authTot="6;" authUrg="0;" desc="HIC++ 12.5.1 Define explicitly =default or =delete implicit special member functions of concrete classes" name="HICPP-12_5_1" rules="1" total="6"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.5.2 Define special members =default if the behavior is equivalent" name="HICPP-12_5_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.3.2 Ensure that execution of a function with a non-void return type ends in a return statement with a value" name="HICPP-6_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.1.1 Do not declare implicit user defined conversions" name="HICPP-12_1_1" rules="2" total="0"/>
               <Category authTot="7;" authUrg="0;" desc="HIC++ 1.2.1 Ensure that all statements are reachable" name="HICPP-1_2_1" rules="10" total="7"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 1.2.2 Ensure that no expression or sub-expression is redundant" name="HICPP-1_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.3.1 Ensure that the label(s) for a jump statement or a switch condition appear later, in the same or an enclosing block" name="HICPP-6_3_1" rules="3" total="0"/>
               <Category authTot="3;" authUrg="0;" desc="HIC++ 7.1.4 Place CV-qualifiers on the right hand side of the type they apply to" name="HICPP-7_1_4" rules="1" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 2.2.1 Do not use digraphs or trigraphs" name="HICPP-2_2_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.1.3 Do not place type specifiers before non-type specifiers in a declaration" name="HICPP-7_1_3" rules="1" total="0"/>
               <Category authTot="3;" authUrg="0;" desc="HIC++ 7.1.6 Use class types or typedefs to abstract scalar quantities and standard integer types" name="HICPP-7_1_6" rules="3" total="3"/>
               <Category authTot="1;" authUrg="0;" desc="HIC++ 7.1.5 Do not inline large functions" name="HICPP-7_1_5" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.5.1 Do not use the asm declaration" name="HICPP-7_5_1" rules="1" total="0"/>
               <Category authTot="10;" authUrg="0;" desc="HIC++ 7.1.8 Use auto id = expr when declaring a variable to have the same type as its initializer function call" name="HICPP-7_1_8" rules="1" total="10"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.1.7 Use a trailing return type in preference to type disambiguation using typename" name="HICPP-7_1_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.1.9 Do not explicitly specify the return type of a lambda" name="HICPP-7_1_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 10.1.1 Ensure that access to base class subobjects does not require explicit disambiguation" name="HICPP-10_1_1" rules="1" total="0"/>
               <Category authTot="3;" authUrg="1;" desc="HIC++ 7.1.2 Use const whenever possible" name="HICPP-7_1_2" rules="2" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 7.1.1 Declare each identifier on a separate line in a separate declaration" name="HICPP-7_1_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 14.2.2 Do not explicitly specialize a function template that is overloaded with other templates" name="HICPP-14_2_2" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="HIC++ 17.2.1 Wrap use of the C Standard Library" name="HICPP-17_2_1" rules="2" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 3.4.1 Do not return a reference or a pointer to an automatic variable defined within the function" name="HICPP-3_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 14.2.3 Declare extern an explicitly instantiated template" name="HICPP-14_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 3.4.3 Use RAII for resources" name="HICPP-3_4_3" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 14.2.1 Declare template specializations in the same file as the primary template they specialize." name="HICPP-14_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 3.4.2 Do not assign the address of a variable to a pointer with a greater lifetime" name="HICPP-3_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 4.2.2 Ensure that data loss does not demonstrably occur in an integral expression" name="HICPP-4_2_2" rules="9" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 4.2.1 Ensure that the U suffix is applied to a literal used in a context requiring an unsigned integral expression" name="HICPP-4_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.3.4 Define =delete functions with parameters of type rvalue reference to const" name="HICPP-8_3_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.3.3 Do not use default arguments" name="HICPP-8_3_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 8.3.1 Do not write functions with an excessive McCabe Cyclomatic Complexity" name="HICPP-8_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 18.4.1 Do not use std::condition variable any on a std::mutex" name="HICPP-18_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.4.3 Do not convert from a base class to a derived class" name="HICPP-5_4_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.4.2 Do not cast an expression to an enumeration type" name="HICPP-5_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.8.1 Do not use the conditional operator (?:) as a sub-expression" name="HICPP-5_8_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 5.4.1 Only use casting forms: static cast (excl. void*), dynamic cast or explicit constructor call" name="HICPP-5_4_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 9.1.5 Do not introduce virtual functions in a final class" name="HICPP-9_1_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 17.1.1 Do not use std::vector&lt;bool>" name="HICPP-17_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 9.1.3 Do not return non-const handles to class data from const member functions" name="HICPP-9_1_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 9.1.4 Do not write member functions which return non-const handles to data less accessible than the member function" name="HICPP-9_1_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 9.1.1 Declare static any member function that does not require this. Alternatively, declare const any member function that does not modify the externally visible state of the object" name="HICPP-9_1_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 9.1.2 Make default arguments the same or absent when overriding a virtual function" name="HICPP-9_1_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 1.3.4 Do not use deprecated STL library features" name="HICPP-1_3_4" rules="1" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="HIC++ 1.3.3 Do not use the C Standard Library .h headers" name="HICPP-1_3_3" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.2.4 Only modify a for loop counter in the for expression" name="HICPP-6_2_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 1.3.5 Do not use throw exception specifications" name="HICPP-1_3_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.2.3 Do not alter a control or counter variable more than once in a loop" name="HICPP-6_2_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 12.2.1 Declare virtual, private or protected the destructor of a type used as a base class" name="HICPP-12_2_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 1.3.2 Do not use the register keyword" name="HICPP-1_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 1.3.1 Do not use the increment operator (++) on a variable of type bool" name="HICPP-1_3_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.2.2 Ensure that a loop has a single loop counter, an optional control variable, and is not degenerate" name="HICPP-6_2_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="HIC++ 6.2.1 Implement a loop that only uses element values as a range-based loop" name="HICPP-6_2_1" rules="1" total="0"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="Initialization" name="INIT" rules="25" total="0"/>
            <Category authTot="183;" authUrg="6;" desc="Joint Strike Fighter" name="JSF" rules="278" total="183"/>
            <Category authTot="39;" authUrg="4;" desc="Metrics" name="METRICS" rules="44" total="39"/>
            <Category authTot="16;" authUrg="0;" desc="MISRA C 1998" name="MISRA" rules="62" total="16"/>
            <Category authTot="23;" authUrg="1;" desc="MISRA C 2004" name="MISRA2004" rules="223" total="23"/>
            <Category authTot="74;" authUrg="2;" desc="MISRA C++ 2008" name="MISRA2008" rules="342" total="74"/>
            <Category authTot="0;" authUrg="0;" desc="MISRA C 2012 (Legacy)" name="MISRA2012" rules="382" total="0">
               <Category authTot="24;" authUrg="1;" desc="MISRA C 2012 Rules" name="MISRA2012-RULE" rules="331" total="24"/>
               <Category authTot="3;" authUrg="0;" desc="MISRA C 2012 Directives" name="MISRA2012-DIR" rules="51" total="3"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="MISRA C 2023 (MISRA C 2012)" name="MISRAC2012" rules="382" total="0">
               <Category authTot="0;" authUrg="0;" desc="Rule 11.3 (Required) A conversion shall not be performed between a pointer to object type and a pointer to a different object type" name="MISRAC2012-RULE_11_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.13 (Required) A line whose first token is # shall be a valid preprocessing directive" name="MISRAC2012-RULE_20_13" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.5 (Required) An external object or function shall be declared once in one and only one file" name="MISRAC2012-RULE_8_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.4 (Advisory) A conversion should not be performed between a pointer to object and an integer type" name="MISRAC2012-RULE_11_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.12 (Required) A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" name="MISRAC2012-RULE_20_12" rules="1" total="0"/>
               <Category authTot="4;" authUrg="0;" desc="Rule 8.6 (Required) An identifier with external linkage shall have exactly one external definition" name="MISRAC2012-RULE_8_6" rules="2" total="4"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.5 (Advisory) A conversion should not be performed from pointer to void into pointer to object" name="MISRAC2012-RULE_11_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 15.1 (Advisory) The goto statement should not be used" name="MISRAC2012-RULE_15_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.11 (Required) A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" name="MISRAC2012-RULE_20_11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.3 (Required) All declarations of an object or function shall use the same names and type qualifiers" name="MISRAC2012-RULE_8_3" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.6 (Required) A cast shall not be performed between pointer to void and an arithmetic type" name="MISRAC2012-RULE_11_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 15.2 (Required) The goto statement shall jump to a label declared later in the same function" name="MISRAC2012-RULE_15_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.10 (Advisory) The # and ## preprocessor operators should not be used" name="MISRAC2012-RULE_20_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.4 (Required) A compatible declaration shall be visible when an object or function with external linkage is defined" name="MISRAC2012-RULE_8_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.7 (Required) A cast shall not be performed between pointer to object and a non-integer arithmetic type" name="MISRAC2012-RULE_11_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 15.3 (Required) Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement" name="MISRAC2012-RULE_15_3" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="Rule 8.9 (Advisory) An object should be declared at block scope if its identifier only appears in a single function" name="MISRAC2012-RULE_8_9" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.8 (Required) A conversion shall not remove any const, volatile or _Atomic qualification from the type pointed to by a pointer" name="MISRAC2012-RULE_11_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 15.4 (Advisory) There should be no more than one break or goto statement used to terminate any iteration statement" name="MISRAC2012-RULE_15_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.9 (Required) The macro NULL shall be the only permitted form of integer null pointer constant" name="MISRAC2012-RULE_11_9" rules="2" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="Rule 15.5 (Advisory) A function should have a single point of exit at the end" name="MISRAC2012-RULE_15_5" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 19.1 (Mandatory) An object shall not be assigned or copied to an overlapping object" name="MISRAC2012-RULE_19_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.7 (Advisory) Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" name="MISRAC2012-RULE_8_7" rules="1" total="0"/>
               <Category authTot="1;" authUrg="1;" desc="Rule 15.6 (Required) The body of an iteration-statement or a selection-statement shall be a compound-statement" name="MISRAC2012-RULE_15_6" rules="2" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 19.2 (Advisory) The union keyword should not be used" name="MISRAC2012-RULE_19_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.8 (Required) The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage" name="MISRAC2012-RULE_8_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.14 (Required) The validity of values received from external sources shall be checked" name="MISRAC2012-DIR_4_14" rules="12" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 15.7 (Required) All if ... else if constructs shall be terminated with an else statement" name="MISRAC2012-RULE_15_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.13 (Advisory) Functions which are designed to provide operations on a resource should be called in an appropriate sequence" name="MISRAC2012-DIR_4_13" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.12 (Required) Dynamic memory allocation shall not be used" name="MISRAC2012-DIR_4_12" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.11 (Required) The validity of values passed to library functions shall be checked" name="MISRAC2012-DIR_4_11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.10 (Required) Precautions shall be taken in order to prevent the contents of a header file being included more than once" name="MISRAC2012-DIR_4_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.14 (Required) All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related" name="MISRAC2012-RULE_20_14" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 4.1 (Required) Octal and hexadecimal escape sequences shall be terminated" name="MISRAC2012-RULE_4_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 4.2 (Advisory) Trigraphs should not be used" name="MISRAC2012-RULE_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.1 (Required) Types shall be explicitly specified" name="MISRAC2012-RULE_8_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.2 (Required) Function types shall be in prototype form with named parameters" name="MISRAC2012-RULE_8_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.1 (Required) Conversions shall not be performed between a pointer to a function and any other type" name="MISRAC2012-RULE_11_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 11.2 (Required) Conversions shall not be performed between a pointer to an incomplete type and any other type" name="MISRAC2012-RULE_11_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.3 (Required) The same file shall not be open for read and write access at the same time on different streams" name="MISRAC2012-RULE_22_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.4 (Mandatory) There shall be no attempt to write to a stream which has been opened as read-only" name="MISRAC2012-RULE_22_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.5 (Mandatory) A pointer to a FILE object shall not be dereferenced" name="MISRAC2012-RULE_22_5" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.6 (Mandatory) The value of a pointer to a FILE shall not be used after the associated stream has been closed" name="MISRAC2012-RULE_22_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.7 (Required) The macro EOF shall only be compared with the unmodified return value from any Standard Library function capable of returning EOF" name="MISRAC2012-RULE_22_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.8 (Required) The value of errno shall be set to zero prior to a call to an errno-setting-function" name="MISRAC2012-RULE_22_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.9 (Required) The value of errno shall be tested against zero after calling an errno-setting-function" name="MISRAC2012-RULE_22_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.1 (Required) All resources obtained dynamically by means of Standard Library functions shall be explicitly released" name="MISRAC2012-RULE_22_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.2 (Mandatory) A block of memory shall only be freed if it was allocated by means of a" name="MISRAC2012-RULE_22_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.4 (Required) Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" name="MISRAC2012-RULE_10_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.5 (Advisory) The value of an expression should not be cast to an inappropriate essential type" name="MISRAC2012-RULE_10_5" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 14.1 (Required) A loop counter shall not have essentially floating type" name="MISRAC2012-RULE_14_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.6 (Required) The value of a composite expression shall not be assigned to an object with wider essential type" name="MISRAC2012-RULE_10_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 14.2 (Required) A for loop shall be well-formed" name="MISRAC2012-RULE_14_2" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 7.4 (Required) A string literal shall not be assigned to an object unless the object's type is &quot;pointer to const-qualified char&quot;" name="MISRAC2012-RULE_7_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.7 (Required) If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" name="MISRAC2012-RULE_10_7" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 14.3 (Required) Controlling expressions shall not be invariant" name="MISRAC2012-RULE_14_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.8 (Required) The value of a composite expression shall not be cast to a different essential type category or a wider essential type" name="MISRAC2012-RULE_10_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 14.4 (Required) The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type" name="MISRAC2012-RULE_14_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.1 (Required) A pointer resulting from arithmetic on a pointer operand shall address an element of the same array as that pointer operand" name="MISRAC2012-RULE_18_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.2 (Required) Subtraction between pointers shall only be applied to pointers that address elements of the same array" name="MISRAC2012-RULE_18_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.3 (Required) The relational operators >, >=, &lt; and &lt;= shall not be applied to expressions of pointer type except where they point into the same object" name="MISRAC2012-RULE_18_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.4 (Advisory) The +, -, += and -= operators should not be applied to an expression of pointer type" name="MISRAC2012-RULE_18_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.5 (Advisory) Declarations should contain no more than two levels of pointer nesting" name="MISRAC2012-RULE_18_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.6 (Required) The address of an object with automatic or thread-local storage shall not be copied to another object that persists after the first object has ceased to exist" name="MISRAC2012-RULE_18_6" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.7 (Required) Flexible array members shall not be declared" name="MISRAC2012-RULE_18_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 18.8 (Required) Variable-length arrays shall not be used" name="MISRAC2012-RULE_18_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 3.2 (Required) Line-splicing shall not be used in // comments" name="MISRAC2012-RULE_3_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 3.1 (Required) The character sequences /* and // shall not be used within a comment" name="MISRAC2012-RULE_3_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 7.2 (Required) A &quot;u&quot; or &quot;U&quot; suffix shall be applied to all integer constants that are represented in an unsigned type" name="MISRAC2012-RULE_7_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.1 (Required) Operands shall not be of an inappropriate essential type" name="MISRAC2012-RULE_10_1" rules="8" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 7.3 (Required) The lowercase character &quot;l&quot; shall not be used in a literal suffix" name="MISRAC2012-RULE_7_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.2 (Required) Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" name="MISRAC2012-RULE_10_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 10.3 (Required) The value of an expression shall not be assigned to an object with a narrower essential type or of a different essential type category" name="MISRAC2012-RULE_10_3" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 7.1 (Required) Octal constants shall not be used" name="MISRAC2012-RULE_7_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.14 (Required) The Standard Library function memcmp shall not be used to compare null terminated strings" name="MISRAC2012-RULE_21_14" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.4 (Required) The standard header file &lt;setjmp.h> shall not be used" name="MISRAC2012-RULE_21_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.13 (Mandatory) Any value passed to a function in &lt;ctype.h> shall be representable as an unsigned char or be the value EOF" name="MISRAC2012-RULE_21_13" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.5 (Required) The standard header file &lt;signal.h> shall not be used" name="MISRAC2012-RULE_21_5" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.12 (Required) The standard header file &lt;fenv.h> shall not be used" name="MISRAC2012-RULE_21_12" rules="2" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="Rule 21.6 (Required) The Standard Library input/output functions shall not be used" name="MISRAC2012-RULE_21_6" rules="1" total="1"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.11 (Required) The standard header file &lt;tgmath.h> shall not be used" name="MISRAC2012-RULE_21_11" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="Rule 21.7 (Required) The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_7" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.10 (Required) The Standard Library time and date functions shall not be used" name="MISRAC2012-RULE_21_10" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.8 (Required) The Standard Library termination functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_8" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.9 (Required) The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.19 (Mandatory) The pointers returned by the Standard Library functions localeconv, getenv, setlocale or, strerror shall only be used as if they have pointer to const-qualified type" name="MISRAC2012-RULE_21_19" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.18 (Mandatory) The size_t argument passed to any function in &lt;string.h> shall have an appropriate value" name="MISRAC2012-RULE_21_18" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.17 (Mandatory) Use of the string handling functions from &lt;string.h> shall not result in accesses beyond the bounds of the objects referenced by their pointer parameters" name="MISRAC2012-RULE_21_17" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.16 (Required) The pointer arguments to the Standard Library function memcmp shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" name="MISRAC2012-RULE_21_16" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.15 (Required) The pointer arguments to the Standard Library functions memcpy, memmove and memcmp shall be pointers to qualified or unqualified versions of compatible types" name="MISRAC2012-RULE_21_15" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.1 (Required) #define and #undef shall not be used on a reserved identifier or reserved macro name" name="MISRAC2012-RULE_21_1" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.2 (Required) A reserved identifier or macro name shall not be declared" name="MISRAC2012-RULE_21_2" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.3 (Required) The memory allocation and deallocation functions of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 13.1 (Required) Initializer lists shall not contain persistent side effects" name="MISRAC2012-RULE_13_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 13.2 (Required) The value of an expression and its persistent side effects shall be the same under all permitted evaluation orders and shall be independent from thread interleaving" name="MISRAC2012-RULE_13_2" rules="8" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 13.3 (Advisory) A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator" name="MISRAC2012-RULE_13_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 13.4 (Advisory) The result of an assignment operator should not be used" name="MISRAC2012-RULE_13_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 13.5 (Required) The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects" name="MISRAC2012-RULE_13_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.1 (Required) The features of &lt;stdarg.h> shall not be used" name="MISRAC2012-RULE_17_1" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.21 (Required) The Standard Library function system of &lt;stdlib.h> shall not be used" name="MISRAC2012-RULE_21_21" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 13.6 (Required) The operand of the sizeof operator shall not contain any expression which has potential side effects" name="MISRAC2012-RULE_13_6" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.2 (Required) Functions shall not call themselves, either directly or indirectly" name="MISRAC2012-RULE_17_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 21.20 (Mandatory) The pointer returned by the Standard Library functions asctime, ctime, gmtime, localtime, localeconv, getenv, setlocale or strerror shall not be used following a subsequent call to the same function" name="MISRAC2012-RULE_21_20" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.3 (Mandatory) A function shall not be declared implicitly" name="MISRAC2012-RULE_17_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.4 (Mandatory) All exit paths from a function with non-void return type shall have an explicit return statement with an expression" name="MISRAC2012-RULE_17_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.5 (Required) The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" name="MISRAC2012-RULE_17_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.6 (Mandatory) The declaration of an array parameter shall not contain the static keyword between the [ ]" name="MISRAC2012-RULE_17_6" rules="1" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="Rule 17.7 (Required) The value returned by a function having non-void return type shall be used" name="MISRAC2012-RULE_17_7" rules="2" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 17.8 (Advisory) A function parameter should not be modified" name="MISRAC2012-RULE_17_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.3 (Advisory) A project should not contain unused type declarations" name="MISRAC2012-RULE_2_3" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.4 (Advisory) A project should not contain unused tag declarations" name="MISRAC2012-RULE_2_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.1 (Required) A project shall not contain unreachable code" name="MISRAC2012-RULE_2_1" rules="8" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.2 (Required) A project shall not contain dead code" name="MISRAC2012-RULE_2_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.7 (Advisory) A function should not contain unused parameters" name="MISRAC2012-RULE_2_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.5 (Advisory) A project should not contain unused macro definitions" name="MISRAC2012-RULE_2_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 6.1 (Required) Bit-fields shall only be declared with an appropriate type" name="MISRAC2012-RULE_6_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 2.6 (Advisory) A function should not contain unused label declarations" name="MISRAC2012-RULE_2_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 6.2 (Required) Single-bit named bit fields shall not be of a signed type" name="MISRAC2012-RULE_6_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.5 (Advisory) #undef should not be used" name="MISRAC2012-RULE_20_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.6 (Required) Tokens that look like a preprocessing directive shall not occur within a macro argument" name="MISRAC2012-RULE_20_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.7 (Required) Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses" name="MISRAC2012-RULE_20_7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.8 (Required) The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" name="MISRAC2012-RULE_20_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.9 (Required) All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation" name="MISRAC2012-RULE_20_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.1 (Advisory) #include directives should only be preceded by preprocessor directives or comments" name="MISRAC2012-RULE_20_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.2 (Required) The ', &quot; or \ characters and the /* or // character sequences shall not occur in a header file name" name="MISRAC2012-RULE_20_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.3 (Required) The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" name="MISRAC2012-RULE_20_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 20.4 (Required) A macro shall not be defined with the same name as a keyword" name="MISRAC2012-RULE_20_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 12.2 (Required) The right hand operand of a shift operator shall lie in the range zero to one less than the width in bits of the essential type of the left hand operand" name="MISRAC2012-RULE_12_2" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.8 (Required) Identifiers that define objects or functions with external linkage shall be unique" name="MISRAC2012-RULE_5_8" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 9.4 (Required) An element of an object shall not be initialized more than once" name="MISRAC2012-RULE_9_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 12.3 (Advisory) The comma operator should not be used" name="MISRAC2012-RULE_12_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.9 (Advisory) Identifiers that define objects or functions with internal linkage should be unique" name="MISRAC2012-RULE_5_9" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 9.5 (Required) Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" name="MISRAC2012-RULE_9_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 12.4 (Advisory) Evaluation of constant expressions should not lead to unsigned integer wrap-around" name="MISRAC2012-RULE_12_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.6 (Required) A typedef name shall be a unique identifier" name="MISRAC2012-RULE_5_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 9.2 (Required) The initializer for an aggregate or union shall be enclosed in braces" name="MISRAC2012-RULE_9_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 12.5 (Mandatory) The sizeof operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" name="MISRAC2012-RULE_12_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.1 (Required) All switch statements shall be well-formed" name="MISRAC2012-RULE_16_1" rules="8" total="0"/>
               <Category authTot="10;" authUrg="0;" desc="Rule 5.7 (Required) A tag name shall be a unique identifier" name="MISRAC2012-RULE_5_7" rules="1" total="10"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 9.3 (Required) Arrays shall not be partially initialized" name="MISRAC2012-RULE_9_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.2 (Required) A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" name="MISRAC2012-RULE_16_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.3 (Required) An unconditional break statement shall terminate every switch-clause" name="MISRAC2012-RULE_16_3" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 22.10 (Required) The value of errno shall only be tested when the last function to be called was an errno-setting-function" name="MISRAC2012-RULE_22_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.4 (Required) Every switch statement shall have a default label" name="MISRAC2012-RULE_16_4" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.5 (Required) A default label shall appear as either the first or the last switch label of a switch statement" name="MISRAC2012-RULE_16_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.9 (Advisory) A function should be used in preference to a function-like macro where they are interchangeable" name="MISRAC2012-DIR_4_9" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.6 (Required) Every switch statement shall have at least two switch-clauses" name="MISRAC2012-RULE_16_6" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.8 (Advisory) If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" name="MISRAC2012-DIR_4_8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 16.7 (Required) A switch-expression shall not have essentially Boolean type" name="MISRAC2012-RULE_16_7" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.5 (Advisory) Identifiers in the same name space with overlapping visibility should be typographically unambiguous" name="MISRAC2012-DIR_4_5" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.4 (Advisory) Sections of code should not be &quot;commented out&quot;" name="MISRAC2012-DIR_4_4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.7 (Required) If a function returns error information, then that error information shall be tested" name="MISRAC2012-DIR_4_7" rules="2" total="0"/>
               <Category authTot="3;" authUrg="0;" desc="Dir 4.6 (Advisory) typedefs that indicate size and signedness should be used in place of the basic numerical types" name="MISRAC2012-DIR_4_6" rules="3" total="3"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.1 (Required) Run-time failures shall be minimized" name="MISRAC2012-DIR_4_1" rules="13" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.12 (Required) Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" name="MISRAC2012-RULE_8_12" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.13 (Advisory) A pointer should point to a const-qualified type whenever possible" name="MISRAC2012-RULE_8_13" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.3 (Required) Assembly language shall be encapsulated and isolated" name="MISRAC2012-DIR_4_3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.14 (Required) The restrict type qualifier shall not be used" name="MISRAC2012-RULE_8_14" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Dir 4.2 (Advisory) All usage of assembly language should be documented" name="MISRAC2012-DIR_4_2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 1.1 (Required) The program shall contain no violations of the standard C syntax and constraints, and shall not exceed the implementation's translation limits" name="MISRAC2012-RULE_1_1" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.10 (Required) An inline function shall be declared with the static storage class" name="MISRAC2012-RULE_8_10" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 8.11 (Advisory) When an array with external linkage is declared, its size should be explicitly specified" name="MISRAC2012-RULE_8_11" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 1.4 (Required) Emergent language features shall not be used" name="MISRAC2012-RULE_1_4" rules="5" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.1 (Required) External identifiers shall be distinct" name="MISRAC2012-RULE_5_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 1.3 (Required) There shall be no occurrence of undefined or critical unspecified behaviour" name="MISRAC2012-RULE_1_3" rules="15" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.4 (Required) Macro identifiers shall be distinct" name="MISRAC2012-RULE_5_4" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.5 (Required) Identifiers shall be distinct from macro names" name="MISRAC2012-RULE_5_5" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 9.1 (Mandatory) The value of an object with automatic storage duration shall not be read before it has been set" name="MISRAC2012-RULE_9_1" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.2 (Required) Identifiers declared in the same scope and name space shall be distinct" name="MISRAC2012-RULE_5_2" rules="4" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 12.1 (Advisory) The precedence of operators within expressions should be made explicit" name="MISRAC2012-RULE_12_1" rules="2" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="Rule 5.3 (Required) An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" name="MISRAC2012-RULE_5_3" rules="2" total="0"/>
            </Category>
            <Category authTot="4;" authUrg="0;" desc="Memory and Resource Management" name="MRM" rules="67" total="4"/>
            <Category authTot="50;" authUrg="2;" desc="Naming Conventions" name="NAMING" rules="103" total="50">
               <Category authTot="30;" authUrg="0;" desc="Hungarian Notation" name="NAMING-HN" rules="44" total="30"/>
            </Category>
            <Category authTot="11;" authUrg="0;" desc="Object Oriented" name="OOP" rules="62" total="11"/>
            <Category authTot="7;" authUrg="1;" desc="Optimization" name="OPT" rules="49" total="7"/>
            <Category authTot="0;" authUrg="0;" desc="OWASP Top 10 Most Critical Web Application Security Risks (2017)" name="OWASP2017" rules="16" total="0">
               <Category authTot="0;" authUrg="0;" desc="OWASP A3 Sensitive Data Exposure" name="OWASP2017-A3" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A2 Broken Authentication" name="OWASP2017-A2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A1 Injection" name="OWASP2017-A1" rules="6" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="OWASP A10 Insufficient Logging&amp;Monitoring" name="OWASP2017-A10" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A6 Security Misconfiguration" name="OWASP2017-A6" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A5 Broken Access Control" name="OWASP2017-A5" rules="3" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A4 XML External Entities (XXE)" name="OWASP2017-A4" rules="1" total="0"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="OWASP API Security Top 10 (2019)" name="OWASP2019" rules="42" total="0">
               <Category authTot="0;" authUrg="0;" desc="OWASP API2 Broken User Authentication" name="OWASP2019-API2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP API4 Lack of Resources &amp; Rate Limiting" name="OWASP2019-API4" rules="2" total="0"/>
               <Category authTot="1;" authUrg="0;" desc="OWASP API3 Excessive Data Exposure" name="OWASP2019-API3" rules="17" total="1"/>
               <Category authTot="2;" authUrg="0;" desc="OWASP API10 Insufficient Logging &amp; Monitoring" name="OWASP2019-API10" rules="2" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP API9 Improper Assets Management" name="OWASP2019-API9" rules="7" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP API8 Injection" name="OWASP2019-API8" rules="10" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP API7 Security Misconfiguration" name="OWASP2019-API7" rules="3" total="0"/>
            </Category>
            <Category authTot="0;" authUrg="0;" desc="OWASP Top 10 Most Critical Web Application Security Risks (2021)" name="OWASP2021" rules="18" total="0">
               <Category authTot="0;" authUrg="0;" desc="OWASP A8 Software and Data Integrity Failures" name="OWASP2021-A8" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A7 Identification and Authentication Failures" name="OWASP2021-A7" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A5 Security Misconfiguration" name="OWASP2021-A5" rules="4" total="0"/>
               <Category authTot="2;" authUrg="0;" desc="OWASP A9 Security Logging and Monitoring Failures" name="OWASP2021-A9" rules="1" total="2"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A4 Insecure Design" name="OWASP2021-A4" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A3 Injection" name="OWASP2021-A3" rules="6" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A2 Cryptographic Failures" name="OWASP2021-A2" rules="1" total="0"/>
               <Category authTot="0;" authUrg="0;" desc="OWASP A1 Broken Access Control" name="OWASP2021-A1" rules="3" total="0"/>
            </Category>
            <Category authTot="10;" authUrg="1;" desc="Parser diagnostics" name="PARSER" rules="2" total="10"/>
            <Category authTot="12;" authUrg="0;" desc="Possible Bugs" name="PB" rules="88" total="12"/>
            <Category authTot="8;" authUrg="1;" desc="Physical File Organization" name="PFO" rules="10" total="8"/>
            <Category authTot="14;" authUrg="0;" desc="Portability" name="PORT" rules="40" total="14"/>
            <Category authTot="44;" authUrg="0;" desc="Preprocessor" name="PREPROC" rules="33" total="44"/>
            <Category authTot="0;" authUrg="0;" desc="Qt Best Practices" name="QT" rules="18" total="0"/>
            <Category authTot="14;" authUrg="0;" desc="Security" name="SECURITY" rules="56" total="14"/>
            <Category authTot="4;" authUrg="0;" desc="STL Best Practices" name="STL" rules="42" total="4"/>
            <Category authTot="0;" authUrg="0;" desc="Template" name="TEMPL" rules="19" total="0"/>
         </CategoriesList>
         <RulesList>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-000160" desc="Do not use weak encryption functions" id="APSC_DV-000160-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-000170" desc="Do not use weak encryption functions" id="APSC_DV-000170-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-000480" desc="Protect against SQL injection" id="APSC_DV-000480-a" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-000500" desc="Observe correct revocation order while relinquishing privileges" id="APSC_DV-000500-a" origId="SECURITY-44" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="APSC_DV-000650" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="APSC_DV-000650-a" origId="SECURITY-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001290" desc="Protect against SQL injection" id="APSC_DV-001290-a" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001290" desc="Untrusted data is used as a loop boundary" id="APSC_DV-001290-b" origId="SECURITY-38" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001290" desc="Avoid passing user input into methods as parameters" id="APSC_DV-001290-c" origId="SECURITY-20" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001290" desc="Avoid using unsecured shell functions that may be affected by shell metacharacters" id="APSC_DV-001290-d" origId="SECURITY-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001300" desc="Protect against SQL injection" id="APSC_DV-001300-a" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001740" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-001740-a" origId="BD-SECURITY-SENSLOG" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001750" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-001750-a" origId="BD-SECURITY-SENSLOG" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001850" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-001850-a" origId="BD-SECURITY-SENSLOG" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001860" desc="Do not use weak encryption functions" id="APSC_DV-001860-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Avoid race conditions when using fork and file descriptors" id="APSC_DV-001995-a" origId="BD-TRS-FORKFILE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Avoid race conditions while checking for the existence of a symbolic link" id="APSC_DV-001995-b" origId="BD-TRS-SYMLINK" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Avoid race conditions while accessing files" id="APSC_DV-001995-c" origId="BD-TRS-FRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Use locks to prevent race conditions when modifying bit fields" id="APSC_DV-001995-d" origId="BD-TRS-BITLOCK" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Do not use global variable with different locks set" id="APSC_DV-001995-e" origId="BD-TRS-MLOCK" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Avoid using thread-unsafe functions" id="APSC_DV-001995-f" origId="SECURITY-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Usage of functions prone to race is not allowed" id="APSC_DV-001995-g" origId="SECURITY-19" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Avoid using the 'vfork()' function" id="APSC_DV-001995-h" origId="SECURITY-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-001995" desc="Properly define signal handlers" id="APSC_DV-001995-i" origId="BD-PB-SIGHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002000" desc="Ensure resources are freed" id="APSC_DV-002000-a" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002010" desc="Do not use weak encryption functions" id="APSC_DV-002010-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002290" desc="Do not use the rand() function for generating pseudorandom numbers" id="APSC_DV-002290-a" origId="SECURITY-02_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002290" desc="Properly seed pseudorandom number generators" id="APSC_DV-002290-b" origId="BD-SECURITY-RAND" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002290" desc="The 'random_shuffle' identifier should not be used" id="APSC_DV-002290-c" origId="CODSTA-MCPP-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002290" desc="The random number generator functions 'rand()' and 'srand()' should not be used" id="APSC_DV-002290-d" origId="SECURITY-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002350" desc="Do not use weak encryption functions" id="APSC_DV-002350-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002390" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="APSC_DV-002390-a" origId="BD-SECURITY-XXEXRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002390" desc="Do not process structured text data natively" id="APSC_DV-002390-b" origId="CODSTA-201" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002390" desc="Do not use scanf and fscanf functions without specifying variable size in format string" id="APSC_DV-002390-c" origId="SECURITY-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002390" desc="Do not use mbstowcs() function" id="APSC_DV-002390-d" origId="SECURITY-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002400" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002400-a" origId="BD-SECURITY-TDINPUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002400" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="APSC_DV-002400-b" origId="PB-44" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002400" desc="Avoid using the 'vfork()' function" id="APSC_DV-002400-c" origId="SECURITY-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002400" desc="Avoid using thread-unsafe functions" id="APSC_DV-002400-d" origId="SECURITY-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002440" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002440-a" origId="BD-SECURITY-SENSLOG" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002460" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002460-a" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002470" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002470-a" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="APSC_DV-002480" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="APSC_DV-002480-a" origId="SECURITY-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002510" desc="Protect against command injection" id="APSC_DV-002510-a" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Protect against environment injection" id="APSC_DV-002520-a" origId="BD-SECURITY-TDENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Protect against file name injection" id="APSC_DV-002520-b" origId="BD-SECURITY-TDFNAMES" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Protect against SQL injection" id="APSC_DV-002520-c" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002520-d" origId="SECURITY-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Avoid tainted data in array indexes" id="APSC_DV-002520-e" origId="BD-SECURITY-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002520-f" origId="BD-SECURITY-INTOVERF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002520-g" origId="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Protect against command injection" id="APSC_DV-002520-h" origId="BD-SECURITY-TDCMD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Avoid printing tainted data on the output console" id="APSC_DV-002520-i" origId="BD-SECURITY-TDCONSOLE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002520-j" origId="BD-SECURITY-TDINPUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002520" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002520-k" origId="SECURITY-38" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Protect against environment injection" id="APSC_DV-002530-a" origId="BD-SECURITY-TDENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Protect against file name injection" id="APSC_DV-002530-b" origId="BD-SECURITY-TDFNAMES" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Protect against SQL injection" id="APSC_DV-002530-c" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002530-d" origId="SECURITY-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Avoid tainted data in array indexes" id="APSC_DV-002530-e" origId="BD-SECURITY-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002530-f" origId="BD-SECURITY-INTOVERF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002530-g" origId="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Protect against command injection" id="APSC_DV-002530-h" origId="BD-SECURITY-TDCMD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Avoid printing tainted data on the output console" id="APSC_DV-002530-i" origId="BD-SECURITY-TDCONSOLE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002530-j" origId="BD-SECURITY-TDINPUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002530" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002530-k" origId="SECURITY-38" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002540" desc="Protect against SQL injection" id="APSC_DV-002540-a" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Protect against environment injection" id="APSC_DV-002550-a" origId="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Protect against file name injection" id="APSC_DV-002550-b" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Protect against SQL injection" id="APSC_DV-002550-c" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002550-d" origId="SECURITY-36" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Avoid tainted data in array indexes" id="APSC_DV-002550-e" origId="BD-SECURITY-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002550-f" origId="BD-SECURITY-INTOVERF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002550-g" origId="BD-SECURITY-LOG" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Protect against command injection" id="APSC_DV-002550-h" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Avoid printing tainted data on the output console" id="APSC_DV-002550-i" origId="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002550-j" origId="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002550" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002550-k" origId="SECURITY-38" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Protect against environment injection" id="APSC_DV-002560-a" origId="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Protect against file name injection" id="APSC_DV-002560-b" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Protect against SQL injection" id="APSC_DV-002560-c" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Never use unfiltered data from an untrusted user as the format parameter" id="APSC_DV-002560-d" origId="SECURITY-36" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Avoid tainted data in array indexes" id="APSC_DV-002560-e" origId="BD-SECURITY-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002560-f" origId="BD-SECURITY-INTOVERF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-002560-g" origId="BD-SECURITY-LOG" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Protect against command injection" id="APSC_DV-002560-h" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Avoid printing tainted data on the output console" id="APSC_DV-002560-i" origId="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Exclude unsanitized user input from format strings" id="APSC_DV-002560-j" origId="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="APSC_DV-002560" desc="Untrusted data is used as a loop boundary" id="APSC_DV-002560-k" origId="SECURITY-38" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002570" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-002570-a" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="APSC_DV-002570" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="APSC_DV-002570-b" origId="SECURITY-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid buffer overflow due to defining incorrect format limits" id="APSC_DV-002590-a" origId="BD-PB-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid overflow due to reading a not zero terminated string" id="APSC_DV-002590-b" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid overflow when reading from a buffer" id="APSC_DV-002590-c" origId="BD-PB-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid overflow when writing to a buffer" id="APSC_DV-002590-d" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid wraparounds when performing arithmetic integer operations" id="APSC_DV-002590-e" origId="BD-PB-INTWRAP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Prevent buffer overflows from tainted data" id="APSC_DV-002590-f" origId="BD-SECURITY-BUFWRITE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Protect against integer overflow/underflow from tainted data" id="APSC_DV-002590-g" origId="BD-SECURITY-INTOVERF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="APSC_DV-002590-h" origId="BD-SECURITY-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid buffer read overflow from tainted data" id="APSC_DV-002590-i" origId="BD-SECURITY-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Avoid buffer write overflow from tainted data" id="APSC_DV-002590-j" origId="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-002590" desc="Ensure the output buffer is large enough when using path manipulation functions" id="APSC_DV-002590-k" origId="BD-PB-PATHBUF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="APSC_DV-003110" desc="Do not hard code string literals" id="APSC_DV-003110-a" origId="CODSTA-203" sev="1" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-003235" desc="Avoid passing unvalidated binary data to log methods" id="APSC_DV-003235-a" origId="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="APSC_DV-003235" desc="Avoid passing sensitive data to functions that write to log files" id="APSC_DV-003235-b" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_1_1" desc="Avoid unused values" id="AUTOSAR-A0_1_1-a" origId="BD-PB-VOVR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A0_1_2" desc="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="AUTOSAR-A0_1_2-a" origId="CODSTA-CPP-58" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_1_3" desc="Every defined function with internal linkage shall be used at least once" id="AUTOSAR-A0_1_3-a" origId="OPT-30" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_1_4" desc="Eliminate unused parameters" id="AUTOSAR-A0_1_4-a" origId="OPT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_1_5" desc="There shall be no unused named parameters in virtual functions" id="AUTOSAR-A0_1_5-a" origId="OPT-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_1_6" desc="A project shall not contain unused type declarations" id="AUTOSAR-A0_1_6-a" origId="GLOBAL-UNUSEDTYPE" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_4_2" desc="Type long double shall not be used" id="AUTOSAR-A0_4_2-a" origId="PORT-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A0_4_4" desc="Validate values passed to library functions" id="AUTOSAR-A0_4_4-a" origId="BD-API-VALPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_1_1" desc="Be wary about using multiple inheritance of classes that are not abstract interfaces" id="AUTOSAR-A10_1_1-a" origId="OOP-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_2_1" desc="Never redefine an inherited nonvirtual function" id="AUTOSAR-A10_2_1-a" origId="OOP-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_2_1" desc="Member functions declared in derived class should not hide functions declared in base classes" id="AUTOSAR-A10_2_1-b" origId="OOP-53" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_3_1" desc="Only one of virtual, override or final should be specified in a member function declaration" id="AUTOSAR-A10_3_1-a" origId="CODSTA-MCPP-24" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A10_3_2" desc="Each overriding virtual function shall be declared with the override or final specifier" id="AUTOSAR-A10_3_2-a" origId="CODSTA-MCPP-05" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_3_3" desc="Do not introduce virtual functions in a final class" id="AUTOSAR-A10_3_3-a" origId="CODSTA-MCPP-52" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_3_5" desc="A user-defined assignment operator shall not be virtual" id="AUTOSAR-A10_3_5-a" origId="OOP-56" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A10_4_1" desc="Hierarchies should be based on abstract classes" id="AUTOSAR-A10_4_1-a" origId="OOP-40" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A11_0_1" desc="A non-POD type should be defined as class" id="AUTOSAR-A11_0_1-a" origId="OOP-55" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A11_0_2" desc="Structs should only contain public data members and should not be a base or inherit" id="AUTOSAR-A11_0_2-a" origId="OOP-57" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A11_3_1" desc="Friend declarations shall not be used except declarations of comparison operators" id="AUTOSAR-A11_3_1-a" origId="OOP-11_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_0_1" desc="If a class declares a copy or move operation, or a destructor, either via '=default', '=delete', or via a user-provided declaration, then all others of these five special member functions shall be declared as well" id="AUTOSAR-A12_0_1-a" origId="CODSTA-MCPP-56" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_0_2" desc="Do not compare objects of a class that may contain padding bits with C standard library functions" id="AUTOSAR-A12_0_2-a" origId="CODSTA-CPP-100" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_1" desc="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="AUTOSAR-A12_1_1-a" origId="PB-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_1" desc="All member variables should be initialized in constructor" id="AUTOSAR-A12_1_1-b" origId="INIT-06" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_2" desc="Both NSDMI and a non-static member initializer in a constructor shall not be used in the same type" id="AUTOSAR-A12_1_2-a" origId="INIT-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_3" desc="User-defined constructors that initialize data members with the same constant values across all constructors should initialize using NSDMI instead" id="AUTOSAR-A12_1_3-a" origId="INIT-17_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_4" desc="All constructors that are callable with a single argument of fundamental type shall be declared explicit" id="AUTOSAR-A12_1_4-a" origId="OOP-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_5" desc="Use delegating constructors to reduce code duplication" id="AUTOSAR-A12_1_5-a" origId="CODSTA-CPP-106" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_1_6" desc="Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors" id="AUTOSAR-A12_1_6-a" origId="CODSTA-MCPP-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_4_1" desc="Make base class destructors public and virtual, or protected and nonvirtual" id="AUTOSAR-A12_4_1-a" origId="OOP-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_4_2" desc="If a public destructor of a class is non-virtual, then the class should be declared final" id="AUTOSAR-A12_4_2-a" origId="CODSTA-MCPP-23" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_6_1" desc="Prefer initialization to assignment in constructors" id="AUTOSAR-A12_6_1-a" origId="INIT-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_7_1" desc="Define special members as =default when the behavior is equivalent to the compiler's behavior" id="AUTOSAR-A12_7_1-a" origId="CODSTA-CPP-105" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_1" desc="A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member" id="AUTOSAR-A12_8_1-a" origId="OOP-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_2" desc="User-defined copy and move assignment operators should use user-defined no-throw swap function" id="AUTOSAR-A12_8_2-a" origId="CODSTA-MCPP-49" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_3" desc="Do not rely on the value of a moved-from object" id="AUTOSAR-A12_8_3-a" origId="BD-PB-SUBSEQMOVE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_4" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="AUTOSAR-A12_8_4-a" origId="CODSTA-MCPP-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_5" desc="Check for assignment to self in operator=" id="AUTOSAR-A12_8_5-a" origId="OOP-34" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_6" desc="Avoid public copy constructors and assignment operators in base classes" id="AUTOSAR-A12_8_6-a" origId="OOP-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A12_8_7" desc="Declare assignment operators with the ref-qualifier &amp;" id="AUTOSAR-A12_8_7-a" origId="CODSTA-MCPP-19" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_1_2" desc="User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" id="AUTOSAR-A13_1_2-a" origId="NAMING-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_1_3" desc="User defined literals operators shall only perform conversion of passed parameters" id="AUTOSAR-A13_1_3-a" origId="CODSTA-MCPP-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_2_1" desc="Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type" id="AUTOSAR-A13_2_1-a" origId="CODSTA-CPP-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_2_2" desc="A binary arithmetic operator and a bitwise operator shall return a 'prvalue'" id="AUTOSAR-A13_2_2-a" origId="CODSTA-CPP-102" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_2_3" desc="A relational operator shall return a boolean value" id="AUTOSAR-A13_2_3-a" origId="CODSTA-CPP-101" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_3_1" desc="Avoid Overloading on Forwarding References" id="AUTOSAR-A13_3_1-a" origId="CODSTA-MCPP-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_5_1" desc="When overloading the subscript operator (operator[]), implement both const and non-const versions" id="AUTOSAR-A13_5_1-a" origId="HICPP-13_2_4-a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_5_2" desc="User-conversion cast operators should be made explicit" id="AUTOSAR-A13_5_2-a" origId="CODSTA-MCPP-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_5_3" desc="Do not use user-defined conversion functions" id="AUTOSAR-A13_5_3-a" origId="CODSTA-CPP-05" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_5_4" desc="If two opposite equality operators ('==', '!=') are defined in a class, one shall be defined in terms of the other" id="AUTOSAR-A13_5_4-b" origId="CODSTA-CPP-86" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_5_5" desc="Comparison operators shall be non-member functions" id="AUTOSAR-A13_5_5-a" origId="CODSTA-CPP-107" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_5_5" desc="Comparison operators shall be non-member functions with identical parameter types and noexcept" id="AUTOSAR-A13_5_5-b" origId="CODSTA-CPP-107_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A13_6_1" desc="Digit sequences separators ' shall only be used consistently" id="AUTOSAR-A13_6_1-a" origId="CODSTA-MCPP-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A14_5_1" desc="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="AUTOSAR-A14_5_1-a" origId="TEMPL-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A14_5_3" desc="A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations" id="AUTOSAR-A14_5_3-a" origId="TEMPL-18" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A14_7_2" desc="Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared" id="AUTOSAR-A14_7_2-a" origId="TEMPL-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A14_8_2" desc="Overloaded function templates shall not be explicitly specialized" id="AUTOSAR-A14_8_2-a" origId="TEMPL-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_0_2" desc="Ensure resources are freed" id="AUTOSAR-A15_0_2-a" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_1_1" desc="Only use instances of std::exception for exceptions" id="AUTOSAR-A15_1_1-a" origId="HICPP-15_1_1-a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_1_2" desc="An exception object should not have pointer type" id="AUTOSAR-A15_1_2-a" origId="EXCEPT-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_1_4" desc="Ensure resources are freed" id="AUTOSAR-A15_1_4-a" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A15_1_5" desc="Do not throw an exception across execution boundaries" id="AUTOSAR-A15_1_5-a" origId="PORT-30" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_2_1" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="AUTOSAR-A15_2_1-a" origId="EXCEPT-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_2_1" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-A15_2_1-b" origId="EXCEPT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_3_2" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-A15_3_2-a" origId="EXCEPT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-A15_3_3" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="AUTOSAR-A15_3_3-a" origId="EXCEPT-06" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-A15_3_4" desc="Avoid using catch-all exception handlers" id="AUTOSAR-A15_3_4-a" origId="EXCEPT-26" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-A15_3_5" desc="A class type exception shall always be caught by reference" id="AUTOSAR-A15_3_5-a" origId="EXCEPT-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_4_1" desc="Do not use throw exception specifications" id="AUTOSAR-A15_4_1-a" origId="EXCEPT-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_4_2" desc="Avoid throwing exceptions from functions that are declared not to throw" id="AUTOSAR-A15_4_2-a" origId="BD-PB-NOEXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_4_3" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="AUTOSAR-A15_4_3-a" origId="GLOBAL-EXCSPECDECL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_4_4" desc="Declare functions 'noexcept' if they will not emit exceptions" id="AUTOSAR-A15_4_4-a" origId="CODSTA-MCPP-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_4_5" desc="Checked exceptions that could be thrown from a function shall be specified in the comment directly before the function declaration" id="AUTOSAR-A15_4_5-a" origId="EXCEPT-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_1" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="AUTOSAR-A15_5_1-a" origId="EXCEPT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_1" desc="All user-provided move constructors and move assignment operators shall not exit with an exception" id="AUTOSAR-A15_5_1-b" origId="EXCEPT-21" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_2" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="AUTOSAR-A15_5_2-a" origId="PB-44" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_2" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-A15_5_2-b" origId="PB-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_2" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-A15_5_2-c" origId="PB-75_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="AUTOSAR-A15_5_3-a" origId="PB-44" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="AUTOSAR-A15_5_3-b" origId="EXCEPT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Do not throw from within destructor" id="AUTOSAR-A15_5_3-c" origId="EXCEPT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="AUTOSAR-A15_5_3-d" origId="EXCEPT-06" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="AUTOSAR-A15_5_3-e" origId="EXCEPT-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Exceptions shall be raised only after start-up and before termination of the program" id="AUTOSAR-A15_5_3-f" origId="EXCEPT-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-A15_5_3-g" origId="EXCEPT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="AUTOSAR-A15_5_3-h" origId="EXCEPT-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="AUTOSAR-A15_5_3-i" origId="EXCEPT-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Always catch exceptions" id="AUTOSAR-A15_5_3-j" origId="BD-PB-EXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A15_5_3" desc="Properly define exit handlers" id="AUTOSAR-A15_5_3-k" origId="BD-PB-EXITHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A16_0_1" desc="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" id="AUTOSAR-A16_0_1-a" origId="PREPROC-26" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_0_1" desc="#error directive shall not be used" id="AUTOSAR-A16_0_1-b" origId="PREPROC-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_0_1" desc="The #pragma directive shall not be used" id="AUTOSAR-A16_0_1-c" origId="PREPROC-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-A16_0_1" desc="Avoid using macro definitions" id="AUTOSAR-A16_0_1-d" origId="PREPROC-01" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_0_1" desc="#undef shall not be used" id="AUTOSAR-A16_0_1-e" origId="PREPROC-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_2_1" desc="The following character sequences shall not appear in header file names: ', \, /*, //, or &quot;" id="AUTOSAR-A16_2_1-a" origId="PB-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_2_2" desc="A file should directly include only the headers that contain declarations and definitions required to compile that file" id="AUTOSAR-A16_2_2-a" origId="OPT-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_6_1" desc="#error directive shall not be used" id="AUTOSAR-A16_6_1-a" origId="PREPROC-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A16_7_1" desc="The #pragma directive shall not be used" id="AUTOSAR-A16_7_1-a" origId="PREPROC-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_0_1" desc="Do not #define nor #undef identifier 'defined'" id="AUTOSAR-A17_0_1-a" origId="MISRA2004-20_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_0_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="AUTOSAR-A17_0_1-b" origId="CODSTA-92_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_0_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="AUTOSAR-A17_0_1-c" origId="CODSTA-92_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_0_1" desc="Do not redefine reserved words" id="AUTOSAR-A17_0_1-d" origId="MISRA2004-20_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_0_1" desc="Do not #define or #undef identifiers with names which start with underscore" id="AUTOSAR-A17_0_1-e" origId="MISRA2004-20_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_1_1" desc="The error indicator 'errno' shall not be used" id="AUTOSAR-A17_1_1-a" origId="MISRA2004-20_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A17_6_1" desc="Do not modify the standard namespaces 'std' and 'posix'" id="AUTOSAR-A17_6_1-a" origId="CODSTA-CPP-95" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-A18_0_1" desc="The C library shall not be used" id="AUTOSAR-A18_0_1-a" origId="CODSTA-CPP-59" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A18_0_2" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="AUTOSAR-A18_0_2-a" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A18_0_2" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="AUTOSAR-A18_0_2-b" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_0_3" desc="Do not include &lt;locale.h> header" id="AUTOSAR-A18_0_3-a" origId="MISRA-121_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_0_3" desc="The 'setlocale' function should not be used" id="AUTOSAR-A18_0_3-b" origId="MISRA-121_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_1_1" desc="C-style arrays shall not be used" id="AUTOSAR-A18_1_1-a" origId="STL-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_1_2" desc="Avoid using vector&lt;bool>" id="AUTOSAR-A18_1_2-a" origId="STL-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_1_3" desc="Prefer to use std::unique_ptr instead of std::auto_ptr" id="AUTOSAR-A18_1_3-a" origId="CODSTA-MCPP-16_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_1_4" desc="A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" id="AUTOSAR-A18_1_4-a" origId="BD-PB-ARRPTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_1_6" desc="All std::hash specializations for user-defined types shall have a noexcept function call operator" id="AUTOSAR-A18_1_6-a" origId="CODSTA-MCPP-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_1" desc="Do not use calloc, malloc, realloc and free functions" id="AUTOSAR-A18_5_1-a" origId="MRM-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_10" desc="Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'" id="AUTOSAR-A18_5_10-a" origId="MRM-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_10" desc="An overhead should be used when an array of objects is passed to the placement 'new' allocation function" id="AUTOSAR-A18_5_10-b" origId="MRM-55_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_11" desc="Write operator delete if you write operator new" id="AUTOSAR-A18_5_11-a" origId="MRM-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_11" desc="Write operator delete[] if you write operator new[]" id="AUTOSAR-A18_5_11-b" origId="MRM-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_2" desc="Dynamic heap memory allocation shall not be used" id="AUTOSAR-A18_5_2-a" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_3" desc="Never provide brackets ([]) for delete when deallocating non-arrays" id="AUTOSAR-A18_5_3-a" origId="MRM-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_3" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="AUTOSAR-A18_5_3-b" origId="MRM-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_3" desc="Properly deallocate dynamically allocated resources" id="AUTOSAR-A18_5_3-c" origId="BD-RES-BADDEALLOC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_4" desc="Define both sized and unsized versions of operator delete" id="AUTOSAR-A18_5_4-a" origId="CODSTA-MCPP-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_5" desc="Use the same form in corresponding calls to new/malloc and delete/free" id="AUTOSAR-A18_5_5-a" origId="MRM-06" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_5" desc="Freed memory shouldn't be accessed under any circumstances" id="AUTOSAR-A18_5_5-b" origId="MRM-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_5" desc="Properly define new handlers" id="AUTOSAR-A18_5_5-c" origId="BD-PB-NEWHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_8" desc="Use allocation by declaration rather than by new or malloc" id="AUTOSAR-A18_5_8-a" origId="MRM-30" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_5_9" desc="The user defined 'new' operator should throw the 'std::bad_alloc' exception when the allocation fails" id="AUTOSAR-A18_5_9-a" origId="MRM-53" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_9_1" desc="Prefer lambdas over std::bind, std::bind1st and std::bind2nd" id="AUTOSAR-A18_9_1-a" origId="CODSTA-MCPP-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_9_2" desc="The 'std::forward' function should be used to forward forwarding references" id="AUTOSAR-A18_9_2-a" origId="CODSTA-MCPP-13_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_9_3" desc="Do not use std::move on objects declared with the const or const &amp; type" id="AUTOSAR-A18_9_3-a" origId="CODSTA-MCPP-53" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A18_9_4" desc="Do not subsequently use the argument to std::forward" id="AUTOSAR-A18_9_4-a" origId="BD-PB-SUBSEQFRWD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="The 'register' storage class specifier shall not be used" id="AUTOSAR-A1_1_1-a" origId="MISRA-028" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="A copy assignment operator should be declared when a copy constructor is declared (and vice versa)" id="AUTOSAR-A1_1_1-b" origId="MRM-40_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor" id="AUTOSAR-A1_1_1-c" origId="MRM-40_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="The C library shall not be used" id="AUTOSAR-A1_1_1-d" origId="CODSTA-CPP-59" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="Prefer lambdas over std::bind, std::bind1st and std::bind2nd" id="AUTOSAR-A1_1_1-e" origId="CODSTA-MCPP-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="The 'binder1st' and 'binder2nd' identifiers should not be used" id="AUTOSAR-A1_1_1-f" origId="CODSTA-MCPP-07_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="Prefer to use std::unique_ptr instead of std::auto_ptr" id="AUTOSAR-A1_1_1-g" origId="CODSTA-MCPP-16_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="The 'random_shuffle' identifier should not be used" id="AUTOSAR-A1_1_1-h" origId="CODSTA-MCPP-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="Do not use the increment operator (++) on an operand of type 'bool'" id="AUTOSAR-A1_1_1-i" origId="CODSTA-MCPP-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="The 'set_unexpected' identifier should not be used" id="AUTOSAR-A1_1_1-j" origId="CODSTA-MCPP-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A1_1_1" desc="Do not use throw exception specifications" id="AUTOSAR-A1_1_1-k" origId="EXCEPT-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_1" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="AUTOSAR-A20_8_1-a" origId="BD-PB-PTRVALUE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_2" desc="Use smart pointers when passing a pointer to an object in a thread" id="AUTOSAR-A20_8_2-a" origId="CODSTA-MCPP-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_3" desc="Use smart pointers when passing a pointer to an object in a thread" id="AUTOSAR-A20_8_3-a" origId="CODSTA-MCPP-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_4" desc="Consider using 'std::unique_ptr' instead of 'std::shared_ptr' for local objects" id="AUTOSAR-A20_8_4-a" origId="CODSTA-MCPP-30" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_5" desc="'std::make_unique' shall be used to construct objects owned by 'std::unique_ptr'" id="AUTOSAR-A20_8_5-a" origId="CODSTA-MCPP-16_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_6" desc="Prefer 'std::make_shared' to the direct use of new" id="AUTOSAR-A20_8_6-a" origId="CODSTA-MCPP-16_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A20_8_7" desc="Avoid cyclic shared_ptr references" id="AUTOSAR-A20_8_7-a" origId="BD-RES-CSP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A21_8_1" desc="Do not pass incorrect values to ctype.h library functions" id="AUTOSAR-A21_8_1-a" origId="BD-API-CTYPE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A23_0_1" desc="Use const container calls when the result is immediately converted to a const iterator" id="AUTOSAR-A23_0_1-a" origId="CODSTA-MCPP-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A23_0_2" desc="Do not modify container while iterating over it" id="AUTOSAR-A23_0_2-a" origId="BD-CO-ITMOD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A23_0_2" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="AUTOSAR-A23_0_2-b" origId="BD-CO-STRMOD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A25_1_1" desc="Make predicates const pure functions" id="AUTOSAR-A25_1_1-a" origId="STL-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A25_4_1" desc="For associative containers never use comparison function returning true for equal values" id="AUTOSAR-A25_4_1-a" origId="STL-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A26_5_1" desc="Do not use the rand() function for generating pseudorandom numbers" id="AUTOSAR-A26_5_1-a" origId="SECURITY-02_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A26_5_2" desc="Properly seed pseudorandom number generators" id="AUTOSAR-A26_5_2-a" origId="BD-SECURITY-RAND" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Avoid calling functions printf/wprintf with only one argument other than string constant" id="AUTOSAR-A27_0_1-a" origId="SECURITY-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Avoid tainted data in array indexes" id="AUTOSAR-A27_0_1-b" origId="BD-SECURITY-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Prevent buffer overflows from tainted data" id="AUTOSAR-A27_0_1-c" origId="BD-SECURITY-BUFWRITE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="AUTOSAR-A27_0_1-d" origId="BD-SECURITY-OVERFFMT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Avoid buffer read overflow from tainted data" id="AUTOSAR-A27_0_1-e" origId="BD-SECURITY-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Avoid buffer write overflow from tainted data" id="AUTOSAR-A27_0_1-f" origId="BD-SECURITY-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Protect against command injection" id="AUTOSAR-A27_0_1-g" origId="BD-SECURITY-TDCMD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_1" desc="Exclude unsanitized user input from format strings" id="AUTOSAR-A27_0_1-h" origId="BD-SECURITY-TDINPUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_2" desc="Avoid overflow due to reading a not zero terminated string" id="AUTOSAR-A27_0_2-a" origId="BD-PB-OVERFNZT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_2" desc="Avoid overflow when writing to a buffer" id="AUTOSAR-A27_0_2-b" origId="BD-PB-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_2" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="AUTOSAR-A27_0_2-c" origId="SECURITY-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_2" desc="Prevent buffer overflows from tainted data" id="AUTOSAR-A27_0_2-e" origId="BD-SECURITY-BUFWRITE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_2" desc="Avoid buffer write overflow from tainted data" id="AUTOSAR-A27_0_2-f" origId="BD-SECURITY-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_3" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="AUTOSAR-A27_0_3-a" origId="BD-PB-STREAMINOUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_4" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="AUTOSAR-A27_0_4-a" origId="SECURITY-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_4" desc="Avoid using unsafe string functions that do not check bounds" id="AUTOSAR-A27_0_4-b" origId="SECURITY-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A27_0_4" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="AUTOSAR-A27_0_4-c" origId="SECURITY-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="AUTOSAR-A27_0_4" desc="C-style strings shall not be used" id="AUTOSAR-A27_0_4-d" origId="PB-76" sev="2" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_1" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="AUTOSAR-A2_10_1-a" origId="MISRA2004-5_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_1" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="AUTOSAR-A2_10_1-b" origId="MISRA2004-5_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_1" desc="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="AUTOSAR-A2_10_1-c" origId="CODSTA-CPP-83" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_1" desc="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="AUTOSAR-A2_10_1-d" origId="CODSTA-CPP-84" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_1" desc="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="AUTOSAR-A2_10_1-e" origId="CODSTA-CPP-85" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_4" desc="The identifier name of a non-member object with static storage duration shall not be reused within a namespace" id="AUTOSAR-A2_10_4-a" origId="GLOBAL-REUSEDQUALGLOBVAR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_4" desc="The identifier name of a non-member static function shall not be reused within a namespace" id="AUTOSAR-A2_10_4-b" origId="GLOBAL-REUSEDQUALSTATFUN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_5" desc="Identifiers that define objects with external linkage shall be unique" id="AUTOSAR-A2_10_5-a" origId="GLOBAL-REUSEDEXTVAR" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="AUTOSAR-A2_10_5" desc="Identifiers that define functions with external linkage shall be unique" id="AUTOSAR-A2_10_5-b" origId="GLOBAL-REUSEDEXTFUN" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_6" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="AUTOSAR-A2_10_6-a" origId="CODSTA-CPP-87_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_6" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="AUTOSAR-A2_10_6-b" origId="CODSTA-CPP-87_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_10_6" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="AUTOSAR-A2_10_6-c" origId="CODSTA-CPP-87_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_11_1" desc="Do not use the volatile keyword" id="AUTOSAR-A2_11_1-a" origId="MISRA-046_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_13_1" desc="Only those escape sequences that are defined in ISO/IEC 14882:2014 shall be used" id="AUTOSAR-A2_13_1-a" origId="CODSTA-CPP-60_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_13_2" desc="String literals with different encoding prefixes shall not be concatenated" id="AUTOSAR-A2_13_2-a" origId="PB-38_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_13_3" desc="Type wchar_t shall not be used" id="AUTOSAR-A2_13_3-a" origId="PORT-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_13_4" desc="A string literal shall not be modified" id="AUTOSAR-A2_13_4-a" origId="PB-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_13_5" desc="Hexadecimal constants will be represented using all uppercase letters" id="AUTOSAR-A2_13_5-a" origId="CODSTA-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_13_6" desc="Universal character names shall be used only inside character or string literals" id="AUTOSAR-A2_13_6-a" origId="NAMING-52" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-A2_3_1" desc="Only use characters defined in the ISO C standard" id="AUTOSAR-A2_3_1-a" origId="MISRA-005" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_5_1" desc="Trigraphs shall not be used" id="AUTOSAR-A2_5_1-a" origId="MISRA2004-4_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_5_1" desc="Trigraphs shall not be used" id="AUTOSAR-A2_5_1-b" origId="MISRA2004-4_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_5_2" desc="Do not use the following digraphs: &lt;%, %>, &lt;:, :>, %:, %:%:" id="AUTOSAR-A2_5_2-a" origId="CODSTA-48" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_7_1" desc="Line-splicing shall not be used in // comments" id="AUTOSAR-A2_7_1-a" origId="COMMENT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_7_2" desc="Sections of code should not be &quot;commented out&quot;" id="AUTOSAR-A2_7_2-a" origId="MISRA2004-2_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="1;" cat="AUTOSAR-A2_7_3" desc="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" id="AUTOSAR-A2_7_3-a" origId="COMMENT-14" sev="2" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="14;" authUrg="1;" cat="AUTOSAR-A2_7_3" desc="Function parameters and return type should be documented in a comment that precedes the function declaration" id="AUTOSAR-A2_7_3-b" origId="COMMENT-14_b" sev="2" total="14"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A2_8_1" desc="An include file for a class should have a file name of the form &lt;class name> + extension" id="AUTOSAR-A2_8_1-a" origId="NAMING-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_1_1" desc="Don't define entities with linkage in a header file" id="AUTOSAR-A3_1_1-a" origId="PFO-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="0;" cat="AUTOSAR-A3_1_2" desc="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" id="AUTOSAR-A3_1_2-a" origId="NAMING-53" sev="2" total="12"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-A3_1_3" desc="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" id="AUTOSAR-A3_1_3-a" origId="NAMING-49" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_1_4" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="AUTOSAR-A3_1_4-a" origId="MISRA2004-8_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_1_5" desc="A function definition should not be placed in a class specification unless the function is intended to be inlined" id="AUTOSAR-A3_1_5-a" origId="CODSTA-CPP-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_1_6" desc="Trivial accessor and mutator functions should be inlined" id="AUTOSAR-A3_1_6-a" origId="OPT-23" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_3_1" desc="Objects or functions with external linkage shall be declared in a header file" id="AUTOSAR-A3_3_1-a" origId="MISRA-023" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_3_1" desc="Don't define entities with linkage in a header file" id="AUTOSAR-A3_3_1-b" origId="PFO-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_3_2" desc="Static and thread-local objects shall be constant-initialized" id="AUTOSAR-A3_3_2-a" origId="CODSTA-MCPP-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_8_1" desc="Do not use resources that have been freed" id="AUTOSAR-A3_8_1-a" origId="BD-RES-FREE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_8_1" desc="The address of an object with automatic storage shall not be returned from a function" id="AUTOSAR-A3_8_1-b" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_8_1" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="AUTOSAR-A3_8_1-c" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A3_8_1" desc="Do not point to a wrapped object that has been freed" id="AUTOSAR-A3_8_1-d" origId="BD-PB-WRAPESC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-A3_9_1" desc="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" id="AUTOSAR-A3_9_1-b" origId="CODSTA-223" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_10_1" desc="NULL shall not be used as an integer value" id="AUTOSAR-A4_10_1-a" origId="CODSTA-CPP-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_10_1" desc="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="AUTOSAR-A4_10_1-b" origId="CODSTA-MCPP-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_5_1" desc="Expressions with type enum shall not be used as operands to built-in operators other than  [ ],  =, ==, !=, &lt;, &lt;=, >, >=, and the unary &amp; operator" id="AUTOSAR-A4_5_1-a" origId="CODSTA-70" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Avoid implicit conversions from signed to unsigned type" id="AUTOSAR-A4_7_1-a" origId="PB-56" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="AUTOSAR-A4_7_1-b" origId="MISRA-043_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Avoid conversions of constant values to a narrower type" id="AUTOSAR-A4_7_1-c" origId="PORT-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="AUTOSAR-A4_7_1-d" origId="MISRA-043" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Avoid implicit conversions from wider to narrower floating type" id="AUTOSAR-A4_7_1-e" origId="MISRA2004-10_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Avoid implicit conversions from floating to integral type" id="AUTOSAR-A4_7_1-f" origId="MISRA2004-10_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="AUTOSAR-A4_7_1-g" origId="MISRA-043_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A4_7_1" desc="Avoid wraparounds when performing arithmetic integer operations" id="AUTOSAR-A4_7_1-h" origId="BD-PB-INTWRAP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of function calls" id="AUTOSAR-A5_0_1-a" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="Do not use more than one volatile between two adjacent sequence points" id="AUTOSAR-A5_0_1-b" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="AUTOSAR-A5_0_1-c" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="AUTOSAR-A5_0_1-d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="AUTOSAR-A5_0_1-e" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="Don't write code that depends on the order of evaluation of function arguments" id="AUTOSAR-A5_0_1-f" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_1" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="AUTOSAR-A5_0_1-g" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_2" desc="The condition of an if-statement and the condition of an iteration-statement shall have type bool" id="AUTOSAR-A5_0_2-a" origId="CODSTA-CPP-64" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_3" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="AUTOSAR-A5_0_3-a" origId="MISRA2004-17_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_4" desc="Don't treat arrays polymorphically" id="AUTOSAR-A5_0_4-a" origId="PB-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_4" desc="A pointer to an array of derived class objects should not be converted to a base class pointer" id="AUTOSAR-A5_0_4-b" origId="PB-57" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_0_4" desc="Do not treat arrays polymorphically" id="AUTOSAR-A5_0_4-c" origId="BD-PB-POLARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_10_1" desc="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="AUTOSAR-A5_10_1-a" origId="CODSTA-MCPP-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_16_1" desc="The conditional operator should not be used as a sub-expression" id="AUTOSAR-A5_16_1-a" origId="CODSTA-224" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-A5_1_1" desc="Avoid magic numbers" id="AUTOSAR-A5_1_1-a" origId="CODSTA-26" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_2" desc="Avoid default capture modes" id="AUTOSAR-A5_1_2-a" origId="CODSTA-MCPP-15_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_3" desc="Include a parameter list in every lambda expression" id="AUTOSAR-A5_1_3-a" origId="CODSTA-MCPP-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_4" desc="Never return lambdas that capture local objects by reference" id="AUTOSAR-A5_1_4-a" origId="CODSTA-MCPP-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_4" desc="Never capture local objects from an outer lambda by reference" id="AUTOSAR-A5_1_4-b" origId="CODSTA-MCPP-17_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_4" desc="The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime" id="AUTOSAR-A5_1_4-c" origId="CODSTA-MCPP-17_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_6" desc="Return type of a non-void return type lambda expression should be explicitly specified" id="AUTOSAR-A5_1_6-a" origId="CODSTA-MCPP-45" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_7" desc="A lambda shall not be an operand to typeid" id="AUTOSAR-A5_1_7-a" origId="CODSTA-MCPP-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_1_8" desc="Lambda expressions should not be defined inside another lambda expression" id="AUTOSAR-A5_1_8-a" origId="CODSTA-MCPP-44" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_1" desc="Avoid dynamic_casts" id="AUTOSAR-A5_2_1-a" origId="CODSTA-CPP-35" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_2" desc="C-style casts should not be used" id="AUTOSAR-A5_2_2-a" origId="CODSTA-CPP-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_3" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="AUTOSAR-A5_2_3-a" origId="MISRA2004-11_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_4" desc="Avoid using reinterpret_cast" id="AUTOSAR-A5_2_4-a" origId="CODSTA-CPP-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_5" desc="Avoid accessing arrays out of bounds" id="AUTOSAR-A5_2_5-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_5" desc="Avoid accessing arrays and pointers out of bounds" id="AUTOSAR-A5_2_5-b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_5" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="AUTOSAR-A5_2_5-c" origId="BD-PB-PTRARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_5" desc="Avoid tainted data in array indexes" id="AUTOSAR-A5_2_5-d" origId="BD-SECURITY-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_2_6" desc="The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" id="AUTOSAR-A5_2_6-a" origId="CODSTA-104" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_3_1" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="AUTOSAR-A5_3_1-a" origId="CODSTA-CPP-104" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_3_1" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="AUTOSAR-A5_3_1-b" origId="CODSTA-CPP-104_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_3_2" desc="Avoid null pointer dereferencing" id="AUTOSAR-A5_3_2-a" origId="BD-PB-NP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_3_3" desc="Do not delete objects with incomplete class at the point of deletion" id="AUTOSAR-A5_3_3-a" origId="PB-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_5_1" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="AUTOSAR-A5_5_1-a" origId="CODSTA-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A5_6_1" desc="Avoid division by zero" id="AUTOSAR-A5_6_1-a" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_2_1" desc="Copy assignment operators should not have side effects that could affect copying the object" id="AUTOSAR-A6_2_1-a" origId="MRM-56" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_2_1" desc="Move assignment operators should not have side effects that could affect moving the object" id="AUTOSAR-A6_2_1-b" origId="MRM-57" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_2_2" desc="Expression statements shall not be explicit calls to constructors of temporary objects only" id="AUTOSAR-A6_2_2-a" origId="PB-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_4_1" desc="Every switch statement will have at least two cases and a potential default" id="AUTOSAR-A6_4_1-a" origId="CODSTA-54" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_5_1" desc="A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" id="AUTOSAR-A6_5_1-a" origId="CODSTA-MCPP-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_5_2" desc="A for loop shall contain a single loop-counter which shall not have floating type" id="AUTOSAR-A6_5_2-a" origId="CODSTA-CPP-69" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_5_3" desc="'Do' statements should not be used except in a function-like macro" id="AUTOSAR-A6_5_3-a" origId="CODSTA-18_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_5_4" desc="The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter" id="AUTOSAR-A6_5_4-a" origId="CODSTA-52" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_5_4" desc="The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop" id="AUTOSAR-A6_5_4-b" origId="CODSTA-53" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A6_6_1" desc="The goto statement shall not be used" id="AUTOSAR-A6_6_1-a" origId="MISRA2004-14_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="1;" cat="AUTOSAR-A7_1_1" desc="Declare local variable as const whenever possible" id="AUTOSAR-A7_1_1-a" origId="CODSTA-CPP-53" sev="2" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-A7_1_2" desc="Use constexpr to declare const variables whenever possible" id="AUTOSAR-A7_1_2-a" origId="CODSTA-MCPP-11_a_cpp11" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_2" desc="Use constexpr to declare functions whenever possible" id="AUTOSAR-A7_1_2-b" origId="CODSTA-MCPP-11_b_cpp11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_3" desc="CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name" id="AUTOSAR-A7_1_3-a" origId="FORMAT-47_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_4" desc="The 'register' storage class specifier shall not be used" id="AUTOSAR-A7_1_4-a" origId="MISRA-028" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_5" desc="Do not overuse 'auto' specifier" id="AUTOSAR-A7_1_5-a" origId="CODSTA-MCPP-40" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_6" desc="Prefer alias declarations to typedefs" id="AUTOSAR-A7_1_6-a" origId="CODSTA-MCPP-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_7" desc="Only one statement shall be allowed per line" id="AUTOSAR-A7_1_7-a" origId="FORMAT-06" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_7" desc="Multiple variable declarations shall not be allowed on the same line" id="AUTOSAR-A7_1_7-b" origId="FORMAT-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_7" desc="Each variable should be declared in a separate declaration statement" id="AUTOSAR-A7_1_7-c" origId="FORMAT-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_8" desc="Do not place type specifiers before non-type specifiers in a declaration" id="AUTOSAR-A7_1_8-a" origId="HICPP-7_1_3-a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_1_9" desc="A class, structure, or enumeration will not be declared in the definition of its type" id="AUTOSAR-A7_1_9-a" origId="CODSTA-CPP-56" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_2_1" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="AUTOSAR-A7_2_1-a" origId="PB-70" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_2_2" desc="Use an explicit enumeration base and ensure that it is large enough to store all enumerators" id="AUTOSAR-A7_2_2-a" origId="HICPP-7_2_1-a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_2_3" desc="Prefer Scoped Enums to Unscoped Enums" id="AUTOSAR-A7_2_3-a" origId="CODSTA-MCPP-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_2_4" desc="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="AUTOSAR-A7_2_4-a" origId="MISRA2004-9_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_2_5" desc="Enumeration types shall be used instead of integer types (and constants) as case labels" id="AUTOSAR-A7_2_5-a" origId="CODSTA-55" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_3_1" desc="Member functions declared in derived class should not hide functions declared in base classes" id="AUTOSAR-A7_3_1-a" origId="OOP-53" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_4_1" desc="The 'asm' declaration should not be used" id="AUTOSAR-A7_4_1-a" origId="CODSTA-234" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_5_1" desc="A function shall not return a pointer or a reference to a parameter that is passed by const reference" id="AUTOSAR-A7_5_1-a" origId="PB-39_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_5_2" desc="Functions shall not call themselves, either directly or indirectly" id="AUTOSAR-A7_5_2-a" origId="MISRA2004-16_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A7_6_1" desc="Never return from functions that should not return" id="AUTOSAR-A7_6_1-a" origId="BD-PB-NORETURN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_2_1" desc="Use a trailing return type syntax if the return type is preceded by the 'typename' keyword" id="AUTOSAR-A8_2_1-a" origId="TEMPL-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_1" desc="Do not use functions with variable numbers of arguments" id="AUTOSAR-A8_4_1-a" origId="MISRA-069" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_10" desc="A parameter shall be passed by reference if it can't be NULL" id="AUTOSAR-A8_4_10-a" origId="BD-PB-REFPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_11" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="AUTOSAR-A8_4_11-a" origId="CODSTA-MCPP-34" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_12" desc="Do not pass std::unique_ptr by const reference" id="AUTOSAR-A8_4_12-a" origId="HICPP-8_2_4-a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_12" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="AUTOSAR-A8_4_12-b" origId="CODSTA-MCPP-34" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_12" desc="A parameter should only be declared as a non-const lvalue reference to 'std::shared_ptr' or 'std::unique_ptr' if the function replaces the managed object" id="AUTOSAR-A8_4_12-c" origId="CODSTA-MCPP-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_12" desc="Do not declare the type of a parameter as an rvalue reference to 'std::shared_ptr' or 'std::unique_ptr'" id="AUTOSAR-A8_4_12-d" origId="CODSTA-MCPP-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_13" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="AUTOSAR-A8_4_13-a" origId="CODSTA-MCPP-34" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_13" desc="A parameter should only be declared as a non-const lvalue reference to 'std::shared_ptr' or 'std::unique_ptr' if the function replaces the managed object" id="AUTOSAR-A8_4_13-b" origId="CODSTA-MCPP-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_13" desc="Do not declare the type of a parameter as an rvalue reference to 'std::shared_ptr' or 'std::unique_ptr'" id="AUTOSAR-A8_4_13-c" origId="CODSTA-MCPP-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_2" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="AUTOSAR-A8_4_2-a" origId="MISRA2004-16_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_3" desc="A parameter of a type that is not 'cheap to copy' should be passed by reference" id="AUTOSAR-A8_4_3-a" origId="CODSTA-CPP-109" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_3" desc="Declare reference parameters as const references whenever possible" id="AUTOSAR-A8_4_3-b" origId="CODSTA-CPP-43" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_4" desc="Multiple output values from a function should be returned as a struct or tuple" id="AUTOSAR-A8_4_4-a" origId="CODSTA-MCPP-48" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_5" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="AUTOSAR-A8_4_5-a" origId="CODSTA-MCPP-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_6" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="AUTOSAR-A8_4_6-a" origId="CODSTA-MCPP-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_7" desc="A parameter of const reference to a 'cheap to copy' type should be passed by value" id="AUTOSAR-A8_4_7-a" origId="CODSTA-CPP-108" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_8" desc="Output parameters shall not be used" id="AUTOSAR-A8_4_8-a" origId="CODSTA-CPP-103" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_4_9" desc="Declare reference parameters as const references whenever possible" id="AUTOSAR-A8_4_9-a" origId="CODSTA-CPP-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_5_0" desc="Avoid use before initialization" id="AUTOSAR-A8_5_0-a" origId="BD-PB-NOTINIT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_5_1" desc="List members in an initialization list in the order in which they are declared" id="AUTOSAR-A8_5_1-a" origId="INIT-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="1;" cat="AUTOSAR-A8_5_2" desc="Braced-initialization {}, without equals sign, shall be used for variable initialization" id="AUTOSAR-A8_5_2-a" origId="CODSTA-MCPP-38" sev="2" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_5_3" desc="A variable of type auto shall not be initialized using '{}' or '={}' braced-initialization" id="AUTOSAR-A8_5_3-a" origId="CODSTA-MCPP-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A8_5_4" desc="Avoid overloading constructors with std::initializer_list" id="AUTOSAR-A8_5_4-a" origId="CODSTA-MCPP-47" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A9_3_1" desc="Public member functions shall not return non-const handles to private/protected class-data" id="AUTOSAR-A9_3_1-a" origId="OOP-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A9_3_1" desc="Protected member function shall not return non-const handles to private class-data" id="AUTOSAR-A9_3_1-b" origId="OOP-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A9_5_1" desc="Unions shall not be used" id="AUTOSAR-A9_5_1-a" origId="MISRA2004-18_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A9_5_1" desc="Unions shall not be used" id="AUTOSAR-A9_5_1-b" origId="MISRA2004-18_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A9_6_1" desc="Types of bit-fields should have defined sizes" id="AUTOSAR-A9_6_1-a" origId="CODSTA-233" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-A9_6_2" desc="Do not declare member variables as bit-fields" id="AUTOSAR-A9_6_2-a" origId="CODSTA-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="AUTOSAR-M0_1_1-a" origId="MISRA2004-14_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="AUTOSAR-M0_1_1-b" origId="MISRA2004-14_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="AUTOSAR-M0_1_1-c" origId="MISRA2004-14_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="AUTOSAR-M0_1_1-d" origId="MISRA2004-14_1_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="AUTOSAR-M0_1_1-e" origId="MISRA2004-14_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in 'for' loop" id="AUTOSAR-M0_1_1-f" origId="MISRA2004-14_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_1" desc="There shall be no unreachable code in switch statement" id="AUTOSAR-M0_1_1-g" origId="MISRA2004-14_1_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_10" desc="Every defined function with external linkage shall be used at least once" id="AUTOSAR-M0_1_10-a" origId="GLOBAL-UNUSEDFUNC" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_10" desc="Every defined function with internal linkage shall be used at least once" id="AUTOSAR-M0_1_10-b" origId="OPT-30" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-a" origId="MISRA2004-13_7_ab" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-aa" origId="MISRA2004-13_7_aj" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-ab" origId="MISRA2004-13_7_k" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Avoid conditions that always evaluate to the same value" id="AUTOSAR-M0_1_2-ac" origId="BD-PB-CC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-b" origId="MISRA2004-13_7_v" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-c" origId="MISRA2004-13_7_z" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-d" origId="MISRA2004-13_7_n" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-e" origId="MISRA2004-13_7_s" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-f" origId="MISRA2004-13_7_t" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-g" origId="MISRA2004-13_7_u" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-h" origId="MISRA2004-13_7_j" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-i" origId="MISRA2004-13_7_l" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-j" origId="MISRA2004-13_7_m" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-k" origId="MISRA2004-13_7_w" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-l" origId="MISRA2004-13_7_x" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-m" origId="MISRA2004-13_7_y" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-n" origId="MISRA2004-13_7_ac" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-o" origId="MISRA2004-13_7_ad" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-p" origId="MISRA2004-13_7_ae" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-q" origId="MISRA2004-13_7_af" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-r" origId="MISRA2004-13_7_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-s" origId="MISRA2004-13_7_aa" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-t" origId="MISRA2004-13_7_ak" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-u" origId="MISRA2004-13_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-v" origId="MISRA2004-13_7_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-w" origId="MISRA2004-13_7_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-x" origId="MISRA2004-13_7_ag" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-y" origId="MISRA2004-13_7_ah" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_2" desc="Boolean operations whose results are invariant shall not be permitted" id="AUTOSAR-M0_1_2-z" origId="MISRA2004-13_7_ai" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_3" desc="Avoid unused local variables" id="AUTOSAR-M0_1_3-a" origId="OPT-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_3" desc="Avoid unused private member variables" id="AUTOSAR-M0_1_3-c" origId="OPT-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="5;" authUrg="0;" cat="AUTOSAR-M0_1_4" desc="A project shall not contain non-volatile POD variables having only one use" id="AUTOSAR-M0_1_4-a" origId="GLOBAL-ONEUSEVAR" sev="2" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_8" desc="All non-empty functions with void return type shall have external side effect(s)" id="AUTOSAR-M0_1_8-a" origId="OPT-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-M0_1_8" desc="Functions with void return type shall not be empty" id="AUTOSAR-M0_1_8-b" origId="OPT-32_b" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_1_9" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="AUTOSAR-M0_1_9-a" origId="MISRA2004-14_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_2_1" desc="An object shall not be assigned to an overlapping object" id="AUTOSAR-M0_2_1-a" origId="MISRA2004-18_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_2_1" desc="An object shall not be assigned to an overlapping object" id="AUTOSAR-M0_2_1-b" origId="PB-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Do not subtract two pointers that do not address elements of the same array" id="AUTOSAR-M0_3_1-a" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid overflow when writing to a buffer" id="AUTOSAR-M0_3_1-b" origId="BD-PB-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Do not compare two unrelated pointers" id="AUTOSAR-M0_3_1-c" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid accessing arrays out of bounds" id="AUTOSAR-M0_3_1-d" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid division by zero" id="AUTOSAR-M0_3_1-e" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid null pointer dereferencing" id="AUTOSAR-M0_3_1-f" origId="BD-PB-NP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid overflow due to reading a not zero terminated string" id="AUTOSAR-M0_3_1-g" origId="BD-PB-OVERFNZT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid buffer overflow due to defining incorrect format limits" id="AUTOSAR-M0_3_1-h" origId="BD-PB-OVERFFMT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Avoid overflow when reading from a buffer" id="AUTOSAR-M0_3_1-i" origId="BD-PB-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_3_1" desc="Do not check for null after dereferencing" id="AUTOSAR-M0_3_1-j" origId="BD-PB-DEREF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-M0_3_2" desc="If a function returns error information, then that error information shall be tested" id="AUTOSAR-M0_3_2-a" origId="MISRA2004-16_10" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M0_4_2" desc="Use of floating-point arithmetic shall be documented" id="AUTOSAR-M0_4_2-a" origId="COMMENT-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M10_1_1" desc="Classes should not be derived from virtual bases" id="AUTOSAR-M10_1_1-a" origId="OOP-47" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-M10_1_2" desc="A base class shall only be declared virtual if it is used in a diamond hierarchy" id="AUTOSAR-M10_1_2-a" origId="GLOBAL-VIRTBASECLASS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M10_1_3" desc="A base class shall not be both virtual and non-virtual in the same hierarchy" id="AUTOSAR-M10_1_3-a" origId="OOP-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M10_2_1" desc="All accessible entity names within a multiple inheritance hierarchy should be unique" id="AUTOSAR-M10_2_1-a" origId="CODSTA-CPP-92" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M10_3_3" desc="A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" id="AUTOSAR-M10_3_3-a" origId="OOP-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-M11_0_1" desc="Member data in non-POD types shall be private" id="AUTOSAR-M11_0_1-a" origId="OOP-48" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M12_1_1" desc="Do not use dynamic type of an object under construction" id="AUTOSAR-M12_1_1-a" origId="BD-PB-VCTOR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M14_5_3" desc="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="AUTOSAR-M14_5_3-a" origId="TEMPL-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M14_6_1" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="AUTOSAR-M14_6_1-a" origId="TEMPL-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_0_3" desc="Control shall not be transferred into a try or catch block using a goto or a switch statement" id="AUTOSAR-M15_0_3-a" origId="EXCEPT-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_1_1" desc="The assignment-expression of a throw statement shall not itself cause an exception to be thrown" id="AUTOSAR-M15_1_1-a" origId="EXCEPT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_1_2" desc="NULL shall not be thrown explicitly" id="AUTOSAR-M15_1_2-a" origId="EXCEPT-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_1_3" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="AUTOSAR-M15_1_3-a" origId="EXCEPT-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_3_1" desc="Exceptions shall be raised only after start-up and before termination of the program" id="AUTOSAR-M15_3_1-a" origId="EXCEPT-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_3_3" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="AUTOSAR-M15_3_3-a" origId="EXCEPT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_3_4" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="AUTOSAR-M15_3_4-a" origId="EXCEPT-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_3_4" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="AUTOSAR-M15_3_4-b" origId="EXCEPT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_3_6" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="AUTOSAR-M15_3_6-a" origId="EXCEPT-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M15_3_7" desc="Where multiple handlers are provided in a single 'try-catch' statement or 'function-try-block', any ellipsis (catch-all) handler shall occur last" id="AUTOSAR-M15_3_7-a" origId="EXCEPT-24" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_0_1" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="AUTOSAR-M16_0_1-a" origId="MISRA2004-19_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_0_2" desc="Macros shall not be #define'd or #undef'd within a block" id="AUTOSAR-M16_0_2-a" origId="MISRA2004-19_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_0_5" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="AUTOSAR-M16_0_5-a" origId="MISRA2004-19_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_0_6" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="AUTOSAR-M16_0_6-a" origId="MISRA2004-19_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_0_7" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="AUTOSAR-M16_0_7-a" origId="MISRA2004-19_11_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_0_8" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="AUTOSAR-M16_0_8-a" origId="MISRA2004-19_16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_1_1" desc="The defined preprocessor operator shall only be used in one of the two standard forms" id="AUTOSAR-M16_1_1-a" origId="MISRA2004-19_14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_1_2" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="AUTOSAR-M16_1_2-a" origId="MISRA2004-19_17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_2_3" desc="Use multiple include guards" id="AUTOSAR-M16_2_3-a" origId="PFO-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_3_1" desc="There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition" id="AUTOSAR-M16_3_1-a" origId="MISRA2004-19_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M16_3_2" desc="The # and ## preprocessor operators should not be used" id="AUTOSAR-M16_3_2-a" origId="MISRA2004-19_13" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M17_0_2" desc="The names of standard library macros and objects shall not be reused" id="AUTOSAR-M17_0_2-a" origId="CODSTA-92" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M17_0_3" desc="The names of standard library functions shall not be overridden" id="AUTOSAR-M17_0_3-a" origId="CODSTA-93" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M17_0_5" desc="The facilities provided by &lt;setjmp.h> should not be used" id="AUTOSAR-M17_0_5-a" origId="MISRA2004-20_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_0_3" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-a" origId="PB-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_0_3" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-b" origId="PB-75_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_0_3" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-c" origId="SECURITY-48_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_0_3" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="AUTOSAR-M18_0_3-d" origId="SECURITY-52" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_0_4" desc="The standard header files &lt;time.h> or &lt;ctime> shall not be used" id="AUTOSAR-M18_0_4-a" origId="MISRA2004-20_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_0_5" desc="The unbounded functions of library &lt;cstring> shall not be used" id="AUTOSAR-M18_0_5-a" origId="PB-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_2_1" desc="The macro offsetof, in library stddef.h, shall not be used" id="AUTOSAR-M18_2_1-a" origId="MISRA2004-20_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_7_1" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="AUTOSAR-M18_7_1-a" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M18_7_1" desc="The standard header files &lt;signal.h> or &lt;csignal> shall not be used" id="AUTOSAR-M18_7_1-b" origId="MISRA2004-20_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M19_3_1" desc="The error indicator 'errno' shall not be used" id="AUTOSAR-M19_3_1-a" origId="MISRA2004-20_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-M27_0_1" desc="The input/output library stdio.h shall not be used" id="AUTOSAR-M27_0_1-a" origId="MISRA2004-20_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-M2_10_1" desc="Different identifiers shall be typographically unambiguous" id="AUTOSAR-M2_10_1-a" origId="NAMING-47" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M2_13_2" desc="Octal constants (other than zero) shall not be used" id="AUTOSAR-M2_13_2-a" origId="MISRA2004-7_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M2_13_2" desc="Octal escape sequences shall not be used" id="AUTOSAR-M2_13_2-b" origId="MISRA2004-7_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M2_13_3" desc="A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" id="AUTOSAR-M2_13_3-a" origId="CODSTA-68" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M2_13_4" desc="Literal suffixes shall use uppercase rather than lowercase letters" id="AUTOSAR-M2_13_4-a" origId="CODSTA-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M2_7_1" desc="The character sequence /* shall not be used within a C-style comment" id="AUTOSAR-M2_7_1-a" origId="MISRA2004-2_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_1_2" desc="Always declare functions at file scope" id="AUTOSAR-M3_1_2-a" origId="MISRA2004-8_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_2_1" desc="All declarations of an object or function shall have compatible types" id="AUTOSAR-M3_2_1-a" origId="GLOBAL-COMPATDECLS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_2_2" desc="The One Definition Rule shall not be violated" id="AUTOSAR-M3_2_2-a" origId="GLOBAL-ONEDEFRULE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="AUTOSAR-M3_2_3" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="AUTOSAR-M3_2_3-a" origId="GLOBAL-ONEFILEDECL" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="AUTOSAR-M3_2_4" desc="An identifier with external linkage shall have no more then one external definition" id="AUTOSAR-M3_2_4-a" origId="GLOBAL-ONEEXTERNDEF" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_3_2" desc="If a function has internal linkage then all re-declarations shall include the 'static' storage class specifier" id="AUTOSAR-M3_3_2-a" origId="CODSTA-81" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="AUTOSAR-M3_4_1" desc="Declare variables as locally as possible" id="AUTOSAR-M3_4_1-a" origId="OPT-01" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_4_1" desc="Non-const objects with internal linkage should be defined at function scope if they are only accessed from within a single function" id="AUTOSAR-M3_4_1-b" origId="OPT-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_9_1" desc="The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" id="AUTOSAR-M3_9_1-a" origId="CODSTA-67" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M3_9_3" desc="The underlying bit representations of floating-point values shall not be used" id="AUTOSAR-M3_9_3-a" origId="MISRA2004-12_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M4_10_1" desc="NULL shall not be used as an integer value" id="AUTOSAR-M4_10_1-a" origId="CODSTA-CPP-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M4_10_2" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="AUTOSAR-M4_10_2-a" origId="CODSTA-CPP-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M4_5_1" desc="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="AUTOSAR-M4_5_1-a" origId="MISRA2004-12_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M4_5_3" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="AUTOSAR-M4_5_3-a" origId="CODSTA-69" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_10" desc="If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" id="AUTOSAR-M5_0_10-a" origId="MISRA2004-10_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_11" desc="The plain char type shall be used only for the storage and use of character values" id="AUTOSAR-M5_0_11-a" origId="MISRA2004-6_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_12" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="AUTOSAR-M5_0_12-a" origId="MISRA2004-6_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_14" desc="The first operand of a conditional-operator shall have type bool" id="AUTOSAR-M5_0_14-a" origId="CODSTA-CPP-65" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_15" desc="Array indexing shall be the only allowed form of pointer arithmetic" id="AUTOSAR-M5_0_15-a" origId="MISRA2004-17_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_16" desc="Avoid accessing arrays out of bounds" id="AUTOSAR-M5_0_16-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_16" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="AUTOSAR-M5_0_16-b" origId="BD-PB-PTRARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_17" desc="Do not subtract two pointers that do not address elements of the same array" id="AUTOSAR-M5_0_17-a" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_18" desc="Do not compare two unrelated pointers" id="AUTOSAR-M5_0_18-a" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_2" desc="Use parenthesis for the right-hand operand of an assignment operator when it contains an assignment expression" id="AUTOSAR-M5_0_2-a" origId="MISRA2004-12_1_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_2" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="AUTOSAR-M5_0_2-b" origId="MISRA2004-12_1_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_2" desc="No parentheses are required for the operand of a unary operator" id="AUTOSAR-M5_0_2-c" origId="MISRA2004-12_1_c" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_2" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="AUTOSAR-M5_0_2-d" origId="MISRA2004-12_1_d" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_2" desc="Use parentheses unless all operators in the expression are the same" id="AUTOSAR-M5_0_2-e" origId="MISRA2004-12_1_e" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_2" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="AUTOSAR-M5_0_2-f" origId="MISRA2004-12_1_f" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_20" desc="Non-constant operands to a binary bitwise operator shall have the same underlying type" id="AUTOSAR-M5_0_20-a" origId="CODSTA-66" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_21" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="AUTOSAR-M5_0_21-a" origId="CODSTA-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_3" desc="Avoid implicit conversions of complex expressions" id="AUTOSAR-M5_0_3-a" origId="MISRA2004-10_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_3" desc="Avoid implicit conversions of complex expressions" id="AUTOSAR-M5_0_3-b" origId="MISRA2004-10_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_3" desc="Avoid implicit conversions of complex expressions" id="AUTOSAR-M5_0_3-c" origId="MISRA2004-10_1_i" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="AUTOSAR-M5_0_4" desc="Avoid implicit conversions between signed and unsigned integer types" id="AUTOSAR-M5_0_4-a" origId="MISRA2004-10_1_a" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_5" desc="There shall be no implicit conversions from integral to floating type" id="AUTOSAR-M5_0_5-a" origId="MISRA2004-10_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_5" desc="Avoid implicit conversions from floating to integral type" id="AUTOSAR-M5_0_5-b" origId="MISRA2004-10_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_6" desc="Avoid implicit integral conversions from a wider to a narrower type" id="AUTOSAR-M5_0_6-a" origId="CODSTA-222" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_6" desc="Avoid implicit conversions from wider to narrower floating type" id="AUTOSAR-M5_0_6-b" origId="MISRA2004-10_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_6" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="AUTOSAR-M5_0_6-c" origId="MISRA2004-10_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_7" desc="The value of a complex expression of floating type should not be cast to an integer type" id="AUTOSAR-M5_0_7-a" origId="CODSTA-198_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_7" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="AUTOSAR-M5_0_7-b" origId="MISRA2004-10_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_8" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="AUTOSAR-M5_0_8-a" origId="MISRA2004-10_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_8" desc="The value of a complex expression of floating type should not be cast to a wider floating type" id="AUTOSAR-M5_0_8-b" origId="CODSTA-198" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_0_9" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="AUTOSAR-M5_0_9-a" origId="MISRA2004-10_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_14_1" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="AUTOSAR-M5_14_1-a" origId="MISRA2004-12_4_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_17_1" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="AUTOSAR-M5_17_1-a" origId="CODSTA-CPP-91" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_18_1" desc="The comma operator shall not be used" id="AUTOSAR-M5_18_1-a" origId="MISRA2004-12_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_19_1" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="AUTOSAR-M5_19_1-a" origId="PB-66_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_19_1" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="AUTOSAR-M5_19_1-b" origId="PB-66_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_10" desc="The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression" id="AUTOSAR-M5_2_10-a" origId="CODSTA-232" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_11" desc="Avoid overloading comma operator &quot;,&quot;" id="AUTOSAR-M5_2_11-a" origId="CODSTA-CPP-80" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_11" desc="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="AUTOSAR-M5_2_11-b" origId="CODSTA-CPP-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_12" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="AUTOSAR-M5_2_12-a" origId="PB-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_2" desc="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="AUTOSAR-M5_2_2-a" origId="OOP-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_3" desc="Casts from a base class to a derived class should not be performed on polymorphic types" id="AUTOSAR-M5_2_3-a" origId="OOP-49" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_6" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="AUTOSAR-M5_2_6-a" origId="CODSTA-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_8" desc="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="AUTOSAR-M5_2_8-a" origId="CODSTA-65" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_2_9" desc="A cast should not convert a pointer type to an integral type" id="AUTOSAR-M5_2_9-a" origId="MISRA2004-11_3_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_3_1" desc="Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" id="AUTOSAR-M5_3_1-a" origId="CODSTA-CPP-67" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_3_2" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="AUTOSAR-M5_3_2-a" origId="MISRA2004-12_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_3_3" desc="The unary &amp; operator shall not be overloaded" id="AUTOSAR-M5_3_3-a" origId="CODSTA-CPP-68" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_3_4" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="AUTOSAR-M5_3_4-a" origId="MISRA2004-12_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_3_4" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="AUTOSAR-M5_3_4-b" origId="MISRA2004-12_3_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_3_4" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="AUTOSAR-M5_3_4-c" origId="MISRA2004-12_3_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M5_8_1" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="AUTOSAR-M5_8_1-a" origId="MISRA2004-12_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_2_1" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="AUTOSAR-M6_2_1-a" origId="MISRA2004-13_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_2_2" desc="Floating-point expressions shall not be tested for equality or inequality" id="AUTOSAR-M6_2_2-a" origId="MISRA2004-13_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_2_3" desc="A null statement shall occur on a line by itself or be followed by a comment" id="AUTOSAR-M6_2_3-a" origId="MISRA2004-14_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_3_1" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="AUTOSAR-M6_3_1-a" origId="MISRA2004-14_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="AUTOSAR-M6_4_1" desc="'if' and 'else' should be followed by a compound statement" id="AUTOSAR-M6_4_1-a" origId="MISRA2004-14_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_2" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="AUTOSAR-M6_4_2-a" origId="MISRA2004-14_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_3" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="AUTOSAR-M6_4_3-a" origId="CODSTA-64" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_3" desc="The final clause of a switch statement shall be the default-clause unless all enumeration values are tested" id="AUTOSAR-M6_4_3-b" origId="CODSTA-61" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_3" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="AUTOSAR-M6_4_3-c" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_3" desc="Every switch statement shall have at least one case clause" id="AUTOSAR-M6_4_3-d" origId="MISRA2004-15_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_3" desc="A switch expression shall not represent a value that is effectively Boolean" id="AUTOSAR-M6_4_3-e" origId="MISRA2004-15_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_4" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="AUTOSAR-M6_4_4-a" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_5" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="AUTOSAR-M6_4_5-a" origId="CODSTA-64" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_6" desc="The final clause of a switch statement shall be the default-clause unless all enumeration values are tested" id="AUTOSAR-M6_4_6-a" origId="CODSTA-61" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_4_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="AUTOSAR-M6_4_7-a" origId="MISRA2004-15_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_5_2" desc="If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" id="AUTOSAR-M6_5_2-a" origId="CODSTA-CPP-70" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_5_3" desc="Do not modify for loop counter within a body of the loop" id="AUTOSAR-M6_5_3-a" origId="MISRA2004-13_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_5_4" desc="The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop" id="AUTOSAR-M6_5_4-a" origId="CODSTA-CPP-71" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_5_5" desc="A loop-control-variable other than the loop-counter shall not be modified within condition or expression" id="AUTOSAR-M6_5_5-a" origId="CODSTA-CPP-72" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_5_6" desc="A loop-control-variable other than the loop-counter which is modified in statement shall have type bool" id="AUTOSAR-M6_5_6-a" origId="CODSTA-CPP-73" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_6_1" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="AUTOSAR-M6_6_1-a" origId="CODSTA-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_6_2" desc="The goto statement shall jump to a label declared later in the same function body" id="AUTOSAR-M6_6_2-a" origId="CODSTA-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M6_6_3" desc="The continue statement shall only be used within a well formed for loop" id="AUTOSAR-M6_6_3-a" origId="CODSTA-80" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_1_2" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="AUTOSAR-M7_1_2-a" origId="MISRA2004-16_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_1_2" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="AUTOSAR-M7_1_2-b" origId="MISRA2004-16_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_1_2" desc="Declare reference parameters as const references whenever possible" id="AUTOSAR-M7_1_2-c" origId="CODSTA-CPP-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="AUTOSAR-M7_3_1" desc="The global namespace shall only contain main() and namespace declarations" id="AUTOSAR-M7_3_1-a" origId="CODSTA-CPP-36" sev="2" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_3_2" desc="The identifier main shall not be used for a function other than the global function main" id="AUTOSAR-M7_3_2-a" origId="CODSTA-76" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_3_3" desc="There shall be no unnamed namespaces in header files" id="AUTOSAR-M7_3_3-a" origId="CODSTA-CPP-74" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="AUTOSAR-M7_3_4" desc="using-directives shall not be used" id="AUTOSAR-M7_3_4-a" origId="CODSTA-CPP-75" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_3_6" desc="using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" id="AUTOSAR-M7_3_6-a" origId="CODSTA-CPP-90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_4_1" desc="All usage of assembler shall be documented" id="AUTOSAR-M7_4_1-a" origId="COMMENT-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_4_2" desc="Assembler instructions shall only be introduced using the asm declaration" id="AUTOSAR-M7_4_2-a" origId="CODSTA-73" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_4_3" desc="Assembly language shall be encapsulated and isolated in C/C++ functions" id="AUTOSAR-M7_4_3-a" origId="CODSTA-114" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_5_1" desc="The address of an object with automatic storage shall not be returned from a function" id="AUTOSAR-M7_5_1-a" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M7_5_2" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="AUTOSAR-M7_5_2-a" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_0_1" desc="Each variable should be declared in a separate declaration statement" id="AUTOSAR-M8_0_1-a" origId="FORMAT-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_3_1" desc="Do not redefine an inherited virtual function with a different default parameter value" id="AUTOSAR-M8_3_1-a" origId="OOP-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_4_2" desc="The identifiers used in the declaration and definition of a function shall be identical" id="AUTOSAR-M8_4_2-a" origId="MISRA2004-16_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_4_4" desc="A function identifier shall only be used with either a preceding '&amp;', or with a parenthesised parameter list, which may be empty" id="AUTOSAR-M8_4_4-a" origId="MISRA2004-16_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_5_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="AUTOSAR-M8_5_2-a" origId="INIT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_5_2" desc="Arrays shall not be partially initialized" id="AUTOSAR-M8_5_2-b" origId="MISRA2004-9_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M8_5_2" desc="The non-zero initialization of structures requires an explicit initializer for each element" id="AUTOSAR-M8_5_2-c" origId="MISRA2004-9_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M9_3_1" desc="Const member functions shall not return non-const pointers or references to class-data" id="AUTOSAR-M9_3_1-a" origId="CODSTA-CPP-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M9_3_3" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="AUTOSAR-M9_3_3-a" origId="CODSTA-CPP-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="AUTOSAR-M9_6_4" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="AUTOSAR-M9_6_4-a" origId="CODSTA-71" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-API" desc="Do not pass incorrect values to library functions" id="BD-API-BADPARAM" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-API" desc="Do not pass negative values to functions expecting non-negative arguments" id="BD-API-NEGPARAM" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-API" desc="Do not pass incorrect values to ctype.h library functions" id="BD-API-CTYPE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-API" desc="Do not check for a non-negative value after passing as a non-negative argument" id="BD-API-REVNEGPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-API" desc="The size_t argument passed to any function in string.h shall have an appropriate value" id="BD-API-STRSIZE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-API" desc="Validate values passed to library functions" id="BD-API-VALPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-CO" desc="Do not access iterator out of range" id="BD-CO-ITOUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-CO" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="BD-CO-STRMOD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-CO" desc="Do not pass empty container iterators to std algorithms as destinations" id="BD-CO-EMPCON" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-CO" desc="Do not compare iterators from different containers" id="BD-CO-ITINVCOMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-CO" desc="Do not modify container while iterating over it" id="BD-CO-ITMOD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-MISC" desc="Always close transactions" id="BD-MISC-TRANS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-MISC" desc="Prevent calling unsafe functions (custom rule)" id="BD-MISC-DC" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Always catch exceptions" id="BD-PB-EXCEPT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not modify string literals" id="BD-PB-MODSTR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid use before initialization" id="BD-PB-NOTINIT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid null pointer dereferencing" id="BD-PB-NP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid buffer overflow due to defining incorrect format limits" id="BD-PB-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid overflow due to reading a not zero terminated string" id="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid overflow when reading from a buffer" id="BD-PB-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid overflow when writing to a buffer" id="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid overwriting method parameters" id="BD-PB-POVR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not point to a wrapped object that has been freed" id="BD-PB-WRAPESC" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid division by zero" id="BD-PB-ZERO" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid accessing arrays out of bounds" id="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="A pointer pointing to an element of an array of objects shall not be passed to a smart pointer of single object type" id="BD-PB-ARRPTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid incorrect shift operations" id="BD-PB-BADSHIFT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Use the correct byte ordering when transferring data between systems" id="BD-PB-BYTEORD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid conditions that always evaluate to the same value" id="BD-PB-CC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Consistently check the returned value of non-void functions" id="BD-PB-CHECKRET" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Always check the returned value of non-void function" id="BD-PB-CHECKRETGEN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not check for null after dereferencing" id="BD-PB-DEREF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not modify the alignment of objects by calling realloc()" id="BD-PB-DNMPTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="BD-PB-EOFCOMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Properly use errno value" id="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Properly define exit handlers" id="BD-PB-EXITHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Reset strings on fgets() or fgetws() failure" id="BD-PB-FGETS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Only use values for fsetpos() that are returned from fgetpos()" id="BD-PB-FSETPOS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid infinite recursion" id="BD-PB-INFREC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not rely on an environment pointer following an operation that may invalidate it" id="BD-PB-INVENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="BD-PB-INVRET" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="The Standard Library function memcmp shall not be used to compare null terminated strings" id="BD-PB-MCCSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid calls to memory-setting functions that can be optimized out by the compiler" id="BD-PB-MEMOPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Properly define new handlers" id="BD-PB-NEWHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid throwing exceptions from functions that are declared not to throw" id="BD-PB-NOEXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Declare non-returning functions with the attribute that specifies that they do not return" id="BD-PB-NORETDECL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Never return from functions that should not return" id="BD-PB-NORETURN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid accessing arrays and pointers out of bounds" id="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="An object shall not be assigned or copied to an overlapping object" id="BD-PB-OVERLAP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not treat arrays polymorphically" id="BD-PB-POLARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="BD-PB-PTRARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not compare two unrelated pointers" id="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not subtract two pointers that do not address elements of the same array" id="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="BD-PB-PTRVALUE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not call putenv() with a pointer to an automatic variable as the argument" id="BD-PB-PUTENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Properly define signal handlers" id="BD-PB-SIGHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not return from a computational exception signal handler" id="BD-PB-SIGRETURN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="BD-PB-STREAMINOUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not subsequently use the argument to std::forward" id="BD-PB-SUBSEQFRWD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not rely on the value of a moved-from object" id="BD-PB-SUBSEQMOVE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid switch with unreachable branches" id="BD-PB-SWITCH" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Properly define terminate handlers" id="BD-PB-TERMHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Properly define unexpected handlers" id="BD-PB-UNEXPHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not use dynamic type of an object under construction" id="BD-PB-VCTOR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not use dynamic type of an object under destruction" id="BD-PB-VDTOR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Ensure the size of the variable length array is in valid range" id="BD-PB-VLASIZE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="The same file shall not be opened for read and write access at the same time on different streams" id="BD-PB-WRRDSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid writing to a stream which has been opened as read only" id="BD-PB-WRROS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid integer overflows" id="BD-PB-INTOVERF" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Ensure strings are zero terminated" id="BD-PB-NZTS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Ensure the output buffer is large enough when using path manipulation functions" id="BD-PB-PATHBUF" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="A parameter shall be passed by reference if it can't be NULL" id="BD-PB-REFPARAM" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="BD-PB" desc="Always throw the created std::exception object" id="BD-PB-STDEXC" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Suspicious setting of stream flags" id="BD-PB-STREAMFLAGS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Restore stream format" id="BD-PB-STREAMFMT" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Use macros for variable arguments correctly" id="BD-PB-VARARGS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Avoid unused values" id="BD-PB-VOVR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="7;" authUrg="0;" cat="BD-PB" desc="Avoid unreachable methods" id="BD-PB-UCMETH" sev="4" total="7"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Guarantee that container indices are within the valid range" id="BD-PB-VALRANGE" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-PB" desc="Do not use recursion" id="BD-PB-RECFUN" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Properly deallocate dynamically allocated resources" id="BD-RES-BADDEALLOC" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Ensure deallocation functions guarantee resource freeing" id="BD-RES-BADFREEF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Do not use resources that have been freed" id="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Allocate sufficient memory to hold an object of a given type" id="BD-RES-INSUFMEM" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Do not free resources using invalid pointers" id="BD-RES-INVFREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Ensure resources are freed" id="BD-RES-LEAKS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Avoid cyclic shared_ptr references" id="BD-RES-CSP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-RES" desc="Do not create variables on the stack above the defined limits" id="BD-RES-STACKLIM" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid tainted data in array indexes" id="BD-SECURITY-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Prevent buffer overflows from tainted data" id="BD-SECURITY-BUFWRITE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Protect against integer overflow/underflow from tainted data" id="BD-SECURITY-INTOVERF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="BD-SECURITY-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid buffer read overflow from tainted data" id="BD-SECURITY-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid buffer write overflow from tainted data" id="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Protect against command injection" id="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid printing tainted data on the output console" id="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Protect against environment injection" id="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Protect against file name injection" id="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Exclude unsanitized user input from format strings" id="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Validate potentially tainted data before it is used in the controlling expression of a loop" id="BD-SECURITY-TDLOOP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Protect against SQL injection" id="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid passing unvalidated binary data to log methods" id="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Properly seed pseudorandom number generators" id="BD-SECURITY-RAND" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Sensitive data should be cleared before being deallocated" id="BD-SECURITY-SENSFREE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Avoid passing sensitive data to functions that write to log files" id="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="BD-SECURITY-TDALLOC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-SECURITY" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="BD-SECURITY-XXEXRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Avoid double locking" id="BD-TRS-DLOCK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Avoid race conditions when using fork and file descriptors" id="BD-TRS-FORKFILE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not abandon unreleased locks" id="BD-TRS-LOCK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not use global variable with different locks set" id="BD-TRS-MLOCK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not acquire locks in different order" id="BD-TRS-ORDER" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Avoid race conditions while checking for the existence of a symbolic link" id="BD-TRS-SYMLINK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not use blocking functions while holding a lock" id="BD-TRS-TSHL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="BD-TRS-ARG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Make const member functions thread-safe" id="BD-TRS-CMF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Variable should be used in context of single critical section" id="BD-TRS-DIFCS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Avoid race conditions while accessing files" id="BD-TRS-FRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not join or detach a thread that was previously joined or detached" id="BD-TRS-JOINDETACH" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Use locks to prevent race conditions when modifying bit fields" id="BD-TRS-BITLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not destroy another thread's mutex" id="BD-TRS-DSTRLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="BD-TRS" desc="Do not release a lock that has not been acquired" id="BD-TRS-REVLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" authTot="2;" authUrg="2;" cat="CDD" desc="Avoid function duplication" id="CDD-DUPM" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" authTot="5;" authUrg="5;" cat="CDD" desc="Avoid code duplication" id="CDD-DUPC" sev="3" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" authTot="0;" authUrg="0;" cat="CDD" desc="Avoid duplication of #include directives" id="CDD-DUPI" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" authTot="2;" authUrg="2;" cat="CDD" desc="Avoid string literal duplication" id="CDD-DUPS" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="8;" authUrg="0;" cat="CERT_C-API00" desc="The validity of parameters must be checked inside each function" id="CERT_C-API00-a" origId="CODSTA-86" sev="3" total="8"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-API01" desc="Avoid overflow when writing to a buffer" id="CERT_C-API01-a" origId="BD-PB-OVERFWR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-API01" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-API01-b" origId="SECURITY-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-API02" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-API02-a" origId="SECURITY-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-API02" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-API02-b" origId="SECURITY-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ARR01" desc="Do not call 'sizeof' on a pointer type" id="CERT_C-ARR01-a" origId="PB-32" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ARR02" desc="Explicitly specify array bounds in array declarations with initializers" id="CERT_C-ARR02-a" origId="CODSTA-200" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR30" desc="Avoid accessing arrays out of bounds" id="CERT_C-ARR30-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR32" desc="Ensure the size of the variable length array is in valid range" id="CERT_C-ARR32-a" origId="BD-PB-VLASIZE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR36" desc="Do not subtract two pointers that do not address elements of the same array" id="CERT_C-ARR36-a" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR36" desc="Do not compare two unrelated pointers" id="CERT_C-ARR36-b" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ARR37" desc="Pointer arithmetic shall not be applied to pointers that address variables of non-array type" id="CERT_C-ARR37-a" origId="PB-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR38" desc="Avoid overflow when reading from a buffer" id="CERT_C-ARR38-a" origId="BD-PB-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR38" desc="Avoid overflow when writing to a buffer" id="CERT_C-ARR38-b" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR38" desc="Avoid buffer overflow due to defining incorrect format limits" id="CERT_C-ARR38-c" origId="BD-PB-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR38" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-ARR38-d" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ARR39" desc="Avoid accessing arrays out of bounds" id="CERT_C-ARR39-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ARR39" desc="Pointer arithmetic should not be used" id="CERT_C-ARR39-b" origId="MISRA-101" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ARR39" desc="Do not add or subtract a scaled integer to a pointer" id="CERT_C-ARR39-c" origId="CODSTA-189" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON01" desc="Do not abandon unreleased locks" id="CERT_C-CON01-a" origId="BD-TRS-LOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON02" desc="Do not use the volatile keyword" id="CERT_C-CON02-a" origId="MISRA-046_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON05" desc="Do not use blocking functions while holding a lock" id="CERT_C-CON05-a" origId="BD-TRS-TSHL" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON30" desc="Ensure resources are freed" id="CERT_C-CON30-a" origId="BD-RES-LEAKS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON31" desc="Do not destroy another thread's mutex" id="CERT_C-CON31-a" origId="BD-TRS-DSTRLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON31" desc="Do not use resources that have been freed" id="CERT_C-CON31-b" origId="BD-RES-FREE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON31" desc="Do not free resources using invalid pointers" id="CERT_C-CON31-c" origId="BD-RES-INVFREE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON32" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_C-CON32-a" origId="BD-TRS-BITLOCK" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON33" desc="Avoid using thread-unsafe functions" id="CERT_C-CON33-a" origId="SECURITY-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON34" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="CERT_C-CON34-a" origId="BD-TRS-ARG" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON35" desc="Do not acquire locks in different order" id="CERT_C-CON35-a" origId="BD-TRS-ORDER" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON36" desc="Wrap functions that can spuriously wake up in a loop" id="CERT_C-CON36-a" origId="CODSTA-191" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON37" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-CON37-a" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON38" desc="Use the 'cnd_signal()' function with a unique condition variable" id="CERT_C-CON38-a" origId="SECURITY-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON39" desc="Do not join or detach a thread that was previously joined or detached" id="CERT_C-CON39-a" origId="BD-TRS-JOINDETACH" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON40" desc="Do not refer to an atomic variable twice in an expression" id="CERT_C-CON40-a" origId="CODSTA-195" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-CON41" desc="Wrap functions that can fail spuriously in a loop" id="CERT_C-CON41-a" origId="CODSTA-194" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-CON43" desc="Do not use global variable with different locks set" id="CERT_C-CON43-a" origId="BD-TRS-MLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="1;" cat="CERT_C-DCL00" desc="Declare local variable as const whenever possible" id="CERT_C-DCL00-a" origId="CODSTA-CPP-53" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL01" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="CERT_C-DCL01-a" origId="MISRA2004-5_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL01" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="CERT_C-DCL01-b" origId="MISRA2004-5_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL02" desc="Use visually distinct identifiers" id="CERT_C-DCL02-a" origId="NAMING-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL04" desc="Each variable should be declared in a separate declaration statement" id="CERT_C-DCL04-a" origId="FORMAT-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL05" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="CERT_C-DCL05-a" origId="MISRA2004-16_7_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL06" desc="Use meaningful symbolic constants to represent literal values" id="CERT_C-DCL06-a" origId="CODSTA-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL10" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-DCL10-a" origId="PB-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL11" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-DCL11-a" origId="PB-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL11" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-b" origId="PB-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL11" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-DCL11-c" origId="PB-47" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL11" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-d" origId="PB-48" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL11" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-DCL11-e" origId="PB-49" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL11" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-DCL11-f" origId="PB-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL12" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="CERT_C-DCL12-a" origId="CODSTA-115" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL13" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="CERT_C-DCL13-a" origId="MISRA2004-16_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL15" desc="Objects or functions with external linkage shall be declared in a header file" id="CERT_C-DCL15-a" origId="MISRA-023" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL16" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="CERT_C-DCL16-a" origId="PORT-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL18" desc="Octal and hexadecimal escape sequences shall be terminated" id="CERT_C-DCL18-a" origId="CODSTA-117" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL18" desc="Octal constants (other than zero) shall not be used" id="CERT_C-DCL18-b" origId="MISRA2004-7_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CERT_C-DCL19" desc="Declare variables as locally as possible" id="CERT_C-DCL19-a" origId="OPT-01" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL20" desc="The number of arguments passed to a function shall match the number of parameters" id="CERT_C-DCL20-a" origId="MISRA2004-16_6" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-DCL22" desc="Avoid unused values" id="CERT_C-DCL22-a" origId="BD-PB-VOVR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL30" desc="The address of an object with automatic storage shall not be returned from a function" id="CERT_C-DCL30-a" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL30" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="CERT_C-DCL30-b" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL31" desc="All functions shall be declared before use" id="CERT_C-DCL31-a" origId="MISRA-020" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL36" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="CERT_C-DCL36-a" origId="MISRA-024" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL37" desc="Do not #define or #undef identifiers with names which start with underscore" id="CERT_C-DCL37-a" origId="MISRA2004-20_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL38" desc="The final member of a structure should not be an array of size '0' or '1'" id="CERT_C-DCL38-a" origId="CODSTA-192" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL39" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="CERT_C-DCL39-a" origId="SECURITY-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="CERT_C-DCL40" desc="All declarations of an object or function shall have compatible types" id="CERT_C-DCL40-a" origId="GLOBAL-COMPATDECLS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL40" desc="If objects or functions are declared more than once their types shall be compatible" id="CERT_C-DCL40-b" origId="MISRA2004-8_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-DCL41" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="CERT_C-DCL41-a" origId="MISRA2004-15_0_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ENV01" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-ENV01-a" origId="SECURITY-07" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ENV01" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-ENV01-b" origId="SECURITY-12" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ENV01" desc="Avoid overflow when writing to a buffer" id="CERT_C-ENV01-c" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ENV02" desc="Usage of system properties (environment variables) should be restricted" id="CERT_C-ENV02-a" origId="SECURITY-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ENV30" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="CERT_C-ENV30-a" origId="CODSTA-185_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ENV31" desc="Do not rely on an environment pointer following an operation that may invalidate it" id="CERT_C-ENV31-a" origId="BD-PB-INVENV" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ENV32" desc="Properly define exit handlers" id="CERT_C-ENV32-a" origId="BD-PB-EXITHAN" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ENV33" desc="Do not call the 'system()' function from the 'stdlib.h' or 'cstdlib' library with an argument other than '0' (null pointer)" id="CERT_C-ENV33-a" origId="SECURITY-48" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ENV34" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="CERT_C-ENV34-a" origId="BD-PB-INVRET" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR01" desc="The error indicator 'errno' shall not be used" id="CERT_C-ERR01-a" origId="MISRA2004-20_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CERT_C-ERR02" desc="The Standard Library input/output functions shall not be used" id="CERT_C-ERR02-a" origId="CODSTA-110" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR04" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-a" origId="PB-75" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR04" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-b" origId="PB-75_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR04" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR04-c" origId="PB-75_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR05" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-a" origId="PB-75" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR05" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-b" origId="PB-75_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR05" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-ERR05-c" origId="PB-75_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR06" desc="Do not use assertions" id="CERT_C-ERR06-a" origId="CODSTA-199" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-ERR07" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_C-ERR07-a" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR07" desc="The library functions 'rewind', 'setbuf' and 'ctime' should not be used" id="CERT_C-ERR07-b" origId="CODSTA-235" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ERR30" desc="Properly use errno value" id="CERT_C-ERR30-a" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR30" desc="Provide error handling for file opening errors right next to the call to fopen" id="CERT_C-ERR30-b" origId="MRM-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ERR32" desc="Properly use errno value" id="CERT_C-ERR32-a" origId="BD-PB-ERRNO" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-ERR33" desc="The value returned by a standard library function that may return an error should be used" id="CERT_C-ERR33-a" origId="CODSTA-226_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-ERR33" desc="Always check the returned value of non-void function" id="CERT_C-ERR33-d" origId="BD-PB-CHECKRETGEN" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-ERR34" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_C-ERR34-a" origId="MISRA2004-20_10" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP00" desc="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="CERT_C-EXP00-a" origId="CODSTA-97" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP02" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="CERT_C-EXP02-a" origId="MISRA2004-12_4_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP05" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP05-a" origId="MISRA2004-11_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP08" desc="Pointer arithmetic should not be used" id="CERT_C-EXP08-a" origId="MISRA-101" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP08" desc="Avoid accessing arrays out of bounds" id="CERT_C-EXP08-b" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP10" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_C-EXP10-a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP10" desc="Don't write code that depends on the order of evaluation of function arguments" id="CERT_C-EXP10-b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP10" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="CERT_C-EXP10-c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP10" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="CERT_C-EXP10-d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-EXP12" desc="The value returned by a function having non-void return type shall be used" id="CERT_C-EXP12-a" origId="CODSTA-122_a" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP12" desc="The value returned by a function having non-void return type shall be used" id="CERT_C-EXP12-b" origId="CODSTA-122_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP14" desc="Avoid mixing arithmetic of different precisions in the same expression" id="CERT_C-EXP14-a" origId="MISRA-043_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP15" desc="Suspicious use of semicolon" id="CERT_C-EXP15-a" origId="CODSTA-57" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP16" desc="Function address should not be compared to zero" id="CERT_C-EXP16-a" origId="PB-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP19" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="CERT_C-EXP19-a" origId="MISRA2004-14_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP20" desc="Avoid comparing values with TRUE macro/enum constant using equality operators (&quot;==&quot;, &quot;!=&quot;)" id="CERT_C-EXP20-a" origId="CODSTA-60" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP30" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_C-EXP30-a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP30" desc="Don't write code that depends on the order of evaluation of function arguments" id="CERT_C-EXP30-b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP30" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="CERT_C-EXP30-c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP30" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="CERT_C-EXP30-d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP32" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP32-a" origId="MISRA2004-11_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP33" desc="Avoid use before initialization" id="CERT_C-EXP33-a" origId="BD-PB-NOTINIT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP34" desc="Avoid null pointer dereferencing" id="CERT_C-EXP34-a" origId="BD-PB-NP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP35" desc="Do not modify objects with temporary lifetime" id="CERT_C-EXP35-a" origId="CODSTA-196" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP36" desc="Do not cast pointers into more strictly aligned pointer types" id="CERT_C-EXP36-a" origId="CODSTA-230" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP37" desc="Conversions shall not be performed between non compatible pointer to a function types" id="CERT_C-EXP37-a" origId="CODSTA-124_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP37" desc="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="CERT_C-EXP37-b" origId="SECURITY-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP37" desc="Functions shall always have visible prototype at the function call" id="CERT_C-EXP37-d" origId="MISRA-071_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP39" desc="There shall be no implicit conversions from integral to floating type" id="CERT_C-EXP39-a" origId="MISRA2004-10_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP39" desc="A cast should not be performed between a pointer to object type and a different pointer to object type" id="CERT_C-EXP39-b" origId="MISRA2004-11_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP39" desc="Avoid accessing arrays and pointers out of bounds" id="CERT_C-EXP39-c" origId="BD-PB-OVERFARRAY" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP39" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="CERT_C-EXP39-d" origId="BD-SECURITY-OVERFFMT" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP39" desc="Avoid buffer read overflow from tainted data" id="CERT_C-EXP39-e" origId="BD-SECURITY-OVERFRD" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-EXP39" desc="Avoid buffer write overflow from tainted data" id="CERT_C-EXP39-f" origId="BD-SECURITY-OVERFWR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP40" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_C-EXP40-a" origId="MISRA2004-11_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP42" desc="Don't memcpy or memcmp non-PODs" id="CERT_C-EXP42-a" origId="MRM-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP43" desc="The restrict type qualifier shall not be used" id="CERT_C-EXP43-a" origId="CODSTA-121" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP44" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="CERT_C-EXP44-a" origId="MISRA2004-12_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP44" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="CERT_C-EXP44-b" origId="MISRA2004-12_3_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP45" desc="Assignment operators shall not be used in conditions without brackets" id="CERT_C-EXP45-b" origId="PB-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP45" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="CERT_C-EXP45-d" origId="MISRA2004-13_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP46" desc="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="CERT_C-EXP46-b" origId="MISRA2004-12_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-EXP47" desc="Do not call va_arg with an argument of the incorrect type" id="CERT_C-EXP47-a" origId="PB-72" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO01" desc="Don't use chmod(), chown(), chgrp()" id="CERT_C-FIO01-a" origId="SECURITY-27" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO01" desc="Usage of functions prone to race is not allowed" id="CERT_C-FIO01-b" origId="SECURITY-19" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO21" desc="Usage of functions prone to race is not allowed" id="CERT_C-FIO21-a" origId="SECURITY-19" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO22" desc="Ensure resources are freed" id="CERT_C-FIO22-a" origId="BD-RES-LEAKS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO24" desc="Avoid race conditions while accessing files" id="CERT_C-FIO24-a" origId="BD-TRS-FRC" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO30" desc="Avoid calling functions printf/wprintf with only one argument other than string constant" id="CERT_C-FIO30-a" origId="SECURITY-05" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO30" desc="Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable" id="CERT_C-FIO30-b" origId="SECURITY-08" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO30" desc="Never use unfiltered data from an untrusted user as the format parameter" id="CERT_C-FIO30-c" origId="SECURITY-36" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO32" desc="Protect against file name injection" id="CERT_C-FIO32-a" origId="BD-SECURITY-TDFNAMES" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO34" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="CERT_C-FIO34-a" origId="BD-PB-EOFCOMP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO37" desc="Avoid accessing arrays out of bounds" id="CERT_C-FIO37-a" origId="BD-PB-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO38" desc="A pointer to a FILE object shall not be dereferenced" id="CERT_C-FIO38-a" origId="CODSTA-166_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO39" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="CERT_C-FIO39-a" origId="BD-PB-STREAMINOUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO40" desc="Reset strings on fgets() or fgetws() failure" id="CERT_C-FIO40-a" origId="BD-PB-FGETS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO41" desc="Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing assignments, increment or decrement operators" id="CERT_C-FIO41-a" origId="CODSTA-228_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO41" desc="Do not call 'getc()', 'putc()', 'getwc()', or 'putwc()' with a stream argument containing function calls or function-like macro calls" id="CERT_C-FIO41-b" origId="CODSTA-228_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO42" desc="Ensure resources are freed" id="CERT_C-FIO42-a" origId="BD-RES-LEAKS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO44" desc="Only use values for fsetpos() that are returned from fgetpos()" id="CERT_C-FIO44-a" origId="BD-PB-FSETPOS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO45" desc="Avoid race conditions while accessing files" id="CERT_C-FIO45-a" origId="BD-TRS-FRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FIO46" desc="Do not use resources that have been freed" id="CERT_C-FIO46-a" origId="BD-RES-FREE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO47" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-FIO47-a" origId="PB-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO47" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-b" origId="PB-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO47" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="CERT_C-FIO47-c" origId="PB-47" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO47" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-d" origId="PB-48" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO47" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="CERT_C-FIO47-e" origId="PB-49" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FIO47" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="CERT_C-FIO47-f" origId="PB-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP00" desc="Floating-point expressions shall not be tested for equality or inequality" id="CERT_C-FLP00-a" origId="MISRA2004-13_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP02" desc="Floating-point expressions shall not be tested for equality or inequality" id="CERT_C-FLP02-a" origId="MISRA2004-13_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FLP03" desc="Avoid division by zero" id="CERT_C-FLP03-a" origId="BD-PB-ZERO" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP03" desc="Avoid implicit conversions from wider to narrower floating type" id="CERT_C-FLP03-b" origId="MISRA2004-10_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP03" desc="Avoid implicit conversions from narrower to wider floating type" id="CERT_C-FLP03-c" origId="MISRA2004-10_2_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP03" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="CERT_C-FLP03-d" origId="MISRA2004-10_2_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP06" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP06-a" origId="MISRA-043_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP06" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP06-b" origId="MISRA-043_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP30" desc="Do not use floating point variables as loop counters" id="CERT_C-FLP30-a" origId="MISRA-065" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-FLP32" desc="Validate values passed to library functions" id="CERT_C-FLP32-a" origId="BD-API-VALPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP34" desc="Avoid implicit conversions from wider to narrower floating type" id="CERT_C-FLP34-a" origId="MISRA2004-10_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP34" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="CERT_C-FLP34-b" origId="MISRA2004-10_2_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP36" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP36-a" origId="MISRA-043_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP36" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CERT_C-FLP36-b" origId="MISRA-043_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-FLP37" desc="Do not use object representations to compare floating-point values" id="CERT_C-FLP37-c" origId="CODSTA-190" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT02" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="CERT_C-INT02-a" origId="MISRA-043" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT02" desc="Avoid mixing arithmetic of different precisions in the same expression" id="CERT_C-INT02-b" origId="MISRA-043_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT04" desc="Protect against integer overflow/underflow from tainted data" id="CERT_C-INT04-a" origId="BD-SECURITY-INTOVERF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT04" desc="Avoid buffer read overflow from tainted data" id="CERT_C-INT04-b" origId="BD-SECURITY-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT04" desc="Avoid buffer write overflow from tainted data" id="CERT_C-INT04-c" origId="BD-SECURITY-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT05" desc="Avoid using unsafe string functions that do not check bounds" id="CERT_C-INT05-a" origId="SECURITY-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT07" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-INT07-a" origId="MISRA2004-6_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT07" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="CERT_C-INT07-b" origId="MISRA2004-6_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT08" desc="Avoid data loss when converting between integer types" id="CERT_C-INT08-a" origId="BD-PB-INTDL" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT09" desc="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="CERT_C-INT09-a" origId="MISRA2004-9_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="2;" cat="CERT_C-INT10" desc="The operands of the remainder operator '%' should be of unsigned integer types" id="CERT_C-INT10-a" origId="CODSTA-229" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT12" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="CERT_C-INT12-a" origId="MISRA2004-6_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT13" desc="Use bitwise operators only on unsigned operands" id="CERT_C-INT13-a" origId="CODSTA-63_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT15" desc="Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" id="CERT_C-INT15-a" origId="PB-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT16" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="CERT_C-INT16-a" origId="CODSTA-63" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="CERT_C-INT18-a" origId="PB-65" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="CERT_C-INT18-b" origId="PB-65_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT18" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="CERT_C-INT18-c" origId="MISRA-048_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT30" desc="Avoid wraparounds when performing arithmetic integer operations" id="CERT_C-INT30-a" origId="BD-PB-INTWRAP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT30" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CERT_C-INT30-b" origId="PB-66_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT30" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CERT_C-INT30-c" origId="PB-66_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="CERT_C-INT31-a" origId="CODSTA-161_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="CERT_C-INT31-b" origId="CODSTA-161_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="CERT_C-INT31-c" origId="CODSTA-161_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="CERT_C-INT31-d" origId="CODSTA-161_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="CERT_C-INT31-e" origId="CODSTA-161_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="CERT_C-INT31-f" origId="CODSTA-161_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="CERT_C-INT31-g" origId="CODSTA-161_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="CERT_C-INT31-h" origId="CODSTA-163_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="CERT_C-INT31-i" origId="CODSTA-163_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="CERT_C-INT31-j" origId="CODSTA-164_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="The second and third operands of the ternary operator shall have the same essential type category" id="CERT_C-INT31-k" origId="CODSTA-164_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="CERT_C-INT31-l" origId="CODSTA-157" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="CERT_C-INT31-m" origId="CODSTA-156_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="CERT_C-INT31-n" origId="CODSTA-156_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT31" desc="Avoid data loss when converting between integer types" id="CERT_C-INT31-o" origId="BD-PB-INTDL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT32" desc="Avoid signed integer overflows" id="CERT_C-INT32-a" origId="BD-PB-INTUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT32" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CERT_C-INT32-b" origId="PB-66_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT32" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CERT_C-INT32-c" origId="PB-66_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT33" desc="Avoid division by zero" id="CERT_C-INT33-a" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-INT34" desc="Avoid incorrect shift operations" id="CERT_C-INT34-a" origId="BD-PB-BADSHIFT" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT35" desc="Use correct integer precisions when checking the right hand operand of the shift operator" id="CERT_C-INT35-a" origId="SECURITY-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-INT36" desc="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="CERT_C-INT36-b" origId="CODSTA-127_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-a" origId="MRM-18" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-b" origId="MRM-19" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM00" desc="Do not allocate memory and expect that someone else will deallocate it later" id="CERT_C-MEM00-c" origId="MRM-20" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM00" desc="Do not use resources that have been freed" id="CERT_C-MEM00-d" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM00" desc="Ensure resources are freed" id="CERT_C-MEM00-e" origId="BD-RES-LEAKS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM01" desc="Do not use resources that have been freed" id="CERT_C-MEM01-a" origId="BD-RES-FREE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM01" desc="Always assign a new value to an expression that points to deallocated memory" id="CERT_C-MEM01-b" origId="MRM-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM01" desc="Always assign a new value to global or member variable that points to deallocated memory" id="CERT_C-MEM01-c" origId="MRM-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM01" desc="Always assign a new value to parameter or local variable that points to deallocated memory" id="CERT_C-MEM01-d" origId="MRM-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM02" desc="The result of the memory allocation function should be cast immediately" id="CERT_C-MEM02-a" origId="MRM-58_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM02" desc="The result of the memory allocation function should be cast immediately into a pointer to the allocated type" id="CERT_C-MEM02-b" origId="MRM-58_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM03" desc="Sensitive data should be cleared before being deallocated" id="CERT_C-MEM03-a" origId="BD-SECURITY-SENSFREE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-MEM04" desc="The validity of values passed to library functions shall be checked" id="CERT_C-MEM04-a" origId="MISRA2004-20_3" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM05" desc="Do not use recursion" id="CERT_C-MEM05-a" origId="BD-PB-RECFUN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM05" desc="Ensure the size of the variable length array is in valid range" id="CERT_C-MEM05-b" origId="BD-PB-VLASIZE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-MEM07" desc="The validity of values passed to library functions shall be checked" id="CERT_C-MEM07-a" origId="MISRA2004-20_3" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM12" desc="Ensure resources are freed" id="CERT_C-MEM12-a" origId="BD-RES-LEAKS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM30" desc="Do not use resources that have been freed" id="CERT_C-MEM30-a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM31" desc="Ensure resources are freed" id="CERT_C-MEM31-a" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM33" desc="Allocate structures containing a flexible array member dynamically" id="CERT_C-MEM33-a" origId="CODSTA-193" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM33" desc="Do not copy instances of structures containing a flexible array member" id="CERT_C-MEM33-b" origId="PB-71" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM34" desc="Do not free resources using invalid pointers" id="CERT_C-MEM34-a" origId="BD-RES-INVFREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MEM35" desc="Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function" id="CERT_C-MEM35-a" origId="MRM-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MEM36" desc="Do not modify the alignment of objects by calling realloc()" id="CERT_C-MEM36-a" origId="BD-PB-DNMPTR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC01" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="CERT_C-MSC01-a" origId="MISRA2004-14_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC01" desc="The final clause of a switch statement shall be the default clause" id="CERT_C-MSC01-b" origId="MISRA2004-15_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC04" desc="The character sequence /* shall not be used within a C-style comment" id="CERT_C-MSC04-a" origId="MISRA2004-2_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC04" desc="The character sequence // shall not be used within a C-style comment" id="CERT_C-MSC04-b" origId="COMMENT-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC04" desc="The character sequence /* shall not be used within a C++-style comment" id="CERT_C-MSC04-c" origId="COMMENT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC04" desc="Line-splicing shall not be used in // comments" id="CERT_C-MSC04-d" origId="COMMENT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code in &quot;else&quot; block" id="CERT_C-MSC07-a" origId="MISRA2004-14_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="CERT_C-MSC07-b" origId="MISRA2004-14_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="CERT_C-MSC07-c" origId="MISRA2004-14_1_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code in switch statement" id="CERT_C-MSC07-d" origId="MISRA2004-14_1_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code in 'for' loop" id="CERT_C-MSC07-e" origId="MISRA2004-14_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="CERT_C-MSC07-f" origId="MISRA2004-14_1_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="CERT_C-MSC07-g" origId="MISRA2004-14_1_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MSC07" desc="Avoid switch with unreachable branches" id="CERT_C-MSC07-h" origId="BD-PB-SWITCH" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CERT_C-MSC09" desc="Only use characters defined in the ISO C standard" id="CERT_C-MSC09-a" origId="MISRA-005" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC11" desc="Assert liberally to document internal assumptions and invariants" id="CERT_C-MSC11-a" origId="CODSTA-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code in &quot;else&quot; block" id="CERT_C-MSC12-a" origId="MISRA2004-14_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="CERT_C-MSC12-b" origId="MISRA2004-14_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="CERT_C-MSC12-c" origId="MISRA2004-14_1_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code in switch statement" id="CERT_C-MSC12-d" origId="MISRA2004-14_1_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code in 'for' loop" id="CERT_C-MSC12-e" origId="MISRA2004-14_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="CERT_C-MSC12-f" origId="MISRA2004-14_1_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="CERT_C-MSC12-g" origId="MISRA2004-14_1_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MSC12" desc="Avoid switch with unreachable branches" id="CERT_C-MSC12-h" origId="BD-PB-SWITCH" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC13" desc="Avoid unnecessary local variables" id="CERT_C-MSC13-a" origId="OPT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC14" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CERT_C-MSC14-a" origId="PB-73" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC15" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CERT_C-MSC15-a" origId="PB-73" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC17" desc="Missing break statement between cases in a switch statement" id="CERT_C-MSC17-a" origId="CODSTA-149" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MSC19" desc="Avoid accessing arrays out of bounds" id="CERT_C-MSC19-a" origId="BD-PB-ARRAY" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MSC19" desc="Avoid null pointer dereferencing" id="CERT_C-MSC19-b" origId="BD-PB-NP" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC22" desc="The facilities provided by &lt;setjmp.h> should not be used" id="CERT_C-MSC22-a" origId="MISRA2004-20_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-MSC24" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_C-MSC24-a" origId="MISRA2004-20_10" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC24" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_C-MSC24-b" origId="SECURITY-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC24" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-MSC24-c" origId="SECURITY-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC24" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="CERT_C-MSC24-d" origId="SECURITY-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC30" desc="Do not use the rand() function for generating pseudorandom numbers" id="CERT_C-MSC30-a" origId="SECURITY-02_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MSC32" desc="Properly seed pseudorandom number generators" id="CERT_C-MSC32-d" origId="BD-SECURITY-RAND" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC33" desc="The 'asctime()' and 'asctime_r()' functions should not be used" id="CERT_C-MSC33-a" origId="SECURITY-01" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC37" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="CERT_C-MSC37-a" origId="MISRA2004-16_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC38" desc="A function-like macro shall not be invoked without all of its arguments" id="CERT_C-MSC38-a" origId="MISRA2004-19_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-MSC39" desc="Use macros for variable arguments correctly" id="CERT_C-MSC39-a" origId="BD-PB-VARARGS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-MSC40" desc="An inline definition of a function with external linkage shall not contain definitions and uses of static objects" id="CERT_C-MSC40-a" origId="CODSTA-202" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_C-MSC41" desc="Do not hard code string literals" id="CERT_C-MSC41-a" origId="CODSTA-203" sev="1" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS30" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-POS30-a" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS30" desc="The values returned by functions 'read' and 'readlink' shall be used" id="CERT_C-POS30-b" origId="CODSTA-144" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS30" desc="Use of possibly not null-terminated string with functions expecting null-terminated string" id="CERT_C-POS30-c" origId="CODSTA-145" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS33" desc="Avoid using the 'vfork()' function" id="CERT_C-POS33-a" origId="SECURITY-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS34" desc="Usage of system properties (environment variables) should be restricted" id="CERT_C-POS34-a" origId="SECURITY-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS34" desc="Do not call putenv() with a pointer to an automatic variable as the argument" id="CERT_C-POS34-b" origId="BD-PB-PUTENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS35" desc="Avoid race conditions while checking for the existence of a symbolic link" id="CERT_C-POS35-b" origId="BD-TRS-SYMLINK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS36" desc="Observe correct revocation order while relinquishing privileges" id="CERT_C-POS36-a" origId="SECURITY-44" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS37" desc="Ensure that privilege relinquishment is successful" id="CERT_C-POS37-a" origId="SECURITY-45" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS38" desc="Avoid race conditions when using fork and file descriptors" id="CERT_C-POS38-a" origId="BD-TRS-FORKFILE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS39" desc="Use the correct byte ordering when transferring data between systems" id="CERT_C-POS39-a" origId="BD-PB-BYTEORD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS44" desc="The 'pthread_kill', 'pthread_sigqueue' and 'tgkill' functions should not be used to send signals to threads" id="CERT_C-POS44-a" origId="SECURITY-53" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS47" desc="The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument" id="CERT_C-POS47-a" origId="SECURITY-43" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS48" desc="Do not destroy another thread's mutex" id="CERT_C-POS48-a" origId="BD-TRS-DSTRLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS48" desc="Do not release a lock that has not been acquired" id="CERT_C-POS48-b" origId="BD-TRS-REVLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS49" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_C-POS49-a" origId="BD-TRS-BITLOCK" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS50" desc="Declare objects shared between POSIX threads with appropriate storage durations" id="CERT_C-POS50-a" origId="BD-TRS-ARG" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS51" desc="Do not acquire locks in different order" id="CERT_C-POS51-a" origId="BD-TRS-ORDER" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-POS52" desc="Do not use blocking functions while holding a lock" id="CERT_C-POS52-a" origId="BD-TRS-TSHL" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="CERT_C-POS53" desc="Do not use more than one mutex for concurrent waiting operations on a condition variable" id="CERT_C-POS53-a" origId="GLOBAL-CONDMUTEXVAR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-POS54" desc="The value returned by a POSIX library function that may return an error should be used" id="CERT_C-POS54-a" origId="CODSTA-227" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE00" desc="A function should be used in preference to a function-like macro" id="CERT_C-PRE00-a" origId="MISRA2004-19_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE01" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="CERT_C-PRE01-a" origId="MISRA2004-19_10" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE02" desc="Enclose in parentheses whole definition of a function-like macro" id="CERT_C-PRE02-a" origId="MISRA-096" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE06" desc="Use multiple include guards" id="CERT_C-PRE06-a" origId="PFO-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE07" desc="Trigraphs shall not be used" id="CERT_C-PRE07-a" origId="MISRA2004-4_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE30" desc="Avoid token concatenation that may produce universal character names" id="CERT_C-PRE30-a" origId="PREPROC-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE31" desc="Assertions should not contain assignments, increment, or decrement operators" id="CERT_C-PRE31-b" origId="CODSTA-150" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE31" desc="Assertions should not contain function calls nor function-like macro calls" id="CERT_C-PRE31-c" origId="CODSTA-150_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE31" desc="Avoid side effects in arguments to unsafe macros" id="CERT_C-PRE31-d" origId="CODSTA-150_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-PRE32" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="CERT_C-PRE32-a" origId="MISRA2004-19_9" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-SIG00" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG00-a" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-SIG01" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG01-a" origId="MISRA2004-20_8_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-SIG02" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="CERT_C-SIG02-a" origId="MISRA2004-20_8_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-SIG30" desc="Properly define signal handlers" id="CERT_C-SIG30-a" origId="BD-PB-SIGHAN" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-SIG31" desc="Properly define signal handlers" id="CERT_C-SIG31-a" origId="BD-PB-SIGHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-SIG34" desc="Properly define signal handlers" id="CERT_C-SIG34-a" origId="BD-PB-SIGHAN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-SIG35" desc="Do not return from a computational exception signal handler" id="CERT_C-SIG35-a" origId="BD-PB-SIGRETURN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR00" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-STR00-a" origId="MISRA2004-6_1" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR02" desc="Protect against command injection" id="CERT_C-STR02-a" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR02" desc="Protect against file name injection" id="CERT_C-STR02-b" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR02" desc="Protect against SQL injection" id="CERT_C-STR02-c" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR03" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-STR03-a" origId="BD-PB-OVERFNZT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR04" desc="The plain char type shall be used only for the storage and use of character values" id="CERT_C-STR04-a" origId="MISRA2004-6_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR05" desc="A string literal shall not be modified" id="CERT_C-STR05-a" origId="PB-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR07" desc="Avoid using unsafe string functions that do not check bounds" id="CERT_C-STR07-a" origId="SECURITY-13" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR09" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="CERT_C-STR09-a" origId="CODSTA-69" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR10" desc="Narrow and wide string literals shall not be concatenated" id="CERT_C-STR10-a" origId="PB-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR11" desc="Do not specify the bound of a character array initialized with a string literal" id="CERT_C-STR11-a" origId="CODSTA-197" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR30" desc="A string literal shall not be modified" id="CERT_C-STR30-a" origId="PB-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR30" desc="Do not modify string literals" id="CERT_C-STR30-b" origId="BD-PB-MODSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR31" desc="Avoid accessing arrays out of bounds" id="CERT_C-STR31-a" origId="BD-PB-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR31" desc="Avoid overflow when writing to a buffer" id="CERT_C-STR31-b" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR31" desc="Prevent buffer overflows from tainted data" id="CERT_C-STR31-c" origId="BD-SECURITY-BUFWRITE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR31" desc="Avoid buffer write overflow from tainted data" id="CERT_C-STR31-d" origId="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR31" desc="Avoid using unsafe string functions which may cause buffer overflows" id="CERT_C-STR31-e" origId="SECURITY-12" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR32" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_C-STR32-a" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR34" desc="Cast characters to unsigned char before assignment to larger integer sizes" id="CERT_C-STR34-b" origId="CODSTA-187_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR34" desc="An expressions of the 'signed char' type should not be used as an array index" id="CERT_C-STR34-c" origId="CODSTA-187_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR34" desc="Cast characters to unsigned char before converting to larger integer sizes" id="CERT_C-STR34-d" origId="CODSTA-187_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-STR37" desc="Do not pass incorrect values to ctype.h library functions" id="CERT_C-STR37-a" origId="BD-API-CTYPE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-STR38" desc="Do not confuse narrow and wide character strings and functions" id="CERT_C-STR38-a" origId="CODSTA-188" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_C-WIN00" desc="Use care to ensure that LoadLibrary() will load the correct library" id="CERT_C-WIN00-a" origId="SECURITY-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_C-WIN30" desc="Ensure resources are freed" id="CERT_C-WIN30-a" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CON50" desc="Do not destroy another thread's mutex" id="CERT_CPP-CON50-a" origId="BD-TRS-DSTRLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CON51" desc="Do not call lock() directly on a mutex" id="CERT_CPP-CON51-a" origId="CODSTA-MCPP-21" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CON52" desc="Use locks to prevent race conditions when modifying bit fields" id="CERT_CPP-CON52-a" origId="BD-TRS-BITLOCK" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CON53" desc="Do not acquire locks in different order" id="CERT_CPP-CON53-a" origId="BD-TRS-ORDER" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CON54" desc="Wrap functions that can spuriously wake up in a loop" id="CERT_CPP-CON54-a" origId="CODSTA-191" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CON55" desc="Do not use the 'notify_one()' function when multiple threads are waiting on the same condition variable" id="CERT_CPP-CON55-a" origId="SECURITY-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CON56" desc="Avoid double locking" id="CERT_CPP-CON56-a" origId="BD-TRS-DLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR50" desc="Guarantee that container indices are within the valid range" id="CERT_CPP-CTR50-a" origId="BD-PB-VALRANGE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR51" desc="Do not modify container while iterating over it" id="CERT_CPP-CTR51-a" origId="BD-CO-ITMOD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR52" desc="Do not pass empty container iterators to std algorithms as destinations" id="CERT_CPP-CTR52-a" origId="BD-CO-EMPCON" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR53" desc="Do not use an iterator range that isn't really a range" id="CERT_CPP-CTR53-a" origId="STL-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR53" desc="Do not compare iterators from different containers" id="CERT_CPP-CTR53-b" origId="BD-CO-ITINVCOMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR54" desc="Do not compare iterators from different containers" id="CERT_CPP-CTR54-a" origId="BD-CO-ITINVCOMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR54" desc="Do not compare two unrelated pointers" id="CERT_CPP-CTR54-b" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR54" desc="Do not subtract two pointers that do not address elements of the same array" id="CERT_CPP-CTR54-c" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR55" desc="Do not add or subtract a constant with a value greater than one from an iterator" id="CERT_CPP-CTR55-a" origId="PB-74" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR56" desc="Don't treat arrays polymorphically" id="CERT_CPP-CTR56-a" origId="PB-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR56" desc="A pointer to an array of derived class objects should not be converted to a base class pointer" id="CERT_CPP-CTR56-b" origId="PB-57" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR56" desc="Do not treat arrays polymorphically" id="CERT_CPP-CTR56-c" origId="BD-PB-POLARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR57" desc="For associative containers never use comparison function returning true for equal values" id="CERT_CPP-CTR57-a" origId="STL-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-CTR58" desc="Make predicates const pure functions" id="CERT_CPP-CTR58-a" origId="STL-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL50" desc="Functions shall not be defined with a variable number of arguments" id="CERT_CPP-DCL50-a" origId="MISRA2004-16_1" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL51" desc="Do not #define or #undef identifiers with names which start with underscore" id="CERT_CPP-DCL51-a" origId="MISRA2004-20_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL51" desc="Do not redefine reserved words" id="CERT_CPP-DCL51-b" origId="MISRA2004-20_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL51" desc="Do not #define nor #undef identifier 'defined'" id="CERT_CPP-DCL51-c" origId="MISRA2004-20_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL51" desc="The names of standard library macros, objects and functions shall not be reused" id="CERT_CPP-DCL51-d" origId="MISRA2004-20_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL51" desc="The names of standard library macros, objects and functions shall not be reused (C90)" id="CERT_CPP-DCL51-e" origId="MISRA2004-20_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL51" desc="The names of standard library macros, objects and functions shall not be reused (C99)" id="CERT_CPP-DCL51-f" origId="MISRA2004-20_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL52" desc="Never qualify a reference type with 'const' or 'volatile'" id="CERT_CPP-DCL52-a" origId="CODSTA-CPP-97" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL53" desc="Parameter names in function declarations should not be enclosed in parentheses" id="CERT_CPP-DCL53-a" origId="FORMAT-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL53" desc="Local variable names in variable declarations should not be enclosed in parentheses" id="CERT_CPP-DCL53-b" origId="FORMAT-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL53" desc="Avoid function declarations that are syntactically ambiguous" id="CERT_CPP-DCL53-c" origId="PB-79" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL54" desc="Always provide new and delete together" id="CERT_CPP-DCL54-a" origId="MRM-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL55" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="CERT_CPP-DCL55-a" origId="SECURITY-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL56" desc="Avoid initialization order problems across translation units by replacing non-local static objects with local static objects" id="CERT_CPP-DCL56-a" origId="INIT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL57" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="CERT_CPP-DCL57-a" origId="EXCEPT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL57" desc="Always catch exceptions" id="CERT_CPP-DCL57-b" origId="BD-PB-EXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL58" desc="Do not modify the standard namespaces 'std' and 'posix'" id="CERT_CPP-DCL58-a" origId="CODSTA-CPP-95" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL59" desc="There shall be no unnamed namespaces in header files" id="CERT_CPP-DCL59-a" origId="CODSTA-CPP-74" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="CERT_CPP-DCL60" desc="The One Definition Rule shall not be violated" id="CERT_CPP-DCL60-a" origId="GLOBAL-ONEDEFRULE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="CERT_CPP-ERR50-a" origId="PB-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="CERT_CPP-ERR50-b" origId="EXCEPT-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Do not throw from within destructor" id="CERT_CPP-ERR50-c" origId="EXCEPT-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="CERT_CPP-ERR50" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="CERT_CPP-ERR50-d" origId="EXCEPT-06" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="CERT_CPP-ERR50-e" origId="EXCEPT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Exceptions shall be raised only after start-up and before termination of the program" id="CERT_CPP-ERR50-f" origId="EXCEPT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="CERT_CPP-ERR50-g" origId="EXCEPT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="CERT_CPP-ERR50-h" origId="EXCEPT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="CERT_CPP-ERR50-i" origId="EXCEPT-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Always catch exceptions" id="CERT_CPP-ERR50-j" origId="BD-PB-EXCEPT" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Properly define exit handlers" id="CERT_CPP-ERR50-k" origId="BD-PB-EXITHAN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_CPP-ERR50-l" origId="PB-75" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="Avoid throwing exceptions from functions that are declared not to throw" id="CERT_CPP-ERR50-m" origId="BD-PB-NOEXCEPT" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR50" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="CERT_CPP-ERR50-n" origId="PB-75_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR51" desc="Always catch exceptions" id="CERT_CPP-ERR51-a" origId="BD-PB-EXCEPT" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR51" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="CERT_CPP-ERR51-b" origId="EXCEPT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR52" desc="The facilities provided by &lt;setjmp.h> should not be used" id="CERT_CPP-ERR52-a" origId="MISRA2004-20_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR52" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="CERT_CPP-ERR52-b" origId="MISRA2004-20_7_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR53" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="CERT_CPP-ERR53-a" origId="EXCEPT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR54" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="CERT_CPP-ERR54-a" origId="EXCEPT-17" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR55" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="CERT_CPP-ERR55-a" origId="EXCEPT-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR56" desc="Always catch exceptions" id="CERT_CPP-ERR56-a" origId="BD-PB-EXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR56" desc="Do not leave 'catch' blocks empty" id="CERT_CPP-ERR56-b" origId="EXCEPT-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR57" desc="Ensure resources are freed" id="CERT_CPP-ERR57-a" origId="BD-RES-LEAKS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR58" desc="Exceptions shall be raised only after start-up and before termination of the program" id="CERT_CPP-ERR58-a" origId="EXCEPT-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_CPP-ERR59" desc="Do not throw an exception across execution boundaries" id="CERT_CPP-ERR59-a" origId="PORT-30" sev="1" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR60" desc="Exception objects must be nothrow copy constructible" id="CERT_CPP-ERR60-a" origId="EXCEPT-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-ERR60" desc="An explicitly declared copy constructor for a class that inherits from 'std::exception' should have a non-throwing exception specification" id="CERT_CPP-ERR60-b" origId="EXCEPT-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CERT_CPP-ERR61" desc="A class type exception shall always be caught by reference" id="CERT_CPP-ERR61-a" origId="EXCEPT-15" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CERT_CPP-ERR61" desc="Throw by value, catch by reference" id="CERT_CPP-ERR61-b" origId="EXCEPT-02" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CERT_CPP-ERR62" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="CERT_CPP-ERR62-a" origId="MISRA2004-20_10" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP50" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="CERT_CPP-EXP50-a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of function arguments" id="CERT_CPP-EXP50-b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="CERT_CPP-EXP50-c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="CERT_CPP-EXP50-d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP50" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="CERT_CPP-EXP50-e" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP50" desc="Don't write code that depends on the order of evaluation of function calls" id="CERT_CPP-EXP50-f" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP51" desc="Do not treat arrays polymorphically" id="CERT_CPP-EXP51-a" origId="BD-PB-POLARR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP52" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="CERT_CPP-EXP52-a" origId="MISRA2004-12_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP52" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="CERT_CPP-EXP52-b" origId="MISRA2004-12_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP52" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="CERT_CPP-EXP52-c" origId="MISRA2004-12_3_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP52" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="CERT_CPP-EXP52-d" origId="CODSTA-CPP-104" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP52" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="CERT_CPP-EXP52-e" origId="CODSTA-CPP-104_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP53" desc="Avoid use before initialization" id="CERT_CPP-EXP53-a" origId="BD-PB-NOTINIT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP54" desc="Do not use resources that have been freed" id="CERT_CPP-EXP54-a" origId="BD-RES-FREE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP54" desc="The address of an object with automatic storage shall not be returned from a function" id="CERT_CPP-EXP54-b" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP54" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="CERT_CPP-EXP54-c" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP55" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="CERT_CPP-EXP55-a" origId="MISRA2004-11_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP56" desc="Do not call a function with a mismatched language linkage" id="CERT_CPP-EXP56-a" origId="CODSTA-CPP-96" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP57" desc="Do not delete objects with incomplete class at the point of deletion" id="CERT_CPP-EXP57-a" origId="PB-55" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP57" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="CERT_CPP-EXP57-b" origId="CODSTA-125" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP58" desc="Use macros for variable arguments correctly" id="CERT_CPP-EXP58-a" origId="BD-PB-VARARGS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP59" desc="Use offsetof() on valid types and members" id="CERT_CPP-EXP59-a" origId="CODSTA-CPP-99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP60" desc="Do not pass a nonstandard-layout type object across execution boundaries" id="CERT_CPP-EXP60-a" origId="PORT-31" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP61" desc="Never return lambdas that capture local objects by reference" id="CERT_CPP-EXP61-a" origId="CODSTA-MCPP-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP61" desc="Never capture local objects from an outer lambda by reference" id="CERT_CPP-EXP61-b" origId="CODSTA-MCPP-17_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP61" desc="The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime" id="CERT_CPP-EXP61-c" origId="CODSTA-MCPP-17_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP62" desc="Do not compare objects of a class that may contain padding bits with C standard library functions" id="CERT_CPP-EXP62-a" origId="CODSTA-CPP-100" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-EXP63" desc="Do not rely on the value of a moved-from object" id="CERT_CPP-EXP63-a" origId="BD-PB-SUBSEQMOVE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-FIO50" desc="Do not alternately input and output from a stream without an intervening flush or positioning call" id="CERT_CPP-FIO50-a" origId="BD-PB-STREAMINOUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-FIO51" desc="Ensure resources are freed" id="CERT_CPP-FIO51-a" origId="BD-RES-LEAKS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-INT50" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="CERT_CPP-INT50-a" origId="PB-70" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM50" desc="Do not use resources that have been freed" id="CERT_CPP-MEM50-a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM51" desc="Use the same form in corresponding calls to new/malloc and delete/free" id="CERT_CPP-MEM51-a" origId="MRM-06" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM51" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="CERT_CPP-MEM51-b" origId="MRM-36" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM51" desc="Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor" id="CERT_CPP-MEM51-c" origId="MRM-40_d" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM51" desc="Properly deallocate dynamically allocated resources" id="CERT_CPP-MEM51-d" origId="BD-RES-BADDEALLOC" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM52" desc="Check the return value of new" id="CERT_CPP-MEM52-a" origId="MRM-34" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM52" desc="Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined" id="CERT_CPP-MEM52-b" origId="MRM-01" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM53" desc="Do not invoke malloc/realloc for objects having constructors" id="CERT_CPP-MEM53-a" origId="MRM-08" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM54" desc="Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'" id="CERT_CPP-MEM54-a" origId="MRM-55" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM54" desc="An overhead should be used when an array of objects is passed to the placement 'new' allocation function" id="CERT_CPP-MEM54-b" origId="MRM-55_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM55" desc="The user defined 'new' operator should throw the 'std::bad_alloc' exception when the allocation fails" id="CERT_CPP-MEM55-a" origId="MRM-53" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM56" desc="Do not store an already-owned pointer value in an unrelated smart pointer" id="CERT_CPP-MEM56-a" origId="BD-PB-PTRVALUE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MEM57" desc="Avoid using the default operator 'new' for over-aligned types" id="CERT_CPP-MEM57-a" origId="MRM-54" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MSC50" desc="Do not use the rand() function for generating pseudorandom numbers" id="CERT_CPP-MSC50-a" origId="SECURITY-02_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-MSC51" desc="Properly seed pseudorandom number generators" id="CERT_CPP-MSC51-a" origId="BD-SECURITY-RAND" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-MSC52" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="CERT_CPP-MSC52-a" origId="MISRA2004-16_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-MSC53" desc="Never return from functions that should not return" id="CERT_CPP-MSC53-a" origId="BD-PB-NORETURN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-MSC54" desc="Properly define signal handlers" id="CERT_CPP-MSC54-a" origId="BD-PB-SIGHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP50" desc="Avoid calling virtual functions from constructors" id="CERT_CPP-OOP50-a" origId="OOP-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP50" desc="Avoid calling virtual functions from destructors" id="CERT_CPP-OOP50-b" origId="OOP-16_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP50" desc="Do not use dynamic type of an object under construction" id="CERT_CPP-OOP50-c" origId="BD-PB-VCTOR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP50" desc="Do not use dynamic type of an object under destruction" id="CERT_CPP-OOP50-d" origId="BD-PB-VDTOR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP51" desc="Do not slice derived objects" id="CERT_CPP-OOP51-a" origId="PB-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP52" desc="Define a virtual destructor in classes used as base classes which have virtual functions" id="CERT_CPP-OOP52-a" origId="OOP-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP53" desc="List members in an initialization list in the order in which they are declared" id="CERT_CPP-OOP53-a" origId="INIT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP54" desc="Check for assignment to self in operator=" id="CERT_CPP-OOP54-a" origId="OOP-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP55" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="CERT_CPP-OOP55-a" origId="CODSTA-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP56" desc="Properly define terminate handlers" id="CERT_CPP-OOP56-a" origId="BD-PB-TERMHAN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP56" desc="Properly define unexpected handlers" id="CERT_CPP-OOP56-b" origId="BD-PB-UNEXPHAN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP56" desc="Properly define new handlers" id="CERT_CPP-OOP56-c" origId="BD-PB-NEWHAN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP57" desc="Do not initialize objects with a non-trivial class type using C standard library functions" id="CERT_CPP-OOP57-a" origId="CODSTA-CPP-93" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP57" desc="Do not compare objects of nonstandard-layout class type with C standard library functions" id="CERT_CPP-OOP57-b" origId="CODSTA-CPP-94" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-OOP58" desc="Copy operations must not mutate the source object" id="CERT_CPP-OOP58-a" origId="CODSTA-CPP-98" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR50" desc="Avoid overflow due to reading a not zero terminated string" id="CERT_CPP-STR50-b" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR50" desc="Avoid overflow when writing to a buffer" id="CERT_CPP-STR50-c" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR50" desc="Prevent buffer overflows from tainted data" id="CERT_CPP-STR50-e" origId="BD-SECURITY-BUFWRITE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR50" desc="Avoid buffer write overflow from tainted data" id="CERT_CPP-STR50-f" origId="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CERT_CPP-STR50" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="CERT_CPP-STR50-g" origId="SECURITY-51" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR51" desc="Avoid null pointer dereferencing" id="CERT_CPP-STR51-a" origId="BD-PB-NP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR52" desc="Use valid references, pointers, and iterators to reference elements of a basic_string" id="CERT_CPP-STR52-a" origId="BD-CO-STRMOD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CERT_CPP-STR53" desc="Guarantee that container indices are within the valid range" id="CERT_CPP-STR53-a" origId="BD-PB-VALRANGE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Local variable or parameter names and class member variable or parent class/struct member variable names shall differ by more than a single character" id="CODSTA-22" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid internal or external name conflict with a C++ reserved word" id="CODSTA-39" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Local variables should not use the same names as member variables" id="CODSTA-44" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Parameters should not use the same names as member variables" id="CODSTA-45" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use break in for loops" id="CODSTA-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA" desc="Global functions shall not declare parameters with array type" id="CODSTA-142" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not declare the size of an array when the array is passed into a function as a parameter" id="CODSTA-15" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not declare the size of an array when the array is initialized" id="CODSTA-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="CODSTA-160" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A pointer to a FILE object shall not be dereferenced" id="CODSTA-166_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A pointer to a FILE object shall not be dereferenced by a library function" id="CODSTA-166_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="CODSTA-182" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="CODSTA-185_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not specify the bound of a character array initialized with a string literal" id="CODSTA-197" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="EOS should be used to terminate a string rather than NULL" id="CODSTA-20" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An inline definition of a function with external linkage shall not contain definitions and uses of static objects" id="CODSTA-202" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Literal suffixes shall use uppercase rather than lowercase letters" id="CODSTA-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Enumeration types shall be used instead of integer types (and constants) as case labels" id="CODSTA-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Array elements shall be accessed by the array operator [ ]" id="CODSTA-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not define constants via #define" id="CODSTA-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Local variables shall not have static storage duration" id="CODSTA-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Pointers to pointers should be avoided whenever possible" id="CODSTA-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid using the '?:' operator" id="CODSTA-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="If a function has no parameters, use ( ) instead of ( void )" id="CODSTA-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not cast pointers to functions to pointers to primitive types" id="CODSTA-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Storage type modifiers shall be associated with the type, not the variable or the function" id="CODSTA-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Signed and unsigned values shall not be mixed in arithmetic operations" id="CODSTA-100" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Signed and unsigned values shall not be mixed in second and third operand of conditional operator" id="CODSTA-101" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A single operation with side-effect shall only be used in the proper context" id="CODSTA-102" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A call of function with side-effect shall only be used in the proper context" id="CODSTA-103" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" id="CODSTA-104" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" id="CODSTA-107" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The standard header file &lt;tgmath.h> shall not be used" id="CODSTA-108" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The facilities that are specified as being provided by &lt;tgmath.h> should not be used" id="CODSTA-108_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The features provided by &lt;fenv.h> should not be used" id="CODSTA-109" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CODSTA" desc="The Standard Library input/output functions shall not be used" id="CODSTA-110" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The union keyword should not be used" id="CODSTA-111" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Variable-length arrays should not be used" id="CODSTA-112" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Flexible array members shall not be declared" id="CODSTA-113" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Assembly language shall be encapsulated and isolated in C/C++ functions" id="CODSTA-114" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="CODSTA-116" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Octal and hexadecimal escape sequences shall be terminated" id="CODSTA-117" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A declaration shall be visible when an object or function with external linkage is defined" id="CODSTA-118" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="CODSTA-119" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid using shift operations instead of arithmetic operations" id="CODSTA-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An inline function shall be declared with the static storage class" id="CODSTA-120" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The restrict type qualifier shall not be used" id="CODSTA-121" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA" desc="The value returned by a function having non-void return type shall be used" id="CODSTA-122_a" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value returned by a function having non-void return type shall be used" id="CODSTA-122_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="CODSTA-124_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Conversions shall not be performed between non compatible pointer to a function types" id="CODSTA-124_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="CODSTA-125" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="CODSTA-126" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="CODSTA-129_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An implicit conversion shall not be performed between pointer to void and an arithmetic type" id="CODSTA-129_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc=">, >=, &lt;, &lt;= shall not be applied to pointer types except where they point to the same array" id="CODSTA-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="CODSTA-130" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use NULL instead of literal zero (0) as the null-pointer-constant" id="CODSTA-131" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A macro shall not be defined with the same name as a keyword in C90" id="CODSTA-133_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A macro shall not be defined with the same name as a keyword in C99" id="CODSTA-133_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Type casting from any type to or from pointers shall not be used" id="CODSTA-135" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used" id="CODSTA-136_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The identifiers va_list, va_arg, va_start, va_end should not be used" id="CODSTA-136_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The function call shall not be the operand of the sizeof operator" id="CODSTA-137" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The result of a built-in assignment operator should not be used" id="CODSTA-138" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Pointer subtraction shall only be applied to pointers that address elements of the same array" id="CODSTA-13_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Never convert consts to non-consts" id="CODSTA-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Initializer lists shall not contain persistent side effects" id="CODSTA-141_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Functions which are called with array argument shall not be declared with pointer parameter" id="CODSTA-142_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Suspicious use of 'strcpy' without checking size of source buffer" id="CODSTA-143" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The values returned by functions 'read' and 'readlink' shall be used" id="CODSTA-144" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use of possibly not null-terminated string with functions expecting null-terminated string" id="CODSTA-145" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A value returned from a stdio character-oriented I/O function should not be implicitly converted to a type smaller than 'int'" id="CODSTA-146" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Pointer should not be compared with NULL using relational operators &lt;, >, >=, &lt;=" id="CODSTA-147" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use string literals as operands of equality or relational operators" id="CODSTA-148" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Missing break statement between cases in a switch statement" id="CODSTA-149" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Assertions should not contain assignments, increment, or decrement operators" id="CODSTA-150" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid side effects in arguments to unsafe macros" id="CODSTA-150_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="CODSTA-152" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An external object or function shall not have more than one non-defining declaration in translation unit" id="CODSTA-154" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use typedefs from stdint.h instead of declaring your own in C99 code" id="CODSTA-155" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="CODSTA-156_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="CODSTA-156_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="CODSTA-157" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Function types shall have named parameters" id="CODSTA-158" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Function types shall be in prototype form" id="CODSTA-159" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="CODSTA-161_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="CODSTA-161_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="CODSTA-161_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="CODSTA-161_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="CODSTA-161_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="CODSTA-161_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="CODSTA-161_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="CODSTA-162" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="CODSTA-163_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="CODSTA-163_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="CODSTA-164_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The second and third operands of the ternary operator shall have the same essential type category" id="CODSTA-164_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not cast from or to essentially Boolean type" id="CODSTA-165_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A loop counter in a 'for' loop shall not have essentially floating type" id="CODSTA-167_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="CODSTA-167_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="CODSTA-168" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The first clause of a 'for' loop shall be well-formed" id="CODSTA-169_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The second clause of a 'for' loop shall be well-formed" id="CODSTA-169_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The third clause of a 'for' statement shall be well-formed" id="CODSTA-169_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use NULL identifier; use 0 instead" id="CODSTA-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)" id="CODSTA-170_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)" id="CODSTA-170_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The name of a macro should be distinct from the names of its parameters(c90)" id="CODSTA-171_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The name of a macro should be distinct from the names of its parameters(c99)" id="CODSTA-171_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="CODSTA-172_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="CODSTA-172_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="CODSTA-174_a_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="CODSTA-174_a_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="CODSTA-174_b_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="CODSTA-174_b_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="External identifiers shall be distinct" id="CODSTA-178" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="CODSTA-179_a_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="CODSTA-179_a_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="CODSTA-179_b_c90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="CODSTA-179_b_c99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="CODSTA-183" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="CODSTA-184" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="CODSTA-185_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="CODSTA-186" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Cast characters to unsigned char before assignment to larger integer sizes" id="CODSTA-187_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An expressions of the 'signed char' type should not be used as an array index" id="CODSTA-187_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Cast characters to unsigned char before converting to larger integer sizes" id="CODSTA-187_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not confuse narrow and wide character strings and functions" id="CODSTA-188" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not add or subtract a scaled integer to a pointer" id="CODSTA-189" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use the ctype.h facilities for character test" id="CODSTA-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use object representations to compare floating-point values" id="CODSTA-190" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Wrap functions that can spuriously wake up in a loop" id="CODSTA-191" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The final member of a structure should not be an array of size '0' or '1'" id="CODSTA-192" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Allocate structures containing a flexible array member dynamically" id="CODSTA-193" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Wrap functions that can fail spuriously in a loop" id="CODSTA-194" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not refer to an atomic variable twice in an expression" id="CODSTA-195" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not modify objects with temporary lifetime" id="CODSTA-196" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value of a complex expression of floating type should not be cast to a wider floating type" id="CODSTA-198" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The value of a complex expression of floating type should not be cast to an integer type" id="CODSTA-198_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use assertions" id="CODSTA-199" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Explicitly specify array bounds in array declarations with initializers" id="CODSTA-200" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not process structured text data natively" id="CODSTA-201" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Functions declared as 'noreturn' shall have the 'void' return type" id="CODSTA-204" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not cast an array to the pointer to a structure of a larger size than the size of the array" id="CODSTA-205" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The '_Noreturn' function specifier should not be used" id="CODSTA-206" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The &lt;stdnoreturn.h> header file should not be used" id="CODSTA-207" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The &lt;stdalign.h> header file shall not be used" id="CODSTA-208" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The facilities that are specified as being provided by &lt;stdatomic.h> should not be used" id="CODSTA-209" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The '_Thread_local' storage class specifier should not be used" id="CODSTA-210" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The facilities that are specified as being provided by &lt;threads.h> should not be used" id="CODSTA-211" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The 'rsize_t' type should not be used" id="CODSTA-212" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The '_Alignas' alignment specifier and the '_Alignof' operator should not be used" id="CODSTA-213" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The '_Atomic' type specifier and the '_Atomic' type qualifier should not be used" id="CODSTA-214" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'" id="CODSTA-215" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The '_Generic' operator should not be used" id="CODSTA-216" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The 'errno_t' type should not be used" id="CODSTA-217" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use following macros: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S" id="CODSTA-218" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use the functions defined in Annex K of ISO/IEC 9899:2011 standard" id="CODSTA-219" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Arguments of integer-constant macros should be decimal, octal, or hexadecimal constants with appropriate values" id="CODSTA-220" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not include any type qualifiers in the specification of a function type" id="CODSTA-221" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid implicit integral conversions from a wider to a narrower type" id="CODSTA-222" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="CODSTA" desc="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" id="CODSTA-223" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The conditional operator should not be used as a sub-expression" id="CODSTA-224" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="1;" cat="CODSTA" desc="All 'if' statements should have an 'else' clause" id="CODSTA-23" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="CODSTA" desc="Avoid magic numbers" id="CODSTA-26" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid functions that modify global variables" id="CODSTA-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use meaningful symbolic constants to represent literal values" id="CODSTA-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid returning handles to function parameters" id="CODSTA-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid explicit type conversions (casts)" id="CODSTA-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not write logical expressions of the type if(test) or if(!test)  when test is a pointer" id="CODSTA-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use operator ++ or -- in the conditional expression of if, while, or switch" id="CODSTA-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use a typedef to simplify program syntax when declaring function pointers" id="CODSTA-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Always provide a default branch for switch statements" id="CODSTA-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Pass built-in-types by value unless you are modifying them" id="CODSTA-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Prefer const objects or enums to #defines for simple constants" id="CODSTA-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use a #define that prevents the compiler from checking types" id="CODSTA-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="'void' should be used when a function is passed or returns no values" id="CODSTA-40" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="All structures should be typedef'd" id="CODSTA-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use the following digraphs: &lt;%, %>, &lt;:, :>, %:, %:%:" id="CODSTA-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Null initialize or increment expressions in for loops will not be used; a while loop will be used instead" id="CODSTA-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Hexadecimal constants will be represented using all uppercase letters" id="CODSTA-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter" id="CODSTA-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop" id="CODSTA-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Every switch statement will have at least two cases and a potential default" id="CODSTA-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="All 'case' and 'default' labels of 'switch' statement should have an explicit 'break' or a 'return' statement, or 'fall through' comment" id="CODSTA-56" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid comparing values with TRUE macro/enum constant using equality operators (&quot;==&quot;, &quot;!=&quot;)" id="CODSTA-60" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The final clause of a switch statement shall be the default-clause unless all enumeration values are tested" id="CODSTA-61" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="CODSTA-62" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="CODSTA-63" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="CODSTA-64" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="CODSTA-65" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Non-constant operands to a binary bitwise operator shall have the same underlying type" id="CODSTA-66" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" id="CODSTA-67" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" id="CODSTA-68" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than  =,  ==, != and the unary &amp; operator" id="CODSTA-69" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Expressions with type enum shall not be used as operands to built-in operators other than  [ ],  =, ==, !=, &lt;, &lt;=, >, >=, and the unary &amp; operator" id="CODSTA-70" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="CODSTA-71" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Assembler instructions shall only be introduced using the asm declaration" id="CODSTA-73" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Bit-fields shall not have enum type" id="CODSTA-74" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Bit-fields shall be either bool type or an explicitly unsigned or signed integral type" id="CODSTA-75" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The identifier main shall not be used for a function other than the global function main" id="CODSTA-76" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The goto statement shall jump to a label declared later in the same function body" id="CODSTA-77" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="CODSTA-78" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="CODSTA-79" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The continue statement shall only be used within a well formed for loop" id="CODSTA-80" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="If a function has internal linkage then all re-declarations shall include the 'static' storage class specifier" id="CODSTA-81" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid infinite loops" id="CODSTA-82" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use empty infinite loops" id="CODSTA-82_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="All loops must have a fixed upper or lower bound" id="CODSTA-83" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid exit points within infinite loops" id="CODSTA-85" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="8;" authUrg="0;" cat="CODSTA" desc="The validity of parameters must be checked inside each function" id="CODSTA-86" sev="3" total="8"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use no more than one level of dereferencing" id="CODSTA-87" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Function pointers are not permitted" id="CODSTA-88" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The declaration should not contain more than one level of pointer indirection" id="CODSTA-89" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Each operand of a logical '&amp;&amp;' or '||' shall be a postfix-expression" id="CODSTA-90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A function shall have at most one exit point" id="CODSTA-91" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The names of standard library macros and objects shall not be reused" id="CODSTA-92" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="CODSTA-92_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="CODSTA-92_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="CODSTA" desc="Do not declare pointer or array type" id="CODSTA-94" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="CODSTA" desc="Do not declare pointer type" id="CODSTA-95" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Bit-fields shall have explicitly unsigned integral or enumeration types only" id="CODSTA-96" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="CODSTA-97" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="All 'if...else if' constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary" id="CODSTA-98" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Signed and unsigned values shall not be mixed in comparison operations" id="CODSTA-99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The second or third operand of a ternary operator '?:' shall not contain side effects" id="CODSTA-105" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="CODSTA-115" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects" id="CODSTA-123" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A conversion should not be performed between a pointer to object and an integer type" id="CODSTA-127" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="CODSTA-127_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A conversion should not be performed from pointer to void into pointer to object" id="CODSTA-128" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A function parameter should not be modified" id="CODSTA-132" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="CODSTA-134" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use enumerations in boolean condition" id="CODSTA-151" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The cast operation to essentially enumeration type is not allowed" id="CODSTA-165_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not use casts between essentially character types and essentially floating types" id="CODSTA-165_c" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A function should not contain unused type declarations" id="CODSTA-175_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A source file should not contain unused type declarations" id="CODSTA-175_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A function should not contain unused local tag declarations" id="CODSTA-176_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A source file should not contain unused tag declarations" id="CODSTA-176_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="A source file should not contain unused macro definitions" id="CODSTA-177" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The +, -, += and -= operators should not be applied to an expression of pointer type" id="CODSTA-181" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Avoid switch statements with only one case" id="CODSTA-41" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Suspicious use of semicolon" id="CODSTA-57" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Cast to void is not allowed" id="CODSTA-58" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Hardcoded array declarations and 'malloc' calls should not be used" id="CODSTA-59" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Do not declare member variables as bit-fields" id="CODSTA-02" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Assert liberally to document internal assumptions and invariants" id="CODSTA-11" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Assertions should not contain function calls nor function-like macro calls" id="CODSTA-150_b" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Prefer 'while' statements over 'do' statements" id="CODSTA-18" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA" desc="Do not hard code string literals" id="CODSTA-203" sev="5" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="When using enum, the values of each member should be explicitly declared" id="CODSTA-21" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The macro FALSE should be defined as 0 (zero)" id="CODSTA-24" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The enumeration constant named 'FALSE' should be explicitly initialized by 0 value" id="CODSTA-25" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Define fields for union declarations" id="CODSTA-28" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The macro TRUE should be defined as 1" id="CODSTA-42" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The enumeration constant named 'TRUE' should be explicitly initialized by 1 value" id="CODSTA-43" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="Use positive logic rather than negative logic whenever practical" id="CODSTA-46" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA" desc="The names of standard library functions shall not be overridden" id="CODSTA-93" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Constructors allowing for conversion should be made explicit" id="CODSTA-CPP-04" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not use user-defined conversion functions" id="CODSTA-CPP-05" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The first operand of a conditional-operator shall have type bool" id="CODSTA-CPP-65" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CODSTA-CPP" desc="Declare at least one constructor to prevent the compiler from doing so" id="CODSTA-CPP-19" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Arrays shall not be used in interfaces" id="CODSTA-CPP-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Private and protected methods shall not declare parameters with array type" id="CODSTA-CPP-55_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Copy operations must not mutate the source object" id="CODSTA-CPP-98" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Have assignment operator returns a reference to *this; make assignment operator's return type a non-const reference to it's class' type" id="CODSTA-CPP-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Bitwise operators, comparison operators, logical operators, comma operator should be const" id="CODSTA-CPP-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid returning handles to class data from member functions" id="CODSTA-CPP-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Postfix increment and decrement should be implemented in terms of their prefix counterparts" id="CODSTA-CPP-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="CODSTA-CPP-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid using reinterpret_cast" id="CODSTA-CPP-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not define structs that contain member functions" id="CODSTA-CPP-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not compare objects of a class that may contain padding bits with C standard library functions" id="CODSTA-CPP-100" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A relational operator shall return a boolean value" id="CODSTA-CPP-101" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A binary arithmetic operator and a bitwise operator shall return a 'prvalue'" id="CODSTA-CPP-102" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Output parameters shall not be used" id="CODSTA-CPP-103" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="CODSTA-CPP-104" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="CODSTA-CPP-104_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Define special members as =default when the behavior is equivalent to the compiler's behavior" id="CODSTA-CPP-105" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Use delegating constructors to reduce code duplication" id="CODSTA-CPP-106" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Comparison operators shall be non-member functions" id="CODSTA-CPP-107" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Comparison operators shall be non-member functions with identical parameter types and noexcept" id="CODSTA-CPP-107_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="C-style casts should not be used" id="CODSTA-CPP-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CODSTA-CPP" desc="Put classes that are used as base classes and classes that are used as member variables into separate include files" id="CODSTA-CPP-12" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Put classes that are used as function return type into separate include files" id="CODSTA-CPP-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Put classes that are used as argument types in function prototypes into separate include files" id="CODSTA-CPP-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Put functions that are used in the body of inline member function into separate include file" id="CODSTA-CPP-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="When two operators are opposites (such as == and !=), it is appropriate to define both" id="CODSTA-CPP-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not use the 'struct' keyword to declare a variable in C++" id="CODSTA-CPP-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If you'd like to support mixed-mode operations make operators a non-member functions" id="CODSTA-CPP-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid making any assignment operator virtual. Do not return const T&amp; from assignment operator" id="CODSTA-CPP-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Consider making virtual functions nonpublic, and public functions nonvirtual" id="CODSTA-CPP-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Keep types and functions in separate namespaces unless they're specifically intended to work together" id="CODSTA-CPP-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Keep a type and its nonmember function interface in the same namespace" id="CODSTA-CPP-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="When binary arithmetic operators are defined  ( + , - , * , / , ^ , % , | , &amp; ), assignment versions should be provided too" id="CODSTA-CPP-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Prefer the canonical forms of arithmetic and assignment operators" id="CODSTA-CPP-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Prefer non-member operators than member ones to support mixed-mode arithmetic" id="CODSTA-CPP-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A function definition should not be placed in a class specification unless the function is intended to be inlined" id="CODSTA-CPP-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Member functions shall not be defined within the template class definition" id="CODSTA-CPP-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid using static_cast on pointers" id="CODSTA-CPP-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid dynamic_casts" id="CODSTA-CPP-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="CODSTA-CPP" desc="The global namespace shall only contain main() and namespace declarations" id="CODSTA-CPP-36" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not define class/struct/union inside function implementation" id="CODSTA-CPP-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Conversion operator, operator->, operator(), operator[] should be const" id="CODSTA-CPP-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Don't write namespace usings in a header file or before an #include" id="CODSTA-CPP-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not use the 'enum' keyword to declare a variable in C++" id="CODSTA-CPP-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not declare member variables with the 'mutable' keyword" id="CODSTA-CPP-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Declare reference parameters as const references whenever possible" id="CODSTA-CPP-43" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Have the non-const version call the const version of member function instead of duplicating the const version definition" id="CODSTA-CPP-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="In the private section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" id="CODSTA-CPP-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Order of scopes in class: public before all others" id="CODSTA-CPP-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Order of scopes in classes: protected before private" id="CODSTA-CPP-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CODSTA-CPP" desc="In the protected section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" id="CODSTA-CPP-48" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="In the public section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" id="CODSTA-CPP-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not use static keyword except inside functions and classes" id="CODSTA-CPP-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="CODSTA-CPP" desc="Do not define inline functions in source files" id="CODSTA-CPP-51" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Consider using the natural relationship between the assignment version of an operator and the stand-alone version" id="CODSTA-CPP-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="1;" cat="CODSTA-CPP" desc="Declare local variable as const whenever possible" id="CODSTA-CPP-53" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Member functions shall be declared const whenever possible" id="CODSTA-CPP-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A class, structure, or enumeration will not be declared in the definition of its type" id="CODSTA-CPP-56" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Namespaces will not be nested more than two levels deep" id="CODSTA-CPP-57" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA-CPP" desc="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="CODSTA-CPP-58" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CODSTA-CPP" desc="The C library shall not be used" id="CODSTA-CPP-59" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used" id="CODSTA-CPP-60" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Only those escape sequences that are defined in ISO/IEC 14882:2014 shall be used" id="CODSTA-CPP-60_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="NULL shall not be used as an integer value" id="CODSTA-CPP-62" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="CODSTA-CPP-63" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The condition of an if-statement and the condition of an iteration-statement shall have type bool" id="CODSTA-CPP-64" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="CODSTA-CPP-66" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" id="CODSTA-CPP-67" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The unary &amp; operator shall not be overloaded" id="CODSTA-CPP-68" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A for loop shall contain a single loop-counter which shall not have floating type" id="CODSTA-CPP-69" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" id="CODSTA-CPP-70" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop" id="CODSTA-CPP-71" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A loop-control-variable other than the loop-counter shall not be modified within condition or expression" id="CODSTA-CPP-72" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="A loop-control-variable other than the loop-counter which is modified in statement shall have type bool" id="CODSTA-CPP-73" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="There shall be no unnamed namespaces in header files" id="CODSTA-CPP-74" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA-CPP" desc="using-directives shall not be used" id="CODSTA-CPP-75" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier" id="CODSTA-CPP-76" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Const member functions shall not return non-const pointers or references to class-data" id="CODSTA-CPP-77" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="CODSTA-CPP-78" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Neither operand of an equality operator (== or !=) shall be a pointer to a virtual member function" id="CODSTA-CPP-79" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid overloading comma operator &quot;,&quot;" id="CODSTA-CPP-80" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Avoid unencapsulated global variables (including variables declared in namespaces and public static members)" id="CODSTA-CPP-82" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="CODSTA-CPP-83" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="CODSTA-CPP-84" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="CODSTA-CPP-85" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If two opposite equality operators ('==', '!=') are defined in a class, one shall be defined in terms of the other" id="CODSTA-CPP-86" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="CODSTA-CPP-87_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="CODSTA-CPP-87_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="CODSTA-CPP-87_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The name of typedef should not be the same as the name of its basic type" id="CODSTA-CPP-88" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" id="CODSTA-CPP-90" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="CODSTA-CPP-91" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="All accessible entity names within a multiple inheritance hierarchy should be unique" id="CODSTA-CPP-92" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not initialize objects with a non-trivial class type using C standard library functions" id="CODSTA-CPP-93" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not compare objects of nonstandard-layout class type with C standard library functions" id="CODSTA-CPP-94" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not modify the standard namespaces 'std' and 'posix'" id="CODSTA-CPP-95" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not call a function with a mismatched language linkage" id="CODSTA-CPP-96" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Never qualify a reference type with 'const' or 'volatile'" id="CODSTA-CPP-97" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Use offsetof() on valid types and members" id="CODSTA-CPP-99" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Prefer non-member non-friend functions to member functions" id="CODSTA-CPP-22" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Classes which have only getters/setters (accessors/mutators) are not allowed" id="CODSTA-CPP-81" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not assign enumerations to bool" id="CODSTA-CPP-89" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CODSTA-CPP" desc="Prefer iostream.h to stdio.h" id="CODSTA-CPP-01" sev="5" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA-CPP" desc="Encapsulate global variables and constants, enumerated types, and typedefs in a class" id="CODSTA-CPP-18" sev="5" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Assignment operator must return const reference" id="CODSTA-CPP-21" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="CODSTA-CPP" desc="Whenever a global function  is  referenced, use the :: operator" id="CODSTA-CPP-23" sev="5" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Do not use the keyword 'explicit' for a constructor" id="CODSTA-CPP-31" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-CPP" desc="Limiting the number of objects of a class" id="CODSTA-CPP-40" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer lambdas over std::bind, std::bind1st and std::bind2nd" id="CODSTA-MCPP-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="5;" authUrg="1;" cat="CODSTA-MCPP" desc="Prefer 'auto' to explicit type names in variable declarations" id="CODSTA-MCPP-08_a" sev="2" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer 'auto' to explicit type names for function return types" id="CODSTA-MCPP-08_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="All std::hash specializations for user-defined types shall have a noexcept function call operator" id="CODSTA-MCPP-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="User-conversion cast operators should be made explicit" id="CODSTA-MCPP-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer alias declarations to typedefs" id="CODSTA-MCPP-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer Scoped Enums to Unscoped Enums" id="CODSTA-MCPP-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CODSTA-MCPP" desc="Each overriding virtual function shall be declared with the override or final specifier" id="CODSTA-MCPP-05" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Declare copy constructor and copy assignment operators with the 'delete' specifier to prevent copying of class" id="CODSTA-MCPP-06_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Declare copy constructor and copy assignment operators with the 'delete' specifier instead of using a base class with private methods to prevent copying of class" id="CODSTA-MCPP-06_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="The 'binder1st' and 'binder2nd' identifiers should not be used" id="CODSTA-MCPP-07_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Declare functions 'noexcept' if they will not emit exceptions" id="CODSTA-MCPP-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer const iterators to iterators" id="CODSTA-MCPP-10_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer to use cbegin(), crbegin, cend(), crend() functions" id="CODSTA-MCPP-10_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use std::move() on rvalue references and std::forward() on forwarding references" id="CODSTA-MCPP-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="The 'std::forward' function should be used to forward forwarding references" id="CODSTA-MCPP-13_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Avoid Overloading on Forwarding References" id="CODSTA-MCPP-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Avoid default capture modes" id="CODSTA-MCPP-15_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use the 'this' pointer explicitly in lambdas with a default by-reference capture" id="CODSTA-MCPP-15_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer 'std::make_shared' to the direct use of new" id="CODSTA-MCPP-16_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer to use std::unique_ptr instead of std::auto_ptr" id="CODSTA-MCPP-16_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="'std::make_unique' shall be used to construct objects owned by 'std::unique_ptr'" id="CODSTA-MCPP-16_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Never return lambdas that capture local objects by reference" id="CODSTA-MCPP-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Never capture local objects from an outer lambda by reference" id="CODSTA-MCPP-17_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="The lambda that captures local objects by reference should not be assigned to the variable with a greater lifetime" id="CODSTA-MCPP-17_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Avoid unnecessary default capture modes in lambda expressions" id="CODSTA-MCPP-18_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Avoid unnecessary lambda captures" id="CODSTA-MCPP-18_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Declare assignment operators with the ref-qualifier &amp;" id="CODSTA-MCPP-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use explicit ref-qualifiers on auto declarations in range-based 'for' loops" id="CODSTA-MCPP-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="If a public destructor of a class is non-virtual, then the class should be declared final" id="CODSTA-MCPP-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Only one of virtual, override or final should be specified in a member function declaration" id="CODSTA-MCPP-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Digit sequences separators ' shall only be used consistently" id="CODSTA-MCPP-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="CODSTA-MCPP-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="A lambda shall not be an operand to typeid" id="CODSTA-MCPP-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use smart pointers when passing a pointer to an object in a thread" id="CODSTA-MCPP-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Consider using 'std::unique_ptr' instead of 'std::shared_ptr' for local objects" id="CODSTA-MCPP-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Define both sized and unsized versions of operator delete" id="CODSTA-MCPP-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Static and thread-local objects shall be constant-initialized" id="CODSTA-MCPP-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="User defined literals operators shall only perform conversion of passed parameters" id="CODSTA-MCPP-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="A smart pointer shall only be used as a parameter type if it expresses lifetime semantics" id="CODSTA-MCPP-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="A parameter should only be declared as a non-const lvalue reference to 'std::shared_ptr' or 'std::unique_ptr' if the function replaces the managed object" id="CODSTA-MCPP-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not declare the type of a parameter as an rvalue reference to 'std::shared_ptr' or 'std::unique_ptr'" id="CODSTA-MCPP-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Derived classes that do not need further explicit initialization and require all the constructors from the base class shall use inheriting constructors" id="CODSTA-MCPP-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="1;" cat="CODSTA-MCPP" desc="Braced-initialization {}, without equals sign, shall be used for variable initialization" id="CODSTA-MCPP-38" sev="3" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="A variable of type auto shall not be initialized using '{}' or '={}' braced-initialization" id="CODSTA-MCPP-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not overuse 'auto' specifier" id="CODSTA-MCPP-40" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="The 'random_shuffle' identifier should not be used" id="CODSTA-MCPP-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not use the increment operator (++) on an operand of type 'bool'" id="CODSTA-MCPP-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="The 'set_unexpected' identifier should not be used" id="CODSTA-MCPP-43" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Lambda expressions should not be defined inside another lambda expression" id="CODSTA-MCPP-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Return type of a non-void return type lambda expression should be explicitly specified" id="CODSTA-MCPP-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Include a parameter list in every lambda expression" id="CODSTA-MCPP-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Avoid overloading constructors with std::initializer_list" id="CODSTA-MCPP-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Multiple output values from a function should be returned as a struct or tuple" id="CODSTA-MCPP-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="User-defined copy and move assignment operators should use user-defined no-throw swap function" id="CODSTA-MCPP-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" id="CODSTA-MCPP-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use const container calls when the result is immediately converted to a const iterator" id="CODSTA-MCPP-51" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not introduce virtual functions in a final class" id="CODSTA-MCPP-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not use std::move on objects declared with the const or const &amp; type" id="CODSTA-MCPP-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not create an rvalue reference of std::array" id="CODSTA-MCPP-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use std::call_once rather than the Double-Checked Locking pattern" id="CODSTA-MCPP-55" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="CODSTA-MCPP-04" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="1;" cat="CODSTA-MCPP" desc="Use constexpr to declare const variables whenever possible" id="CODSTA-MCPP-11_a_cpp11" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Use constexpr to declare functions whenever possible" id="CODSTA-MCPP-11_b_cpp11" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer smart pointer members over raw pointer members" id="CODSTA-MCPP-16_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer smart pointers over raw pointers for arrays or STL containers" id="CODSTA-MCPP-16_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Prefer smart pointers over raw local pointers" id="CODSTA-MCPP-20" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CODSTA-MCPP" desc="Do not call lock() directly on a mutex" id="CODSTA-MCPP-21" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Line-splicing shall not be used in // comments" id="COMMENT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Prefer C++ style comment" id="COMMENT-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="COMMENT" desc="Provide copyright information" id="COMMENT-02" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="COMMENT" desc="Every source file will be documented with an introductory comment that provides information on the file" id="COMMENT-03" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="7;" authUrg="0;" cat="COMMENT" desc="Document functions in comments that precede function definitions" id="COMMENT-04" sev="3" total="7"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Document functions in comments that precede function declarations" id="COMMENT-04_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="10;" authUrg="0;" cat="COMMENT" desc="Each variable declaration should be commented" id="COMMENT-05" sev="3" total="10"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Each typedef should be commented" id="COMMENT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Each enumeration value should be commented" id="COMMENT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Each structure member variable should be commented" id="COMMENT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="All usage of assembler shall be documented" id="COMMENT-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="Use of floating-point arithmetic shall be documented" id="COMMENT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="The character sequence // shall not be used within a C-style comment" id="COMMENT-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="COMMENT" desc="The character sequence /* shall not be used within a C++-style comment" id="COMMENT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="1;" cat="COMMENT" desc="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" id="COMMENT-14" sev="3" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="14;" authUrg="1;" cat="COMMENT" desc="Function parameters and return type should be documented in a comment that precedes the function declaration" id="COMMENT-14_b" sev="3" total="14"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid buffer overflow due to defining incorrect format limits" id="CWE-119-c" origId="BD-PB-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid overflow when reading from a buffer" id="CWE-119-d" origId="BD-PB-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid overflow when writing to a buffer" id="CWE-119-e" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid tainted data in array indexes" id="CWE-119-f" origId="BD-SECURITY-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Prevent buffer overflows from tainted data" id="CWE-119-g" origId="BD-SECURITY-BUFWRITE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid buffer read overflow from tainted data" id="CWE-119-h" origId="BD-SECURITY-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid buffer write overflow from tainted data" id="CWE-119-i" origId="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid accessing arrays out of bounds" id="CWE-119-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Avoid accessing arrays and pointers out of bounds" id="CWE-119-b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-119" desc="Suspicious use of 'strcpy' without checking size of source buffer" id="CWE-119-j" origId="CODSTA-143" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-119" desc="Ensure the output buffer is large enough when using path manipulation functions" id="CWE-119-k" origId="BD-PB-PATHBUF" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-125" desc="Avoid overflow when reading from a buffer" id="CWE-125-c" origId="BD-PB-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-125" desc="Avoid buffer read overflow from tainted data" id="CWE-125-d" origId="BD-SECURITY-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-125" desc="Avoid accessing arrays out of bounds" id="CWE-125-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-125" desc="Avoid accessing arrays and pointers out of bounds" id="CWE-125-b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-190" desc="Avoid wraparounds when performing arithmetic integer operations" id="CWE-190-a" origId="BD-PB-INTWRAP" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-190" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="CWE-190-b" origId="MISRA-048_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-190" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="CWE-190-c" origId="PB-65" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-190" desc="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="CWE-190-d" origId="PB-65_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-190" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="CWE-190-e" origId="PB-66_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-190" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="CWE-190-f" origId="PB-66_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-190" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="CWE-190-g" origId="PB-73" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Avoid tainted data in array indexes" id="CWE-20-a" origId="BD-SECURITY-ARRAY" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Protect against integer overflow/underflow from tainted data" id="CWE-20-b" origId="BD-SECURITY-INTOVERF" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Protect against command injection" id="CWE-20-d" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Avoid printing tainted data on the output console" id="CWE-20-e" origId="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Protect against environment injection" id="CWE-20-f" origId="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Exclude unsanitized user input from format strings" id="CWE-20-g" origId="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Protect against SQL injection" id="CWE-20-h" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Protect against file name injection" id="CWE-20-i" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-20" desc="Avoid passing unvalidated binary data to log methods" id="CWE-20-c" origId="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-20" desc="Untrusted data is used as a loop boundary" id="CWE-20-j" origId="SECURITY-38" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="CWE-200" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="CWE-200-a" origId="SECURITY-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-22" desc="Protect against file name injection" id="CWE-22-a" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-269" desc="Observe correct revocation order while relinquishing privileges" id="CWE-269-a" origId="SECURITY-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-269" desc="Ensure that privilege relinquishment is successful" id="CWE-269-b" origId="SECURITY-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-287" desc="Do not use weak encryption functions" id="CWE-287-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-326" desc="Do not use weak encryption functions" id="CWE-326-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-362" desc="Avoid race conditions when using fork and file descriptors" id="CWE-362-d" origId="BD-TRS-FORKFILE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-362" desc="Do not use global variable with different locks set" id="CWE-362-e" origId="BD-TRS-MLOCK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-362" desc="Usage of functions prone to race is not allowed" id="CWE-362-a" origId="SECURITY-19" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-362" desc="Avoid race conditions while accessing files" id="CWE-362-b" origId="BD-TRS-FRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-362" desc="Use locks to prevent race conditions when modifying bit fields" id="CWE-362-c" origId="BD-TRS-BITLOCK" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-400" desc="Do not create variables on the stack above the defined limits" id="CWE-400-a" origId="BD-RES-STACKLIM" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-415" desc="Do not use resources that have been freed" id="CWE-415-a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-416" desc="Do not use resources that have been freed" id="CWE-416-a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-416" desc="Do not point to a wrapped object that has been freed" id="CWE-416-b" origId="BD-PB-WRAPESC" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-416" desc="Freed memory shouldn't be accessed under any circumstances" id="CWE-416-c" origId="MRM-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-426" desc="Use care to ensure that LoadLibrary() will load the correct library" id="CWE-426-a" origId="SECURITY-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-476" desc="Avoid null pointer dereferencing" id="CWE-476-a" origId="BD-PB-NP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-476" desc="Do not check for null after dereferencing" id="CWE-476-b" origId="BD-PB-DEREF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-532" desc="Avoid passing sensitive data to functions that write to log files" id="CWE-532-a" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-611" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="CWE-611-a" origId="BD-SECURITY-XXEXRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-617" desc="Do not use assertions" id="CWE-617-a" origId="CODSTA-199" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="CWE-704-a" origId="CODSTA-124_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="Conversions shall not be performed between non compatible pointer to a function types" id="CWE-704-b" origId="CODSTA-124_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="CWE-704-c" origId="CODSTA-125" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="CWE-704-d" origId="CODSTA-126" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="CWE-704-g" origId="CODSTA-129_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="An implicit conversion shall not be performed between pointer to void and an arithmetic type" id="CWE-704-h" origId="CODSTA-129_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="CWE-704-i" origId="CODSTA-130" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="CWE-704-j" origId="MISRA-043" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="CWE-704-k" origId="MISRA-043_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="CWE-704-l" origId="MISRA-043_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="A conversion should not be performed between a pointer to object type and an integer type other than 'uintptr_t' or 'intptr_t'" id="CWE-704-e" origId="CODSTA-127_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-704" desc="A conversion should not be performed from pointer to void into pointer to object" id="CWE-704-f" origId="CODSTA-128" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-732" desc="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="CWE-732-b" origId="SECURITY-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-732" desc="Call 'umask' before calling 'mkstemp'" id="CWE-732-a" origId="SECURITY-40" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-770" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="CWE-770-a" origId="BD-SECURITY-TDALLOC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-772" desc="Ensure resources are freed" id="CWE-772-a" origId="BD-RES-LEAKS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-772" desc="Define a virtual destructor in classes used as base classes which have virtual functions" id="CWE-772-b" origId="OOP-22" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-78" desc="Protect against command injection" id="CWE-78-a" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Avoid buffer overflow due to defining incorrect format limits" id="CWE-787-c" origId="BD-PB-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Avoid overflow when writing to a buffer" id="CWE-787-d" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Prevent buffer overflows from tainted data" id="CWE-787-e" origId="BD-SECURITY-BUFWRITE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Avoid buffer write overflow from tainted data" id="CWE-787-f" origId="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Avoid accessing arrays out of bounds" id="CWE-787-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Avoid accessing arrays and pointers out of bounds" id="CWE-787-b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-787" desc="Ensure the output buffer is large enough when using path manipulation functions" id="CWE-787-g" origId="BD-PB-PATHBUF" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="CWE-798" desc="Do not hard code string literals" id="CWE-798-a" origId="CODSTA-203" sev="5" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-835" desc="Avoid infinite loops" id="CWE-835-a" origId="CODSTA-82" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="CWE-863" desc="Do not use 'cuserid' function" id="CWE-863-a" origId="SECURITY-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="CWE-89" desc="Protect against SQL injection" id="CWE-89-a" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="EXCEPT-01" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="EXCEPT" desc="Throw by value, catch by reference" id="EXCEPT-02" sev="1" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Do not throw from within destructor" id="EXCEPT-03" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="The assignment-expression of a throw statement shall not itself cause an exception to be thrown" id="EXCEPT-11" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="EXCEPT" desc="All exceptions should be rethrown or logged with standard logger" id="EXCEPT-04" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="1;" cat="EXCEPT" desc="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" id="EXCEPT-05" sev="2" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="EXCEPT" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="EXCEPT-06" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="EXCEPT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Exceptions shall be raised only after start-up and before termination of the program" id="EXCEPT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="An exception object should not have pointer type" id="EXCEPT-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Control shall not be transferred into a try or catch block using a goto or a switch statement" id="EXCEPT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="NULL shall not be thrown explicitly" id="EXCEPT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="EXCEPT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="EXCEPT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="EXCEPT" desc="A class type exception shall always be caught by reference" id="EXCEPT-15" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="EXCEPT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="EXCEPT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="EXCEPT-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Exception objects must be nothrow copy constructible" id="EXCEPT-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="An explicitly declared copy constructor for a class that inherits from 'std::exception' should have a non-throwing exception specification" id="EXCEPT-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="All user-provided move constructors and move assignment operators shall not exit with an exception" id="EXCEPT-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Checked exceptions that could be thrown from a function shall be specified in the comment directly before the function declaration" id="EXCEPT-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Do not use throw exception specifications" id="EXCEPT-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Where multiple handlers are provided in a single 'try-catch' statement or 'function-try-block', any ellipsis (catch-all) handler shall occur last" id="EXCEPT-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="EXCEPT" desc="Do not leave 'catch' blocks empty" id="EXCEPT-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="EXCEPT" desc="Avoid using catch-all exception handlers" id="EXCEPT-26" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="19;" authUrg="0;" cat="FORMAT" desc="Place an opening brace '{' on its own line" id="FORMAT-02" sev="3" total="19"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="FORMAT" desc="Place a closing brace '}' on its own line" id="FORMAT-03" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="FORMAT" desc="Physical lines should be less than eighty characters" id="FORMAT-04" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="The length of a macro should not exceed 10 lines" id="FORMAT-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Only one statement shall be allowed per line" id="FORMAT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="5;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character preceding assignment operators" id="FORMAT-07" sev="3" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character following assignment operators" id="FORMAT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character preceding bitwise operators" id="FORMAT-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character following bitwise operators" id="FORMAT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character preceding and following bitwise operator '&amp;'" id="FORMAT-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character between a conditional statement keyword and its opening parenthesis" id="FORMAT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a maximum of 1 ASCII space character following the opening parenthesis in conditional statements" id="FORMAT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character preceding ternary conditional operator" id="FORMAT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character following ternary conditional operator" id="FORMAT-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character preceding and following relational and equality operators" id="FORMAT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be no white space following '.' or '->' operator" id="FORMAT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be no white space preceding '.' or '->' operator" id="FORMAT-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character following all commas" id="FORMAT-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character following all semicolons" id="FORMAT-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There should be no space between a unary operator &quot;!&quot; or &quot;~&quot; and its operand" id="FORMAT-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There should be no space between a increment/decrement operator (++/--) and its operand" id="FORMAT-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be no white spaces between the 'return' statement or the 'sizeof' operator and the following opening parenthesis" id="FORMAT-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be no spaces after the opening '(' and before closing ')' parenthesis that enclose the operand of the 'return' statement or the 'sizeof' operator" id="FORMAT-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="The operand of the 'sizeof' operator should be enclosed in parentheses" id="FORMAT-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="FORMAT" desc="Parenthesis shall be used with the &quot;return&quot; statement" id="FORMAT-25_b" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be a single ASCII space character preceding and following logical operators" id="FORMAT-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="46;" authUrg="0;" cat="FORMAT" desc="Line should be indented by a multiple of four spaces" id="FORMAT-27" sev="3" total="46"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="1;" cat="FORMAT" desc="In a function definition, the return type of the function should be written on a separate line directly above the function name" id="FORMAT-28" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Multiple variable declarations shall not be allowed on the same line" id="FORMAT-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Place left parenthesis directly after function name" id="FORMAT-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Separate logical tests in conditional expressions" id="FORMAT-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Each variable should be declared in a separate declaration statement" id="FORMAT-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="18;" authUrg="0;" cat="FORMAT" desc="Braces &quot;{}&quot; which enclose a block should be placed in the same column" id="FORMAT-34" sev="3" total="18"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="When declaring functions, the leading parenthesis and the first argument are to be written on the same line as the function name" id="FORMAT-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Sibling statement lines should be indented to the same level" id="FORMAT-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="FORMAT" desc="First line in control statement body should be indented more than control statement keyword" id="FORMAT-37" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line" id="FORMAT-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="23;" authUrg="1;" cat="FORMAT" desc="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="FORMAT-42" sev="3" total="23"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="19;" authUrg="1;" cat="FORMAT" desc="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" id="FORMAT-43" sev="3" total="19"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Braces (&quot;{}&quot;) which enclose a block will not have an empty line after &quot;{&quot; nor before &quot;}&quot;" id="FORMAT-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There should be no space between a unary operator &quot;&amp;&quot;, &quot;*&quot;, &quot;+&quot;, &quot;-&quot; and its operand" id="FORMAT-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There should be no space between an increment/decrement operator (++/--) and its operand in macro definition" id="FORMAT-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="FORMAT" desc="Place CV-qualifiers on the right hand side of the type they apply to" id="FORMAT-47_a" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="CV-qualifiers shall be placed on the right hand side of the type that is a typedef or a using name" id="FORMAT-47_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Parameter names in function declarations should not be enclosed in parentheses" id="FORMAT-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Local variable names in variable declarations should not be enclosed in parentheses" id="FORMAT-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="FORMAT" desc="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" id="FORMAT-32" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="FORMAT" desc="Sort #include directives in alphabetical order" id="FORMAT-39" sev="4" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="Tabs that do not use ASCII spaces shall not be used" id="FORMAT-01" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="White spaces after the opening square bracket '[' and before its closing square bracket ']' shall be used in consistent way" id="FORMAT-40" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="FORMAT" desc="There shall be no space between '[' opening square bracket and preceding token" id="FORMAT-41" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="All declarations of an object or function shall have compatible types" id="GLOBAL-COMPATDECLS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="Do not use more than one mutex for concurrent waiting operations on a condition variable" id="GLOBAL-CONDMUTEXVAR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="GLOBAL-EXCSPECDECL" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="An inline function that is used in multiple translation units shall be defined in one and only one file" id="GLOBAL-ONEDEFINLINE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="The One Definition Rule shall not be violated" id="GLOBAL-ONEDEFRULE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="A function template that is used in multiple translation units shall be defined in one and only one file" id="GLOBAL-ONEDEFTEMPL" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="A type that is used in multiple translation units shall be defined in one and only one file" id="GLOBAL-ONEDEFTYPE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="GLOBAL" desc="An identifier with external linkage shall have no more then one external definition" id="GLOBAL-ONEEXTERNDEF" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="GLOBAL" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="GLOBAL-ONEFILEDECL" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="5;" authUrg="0;" cat="GLOBAL" desc="A project shall not contain non-volatile POD variables having only one use" id="GLOBAL-ONEUSEVAR" sev="3" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="The identifier name of a non-member object with static storage duration shall not be reused within a namespace" id="GLOBAL-REUSEDQUALGLOBVAR" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="The identifier name of a non-member static function shall not be reused within a namespace" id="GLOBAL-REUSEDQUALSTATFUN" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="All class templates, function templates, class template member functions and class template static members shall be instantiated at least one" id="GLOBAL-TEMPLNOINST" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="A class, union or enum name (including qualification, if any) shall be a unique identifier" id="GLOBAL-UNIQUETYPE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="A typedef name (including qualification, if any) shall be a unique identifier" id="GLOBAL-UNIQUETYPEDEF" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="Every defined function with external linkage shall be used at least once" id="GLOBAL-UNUSEDFUNC" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="A project shall not contain unused type declarations" id="GLOBAL-UNUSEDTYPE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="There shall be no unused parameters (named or unnamed) in the set of parameters for a virtual function and all the functions that override it" id="GLOBAL-UNUSEDVIRTPARAM" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="A base class shall only be declared virtual if it is used in a diamond hierarchy" id="GLOBAL-VIRTBASECLASS" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="GLOBAL" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="GLOBAL-AVOIDEXTERN" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-10_1_1" desc="For multiple inheritance use virtual common base class" id="HICPP-10_1_1-a" origId="OOP-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="HICPP-10_2_1" desc="Each overriding virtual function shall be declared with the override or final specifier" id="HICPP-10_2_1-a" origId="CODSTA-MCPP-05" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-10_3_1" desc="Ensure that a derived class has at most one base class which is not an interface class" id="HICPP-10_3_1-a" origId="OOP-07_c" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-11_1_1" desc="Avoid &quot;public&quot; data members" id="HICPP-11_1_1-a" origId="OOP-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="HICPP-11_1_1" desc="Avoid 'protected' data members" id="HICPP-11_1_1-b" origId="OOP-19" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-11_2_1" desc="Avoid using the friend mechanism" id="HICPP-11_2_1-a" origId="OOP-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_1_1" desc="Constructors allowing for conversion should be made explicit" id="HICPP-12_1_1-a" origId="CODSTA-CPP-04" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_1_1" desc="User-conversion cast operators should be made explicit" id="HICPP-12_1_1-b" origId="CODSTA-MCPP-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_2_1" desc="Make destructors virtual in base classes" id="HICPP-12_2_1-a" origId="OOP-24" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_3_1" desc="Write operator delete if you write operator new" id="HICPP-12_3_1-a" origId="MRM-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_3_1" desc="Write operator delete[] if you write operator new[]" id="HICPP-12_3_1-b" origId="MRM-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-12_4_1" desc="Do not use dynamic type of an object under construction" id="HICPP-12_4_1-b" origId="BD-PB-VCTOR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-12_4_1" desc="Do not use dynamic type of an object under destruction" id="HICPP-12_4_1-c" origId="BD-PB-VDTOR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_4_2" desc="All member variables should be initialized in constructor" id="HICPP-12_4_2-a" origId="INIT-06" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_4_3" desc="Do not specify both an NSDMI and a member initializer in a constructor for the same non-static member" id="HICPP-12_4_3-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_4_4" desc="List members in an initialization list in the order in which they are declared" id="HICPP-12_4_4-a" origId="INIT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_4_5" desc="Use delegating constructors to reduce code duplication" id="HICPP-12_4_5-a" origId="CODSTA-CPP-106" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="HICPP-12_5_1" desc="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" id="HICPP-12_5_1-a" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_5_2" desc="Define special members as =default when the behavior is equivalent to the compiler's behavior" id="HICPP-12_5_2-a" origId="CODSTA-CPP-105" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_5_3" desc="A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member" id="HICPP-12_5_3-a" origId="OOP-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_5_4" desc="All user-provided move constructors and move assignment operators shall not exit with an exception" id="HICPP-12_5_4-a" origId="EXCEPT-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_5_6" desc="User-defined copy and move assignment operators should use user-defined no-throw swap function" id="HICPP-12_5_6-a" origId="CODSTA-MCPP-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_5_7" desc="Declare assignment operators with the ref-qualifier &amp;" id="HICPP-12_5_7-a" origId="CODSTA-MCPP-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-12_5_8" desc="The copy assignment operator shall be declared protected or private in an abstract class" id="HICPP-12_5_8-a" origId="OOP-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_1_1" desc="Member functions declared in derived class should not hide functions declared in base classes" id="HICPP-13_1_1-a" origId="OOP-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_1_2" desc="Avoid Overloading on Forwarding References" id="HICPP-13_1_2-a" origId="CODSTA-MCPP-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_1" desc="Avoid overloading logical operators AND, OR (&amp;&amp;, ||)" id="HICPP-13_2_1-a" origId="CODSTA-CPP-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_1" desc="Avoid overloading comma operator &quot;,&quot;" id="HICPP-13_2_1-b" origId="CODSTA-CPP-80" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_2" desc="A relational operator shall return a boolean value" id="HICPP-13_2_2-a" origId="CODSTA-CPP-101" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_2" desc="A binary arithmetic operator and a bitwise operator shall return a 'prvalue'" id="HICPP-13_2_2-b" origId="CODSTA-CPP-102" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_3" desc="Declare binary arithmetic and bitwise operators as non-members" id="HICPP-13_2_3-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_4" desc="When overloading the subscript operator (operator[]), implement both const and non-const versions" id="HICPP-13_2_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-13_2_5" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="HICPP-13_2_5-a" origId="CODSTA-CPP-91" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-14_1_1" desc="Do not use functions with variable numbers of arguments" id="HICPP-14_1_1-a" origId="MISRA-069" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-14_2_1" desc="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="HICPP-14_2_1-a" origId="TEMPL-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-14_2_2" desc="Overloaded function templates shall not be explicitly specialized" id="HICPP-14_2_2-a" origId="TEMPL-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-14_2_3" desc="Declare 'extern' an explicitly instantiated template" id="HICPP-14_2_3-a" origId="TEMPL-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-15_1_1" desc="Only use instances of std::exception for exceptions" id="HICPP-15_1_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="1;" authUrg="0;" cat="HICPP-15_1_1" desc="Always throw the created std::exception object" id="HICPP-15_1_1-b" origId="BD-PB-STDEXC" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-15_2_1" desc="Do not throw from within destructor" id="HICPP-15_2_1-a" origId="EXCEPT-03" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-15_3_1" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference nonstatic members from this class or its bases" id="HICPP-15_3_1-a" origId="EXCEPT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-15_3_2" desc="Always catch exceptions" id="HICPP-15_3_2-a" origId="BD-PB-EXCEPT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-15_3_2" desc="Avoid throwing exceptions from functions that are declared not to throw" id="HICPP-15_3_2-c" origId="BD-PB-NOEXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="HICPP-15_3_2" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="HICPP-15_3_2-b" origId="EXCEPT-06" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-16_1_1" desc="Avoid using macro definitions" id="HICPP-16_1_1-a" origId="PREPROC-01" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_1" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="HICPP-16_1_1-b" origId="PREPROC-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-16_1_1" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="HICPP-16_1_1-c" origId="PREPROC-11" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_1" desc="Use multiple include guards" id="HICPP-16_1_1-d" origId="PFO-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-16_1_1" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="HICPP-16_1_1-e" origId="PREPROC-10_b" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-16_1_1" desc="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="HICPP-16_1_1-f" origId="PREPROC-10_c" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_1" desc="#error directive shall not be used" id="HICPP-16_1_1-g" origId="PREPROC-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_1" desc="The #pragma directive shall not be used" id="HICPP-16_1_1-h" origId="PREPROC-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_1" desc="#undef shall not be used" id="HICPP-16_1_1-i" origId="PREPROC-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_2" desc="Do not allow absolute or relative path names in #include statements" id="HICPP-16_1_2-a" origId="PREPROC-06" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_2" desc="The \ character should not occur in a header file name" id="HICPP-16_1_2-b" origId="NAMING-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_3" desc="Match the filename in a #include directive to the one on the filesystem" id="HICPP-16_1_3-a" origId="PREPROC-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-16_1_4" desc="Use &lt;> brackets for system and standard library headers. Use quotes for all other headers" id="HICPP-16_1_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" authTot="0;" authUrg="0;" cat="HICPP-16_1_5" desc="Avoid duplication of #include directives" id="HICPP-16_1_5-a" origId="CDD-DUPI" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_1_1" desc="Avoid using vector&lt;bool>" id="HICPP-17_1_1-a" origId="STL-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_2_1" desc="The error indicator 'errno' shall not be used" id="HICPP-17_2_1-b" origId="MISRA2004-20_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-17_2_1" desc="Wrap use of the C Standard Library" id="HICPP-17_2_1-a" sev="4" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_3_1" desc="Do not use std::move on objects declared with the const or const &amp; type" id="HICPP-17_3_1-a" origId="CODSTA-MCPP-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_3_2" desc="The 'std::forward' function should be used to forward forwarding references" id="HICPP-17_3_2-a" origId="CODSTA-MCPP-13_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-17_3_3" desc="Do not subsequently use the argument to std::forward" id="HICPP-17_3_3-a" origId="BD-PB-SUBSEQFRWD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_3_4" desc="Do not create smart pointers of array type" id="HICPP-17_3_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_3_5" desc="Do not create an rvalue reference of std::array" id="HICPP-17_3_5-a" origId="CODSTA-MCPP-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_4_1" desc="Use const container calls when the result is immediately converted to a const iterator" id="HICPP-17_4_1-a" origId="CODSTA-MCPP-51" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_4_2" desc="Prefer 'std::make_shared' to the direct use of new" id="HICPP-17_4_2-a" origId="CODSTA-MCPP-16_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-17_5_1" desc="Follow remove-like algorithms by erase to remove elements from a container" id="HICPP-17_5_1-a" origId="STL-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_1_1" desc="Do not use platform-specific multi-threading facilities" id="HICPP-18_1_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_2_1" desc="Use high_integrity::thread in place of std::thread" id="HICPP-18_2_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-18_2_2" desc="Do not use global variable with different locks set" id="HICPP-18_2_2-a" origId="BD-TRS-MLOCK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-18_2_2" desc="Make const member functions thread-safe" id="HICPP-18_2_2-b" origId="BD-TRS-CMF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_2_3" desc="Do not share volatile data between threads" id="HICPP-18_2_3-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_2_4" desc="Use std::call_once rather than the Double-Checked Locking pattern" id="HICPP-18_2_4-a" origId="CODSTA-MCPP-55" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-18_3_1" desc="Avoid double locking" id="HICPP-18_3_1-a" origId="BD-TRS-DLOCK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-18_3_2" desc="Do not acquire locks in different order" id="HICPP-18_3_2-a" origId="BD-TRS-ORDER" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_3_3" desc="Do not use std::recursive_mutex" id="HICPP-18_3_3-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_3_4" desc="Only use std::unique lock when std::lock guard cannot be used" id="HICPP-18_3_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_3_5" desc="Do not access the members of std::mutex directly" id="HICPP-18_3_5-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_3_6" desc="Do not use relaxed atomics" id="HICPP-18_3_6-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-18_4_1" desc="Do not use std::condition_variable_any on a std::mutex" id="HICPP-18_4_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="Avoid conditions that always evaluate to the same value" id="HICPP-1_2_1-i" origId="BD-PB-CC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="Avoid switch with unreachable branches" id="HICPP-1_2_1-j" origId="BD-PB-SWITCH" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="HICPP-1_2_1-a" origId="MISRA2004-14_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="HICPP-1_2_1-b" origId="MISRA2004-14_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="HICPP-1_2_1-c" origId="MISRA2004-14_1_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code in switch statement" id="HICPP-1_2_1-d" origId="MISRA2004-14_1_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code in 'for' loop" id="HICPP-1_2_1-e" origId="MISRA2004-14_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="HICPP-1_2_1-f" origId="MISRA2004-14_1_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="HICPP-1_2_1-g" origId="MISRA2004-14_1_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="7;" authUrg="0;" cat="HICPP-1_2_1" desc="Avoid unreachable methods" id="HICPP-1_2_1-h" origId="BD-PB-UCMETH" sev="4" total="7"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_2_2" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="HICPP-1_2_2-a" origId="MISRA2004-14_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_3_1" desc="Do not use the increment operator (++) on an operand of type 'bool'" id="HICPP-1_3_1-a" origId="CODSTA-MCPP-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_3_2" desc="The 'register' storage class specifier shall not be used" id="HICPP-1_3_2-a" origId="MISRA-028" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-1_3_3" desc="The C library shall not be used" id="HICPP-1_3_3-a" origId="CODSTA-CPP-59" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_3_4" desc="Do not use deprecated STL library features" id="HICPP-1_3_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-1_3_5" desc="Do not use throw exception specifications" id="HICPP-1_3_5-a" origId="EXCEPT-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_1_1" desc="Tabs that do not use ASCII spaces shall not be used" id="HICPP-2_1_1-a" origId="FORMAT-01" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_2_1" desc="Do not use the following digraphs: &lt;%, %>, &lt;:, :>, %:, %:%:" id="HICPP-2_2_1-a" origId="CODSTA-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_2_1" desc="Trigraphs shall not be used" id="HICPP-2_2_1-b" origId="MISRA2004-4_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_3_1" desc="Prefer C++ style comment" id="HICPP-2_3_1-a" origId="COMMENT-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_3_2" desc="Do not use comments to remove sections of code" id="HICPP-2_3_2-a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-2_4_1" desc="Different identifiers shall be typographically unambiguous" id="HICPP-2_4_1-a" origId="NAMING-47" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_5_1" desc="String literals with different encoding prefixes shall not be concatenated" id="HICPP-2_5_1-a" origId="PB-38_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_5_2" desc="Octal constants (other than zero) shall not be used" id="HICPP-2_5_2-a" origId="MISRA2004-7_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-2_5_3" desc="Prefer 'nullptr' over 'NULL' or '0'(zero)" id="HICPP-2_5_3-a" origId="CODSTA-MCPP-04" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_1_1" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="HICPP-3_1_1-a" origId="MISRA2004-5_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_1_1" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="HICPP-3_1_1-b" origId="MISRA2004-5_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_1_1" desc="Identifiers declared in a local scope should not hide identifiers declared in a class scope" id="HICPP-3_1_1-c" origId="CODSTA-CPP-83" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_1_1" desc="Identifiers declared in a class scope should not hide identifiers declared in a global or namespace scope" id="HICPP-3_1_1-d" origId="CODSTA-CPP-84" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_1_1" desc="Identifiers declared in an inner class scope should not hide identifiers declared in outer class scope" id="HICPP-3_1_1-e" origId="CODSTA-CPP-85" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_2_1" desc="Always declare functions at file scope" id="HICPP-3_2_1-a" origId="MISRA2004-8_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_3_1" desc="Do not use variables with static storage duration" id="HICPP-3_3_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_4_1" desc="The address of an object with automatic storage shall not be returned from a function" id="HICPP-3_4_1-a" origId="MISRA2004-17_6_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_4_2" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="HICPP-3_4_2-a" origId="MISRA2004-17_6_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_4_3" desc="Prefer smart pointers over raw local pointers" id="HICPP-3_4_3-a" origId="CODSTA-MCPP-20" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_4_3" desc="Do not call lock() directly on a mutex" id="HICPP-3_4_3-b" origId="CODSTA-MCPP-21" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_4_3" desc="Use RAII to prevent resource leaks" id="HICPP-3_4_3-c" origId="MRM-52" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-3_5_1" desc="Do not subtract two pointers that do not address elements of the same array" id="HICPP-3_5_1-c" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-3_5_1" desc="Do not compare two unrelated pointers" id="HICPP-3_5_1-d" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-3_5_1" desc="Unions shall not be used" id="HICPP-3_5_1-a" origId="MISRA2004-18_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="HICPP-3_5_1" desc="typedefs should be used in place of the basic types" id="HICPP-3_5_1-b" origId="MISRA2004-6_3_b" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_1_1" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="HICPP-4_1_1-a" origId="PB-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-4_1_1" desc="Do not pass an expression with array type to a function with a pointer or array type parameter" id="HICPP-4_1_1-b" origId="PB-41_b" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_2_1" desc="Apply the U suffix to literals used in a context that requires an unsigned integral expression" id="HICPP-4_2_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-4_2_2" desc="Avoid incorrect shift operations" id="HICPP-4_2_2-f" origId="BD-PB-BADSHIFT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_2_2" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="HICPP-4_2_2-a" origId="MISRA2004-12_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_2_2" desc="Avoid explicit type conversions (casts)" id="HICPP-4_2_2-b" origId="CODSTA-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_2_2" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="HICPP-4_2_2-c" origId="PB-66_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-4_2_2" desc="Avoid wraparounds when performing arithmetic integer operations" id="HICPP-4_2_2-e" origId="BD-PB-INTWRAP" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_2_2" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="HICPP-4_2_2-d" origId="PB-66_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_3_1" desc="Avoid implicit conversions from wider to narrower floating type" id="HICPP-4_3_1-a" origId="MISRA2004-10_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_3_1" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="HICPP-4_3_1-b" origId="MISRA2004-10_2_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-4_4_1" desc="Avoid implicit conversions from floating to integral type" id="HICPP-4_4_1-a" origId="MISRA2004-10_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="HICPP-5_1_1" desc="Avoid magic numbers" id="HICPP-5_1_1-a" origId="CODSTA-26" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of function arguments" id="HICPP-5_1_2-b" origId="MISRA2004-12_2_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="HICPP-5_1_2-a" origId="MISRA2004-12_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="HICPP-5_1_2-c" origId="MISRA2004-12_2_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="HICPP-5_1_2-d" origId="MISRA2004-12_2_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="HICPP-5_1_2-e" origId="MISRA2004-12_2_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="Do not use more than one volatile between two adjacent sequence points" id="HICPP-5_1_2-f" origId="MISRA2004-12_2_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="Don't write code that depends on the order of evaluation of function calls" id="HICPP-5_1_2-g" origId="MISRA2004-12_2_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="The increment (++) and decrement (--) operators should not be mixed with other operators in an expression" id="HICPP-5_1_2-h" origId="MISRA2004-12_13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="The comma operator shall not be used" id="HICPP-5_1_2-i" origId="MISRA2004-12_10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_2" desc="The result of a built-in assignment operator should not be used" id="HICPP-5_1_2-j" origId="CODSTA-138" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_3" desc="Use parentheses unless all operators in the expression are the same" id="HICPP-5_1_3-a" origId="MISRA2004-12_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_3" desc="The operands of a logical &amp;&amp; or || shall be primary-expressions" id="HICPP-5_1_3-b" origId="MISRA2004-12_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_4" desc="Do not capture variables implicitly in a lambda" id="HICPP-5_1_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_5" desc="Include a parameter list in every lambda expression" id="HICPP-5_1_5-a" origId="CODSTA-MCPP-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_6" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="HICPP-5_1_6-a" origId="MISRA2004-12_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_6" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="HICPP-5_1_6-b" origId="MISRA2004-12_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_6" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="HICPP-5_1_6-c" origId="MISRA2004-12_3_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_6" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="HICPP-5_1_6-d" origId="MISRA2004-12_4_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_6" desc="The operand of the 'typeid' operator shall not contain any expression that has side effects" id="HICPP-5_1_6-e" origId="CODSTA-CPP-104" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_1_6" desc="The operand of the 'typeid' operator shall not contain a function call that causes side effects" id="HICPP-5_1_6-f" origId="CODSTA-CPP-104_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-5_2_1" desc="Avoid null pointer dereferencing" id="HICPP-5_2_1-c" origId="BD-PB-NP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-5_2_1" desc="Avoid accessing arrays out of bounds" id="HICPP-5_2_1-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-5_2_1" desc="Avoid accessing arrays and pointers out of bounds" id="HICPP-5_2_1-b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_2_2" desc="Functions shall not call themselves, either directly or indirectly" id="HICPP-5_2_2-a" origId="MISRA2004-16_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-5_2_2" desc="Do not use recursion" id="HICPP-5_2_2-b" origId="BD-PB-RECFUN" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_3_1" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="HICPP-5_3_1-a" origId="MISRA2004-12_9" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_3_2" desc="Do not use calloc, malloc, realloc and free functions" id="HICPP-5_3_2-a" origId="MRM-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-5_3_3" desc="Properly deallocate dynamically allocated resources" id="HICPP-5_3_3-c" origId="BD-RES-BADDEALLOC" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_3_3" desc="Never provide brackets ([]) for delete when deallocating non-arrays" id="HICPP-5_3_3-a" origId="MRM-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_3_3" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="HICPP-5_3_3-b" origId="MRM-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_4_1" desc="C-style casts should not be used" id="HICPP-5_4_1-a" origId="CODSTA-CPP-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_4_1" desc="Avoid using reinterpret_cast" id="HICPP-5_4_1-b" origId="CODSTA-CPP-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_4_1" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="HICPP-5_4_1-c" origId="MISRA2004-11_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_4_2" desc="Do not cast an expression to an enumeration type" id="HICPP-5_4_2-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_4_3" desc="Down casting (casting from base to derived class) shall not be allowed" id="HICPP-5_4_3-a" origId="OOP-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-5_5_1" desc="Avoid division by zero" id="HICPP-5_5_1-a" origId="BD-PB-ZERO" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_6_1" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="HICPP-5_6_1-a" origId="CODSTA-63" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_7_1" desc="Floating-point expressions shall not be tested for equality or inequality" id="HICPP-5_7_1-a" origId="MISRA2004-13_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_7_2" desc="A pointer to member virtual function shall only be tested for equality with null-pointer-constant" id="HICPP-5_7_2-a" origId="CODSTA-MCPP-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-5_8_1" desc="The conditional operator should not be used as a sub-expression" id="HICPP-5_8_1-a" origId="CODSTA-224" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_1_1" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="HICPP-6_1_1-a" origId="MISRA2004-14_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="HICPP-6_1_1" desc="'if' and 'else' should be followed by a compound statement" id="HICPP-6_1_1-b" origId="MISRA2004-14_9" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_1_2" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="HICPP-6_1_2-a" origId="MISRA2004-14_10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_1_2" desc="The final clause of a switch statement shall be the default clause" id="HICPP-6_1_2-b" origId="MISRA2004-15_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_1_3" desc="Every switch branch should be unconditionally terminated" id="HICPP-6_1_3-a" origId="CODSTA-64_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_1_4" desc="Every switch statement will have at least two cases and a potential default" id="HICPP-6_1_4-a" origId="CODSTA-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_1_4" desc="A switch expression shall not represent a value that is effectively Boolean" id="HICPP-6_1_4-b" origId="MISRA2004-15_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_2_1" desc="A for-loop that loops through all elements of the container and does not use its loop-counter shall not be used" id="HICPP-6_2_1-a" origId="CODSTA-MCPP-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_2_2" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="HICPP-6_2_2-a" origId="CODSTA-168" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_2_3" desc="Do not modify for loop counter within a body of the loop" id="HICPP-6_2_3-a" origId="MISRA2004-13_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_2_4" desc="The third clause of a 'for' statement shall be well-formed" id="HICPP-6_2_4-a" origId="CODSTA-169_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_3_1" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="HICPP-6_3_1-a" origId="MISRA2004-15_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_3_1" desc="The goto statement shall jump to a label declared later in the same function body" id="HICPP-6_3_1-b" origId="CODSTA-77" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_3_1" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="HICPP-6_3_1-c" origId="CODSTA-78" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-6_3_2" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="HICPP-6_3_2-a" origId="MISRA2004-16_8_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-6_4_1" desc="Declare variables as locally as possible" id="HICPP-6_4_1-a" origId="OPT-01" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-6_4_1" desc="Postpone variable definitions as long as possible" id="HICPP-6_4_1-b" origId="OPT-20" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_1" desc="Multiple variable declarations shall not be allowed on the same line" id="HICPP-7_1_1-a" origId="FORMAT-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_1" desc="Each variable should be declared in a separate declaration statement" id="HICPP-7_1_1-b" origId="FORMAT-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_10" desc="Use static_assert for assertions involving compile time constants" id="HICPP-7_1_10-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="1;" cat="HICPP-7_1_2" desc="Declare local variable as const whenever possible" id="HICPP-7_1_2-a" origId="CODSTA-CPP-53" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_3" desc="Do not place type specifiers before non-type specifiers in a declaration" id="HICPP-7_1_3-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="HICPP-7_1_4" desc="Place CV-qualifiers on the right hand side of the type they apply to" id="HICPP-7_1_4-a" origId="FORMAT-47_a" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="HICPP-7_1_5" desc="Do not inline large functions" id="HICPP-7_1_5-a" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_6" desc="The plain char type shall be used only for the storage and use of character values" id="HICPP-7_1_6-a" origId="MISRA2004-6_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="HICPP-7_1_6" desc="Use class types or typedefs to abstract scalar quantities and standard integer types" id="HICPP-7_1_6-b" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_6" desc="Use class types or typedefs to abstract scalar quantities and standard integer types" id="HICPP-7_1_6-c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_7" desc="Use a trailing return type syntax if the return type is preceded by the 'typename' keyword" id="HICPP-7_1_7-a" origId="TEMPL-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="10;" authUrg="0;" cat="HICPP-7_1_8" desc="Use auto id = expr when declaring a variable that is the same type as the initializer function call" id="HICPP-7_1_8-a" sev="3" total="10"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_1_9" desc="Do not explicitly specify the return type of a lambda" id="HICPP-7_1_9-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_2_1" desc="Use an explicit enumeration base and ensure that it is large enough to store all enumerators" id="HICPP-7_2_1-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_2_2" desc="Initialize all, only the first, or none of the enumerators in an enumeration" id="HICPP-7_2_2-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="HICPP-7_3_1" desc="using-directives shall not be used" id="HICPP-7_3_1-a" origId="CODSTA-CPP-75" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_4_1" desc="Do not use static keyword except inside functions and classes" id="HICPP-7_4_1-a" origId="CODSTA-CPP-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="HICPP-7_4_2" desc="An inline function that is used in multiple translation units shall be defined in one and only one file" id="HICPP-7_4_2-a" origId="GLOBAL-ONEDEFINLINE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="HICPP-7_4_2" desc="A function template that is used in multiple translation units shall be defined in one and only one file" id="HICPP-7_4_2-b" origId="GLOBAL-ONEDEFTEMPL" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="HICPP-7_4_2" desc="A type that is used in multiple translation units shall be defined in one and only one file" id="HICPP-7_4_2-c" origId="GLOBAL-ONEDEFTYPE" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="HICPP-7_4_3" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="HICPP-7_4_3-a" origId="GLOBAL-ONEFILEDECL" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-7_5_1" desc="The 'asm' declaration should not be used" id="HICPP-7_5_1-a" origId="CODSTA-234" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_1_1" desc="The declaration should not contain more than one level of pointer indirection" id="HICPP-8_1_1-a" origId="CODSTA-89" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_2_1" desc="The identifiers used in the declaration and definition of a function shall be identical" id="HICPP-8_2_1-a" origId="MISRA2004-16_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_2_2" desc="Avoid functions with more than 5 parameters" id="HICPP-8_2_2-a" origId="METRICS-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_2_3" desc="Pass small objects with a trivial copy constructor by value" id="HICPP-8_2_3-a" origId="CODSTA-CPP-108_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_2_4" desc="Do not pass std::unique_ptr by const reference" id="HICPP-8_2_4-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_3_1" desc="Follow the Cyclomatic Complexity limit of 10" id="HICPP-8_3_1-a" origId="METRICS-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_3_3" desc="Do not use default arguments" id="HICPP-8_3_3-a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_3_4" desc="Define =delete functions with parameters of type rvalue reference to const" id="HICPP-8_3_4-a" origId="CODSTA-MCPP-61" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-8_4_1" desc="Avoid use before initialization" id="HICPP-8_4_1-a" origId="BD-PB-NOTINIT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="HICPP-8_4_1" desc="Do not use resources that have been freed" id="HICPP-8_4_1-b" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_4_1" desc="All automatic variables shall have been assigned a value before being used" id="HICPP-8_4_1-c" origId="MISRA-030" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-8_4_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="HICPP-8_4_2-a" origId="INIT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-9_1_1" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="HICPP-9_1_1-a" origId="CODSTA-CPP-78" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-9_1_2" desc="Do not redefine an inherited virtual function with a different default parameter value" id="HICPP-9_1_2-a" origId="OOP-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-9_1_3" desc="Const member functions shall not return non-const pointers or references to class-data" id="HICPP-9_1_3-a" origId="CODSTA-CPP-77" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-9_1_4" desc="Public member functions shall not return non-const handles to private/protected class-data" id="HICPP-9_1_4-a" origId="OOP-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-9_1_5" desc="Do not introduce virtual functions in a final class" id="HICPP-9_1_5-a" origId="CODSTA-MCPP-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="HICPP-9_2_1" desc="Bit-fields shall have explicitly unsigned integral or enumeration types only" id="HICPP-9_2_1-a" origId="CODSTA-96" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Do not initialize a reference to an object whose address can be changed" id="INIT-05" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="All member variables should be initialized in constructor" id="INIT-06" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Initialize static class members" id="INIT-09" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Do not use uninitialized nonstatic member variables in base class constructors" id="INIT-13_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Do not use uninitialized nonstatic member variables of nonvirtual base classes in virtual base class constructors" id="INIT-13_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Initialize all pointer variables" id="INIT-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="An assignment operator shall assign all data members" id="INIT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Objects with external linkage should not be initialized in a header file" id="INIT-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Do not initialize unsigned integer variables with signed constants" id="INIT-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Initialize all variables" id="INIT-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Make class members' initialization explicit by providing user-defined constructor" id="INIT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="User-defined constructor must be provided to ensure the proper initialization of dynamically allocated class objects" id="INIT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="List members in an initialization list in the order in which they are declared" id="INIT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Avoid initialization order problems across translation units by replacing non-local static objects with local static objects" id="INIT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Do not assume that members are initialized in any special order in constructors" id="INIT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Do not use possibly uninitialized nonstatic member variables of base classes in base class constructors" id="INIT-13_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="The initializer for an aggregate or union shall be enclosed in braces" id="INIT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="The data members initialized with the same constant values across all constructors should be initialized using NSDMI" id="INIT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Consider adding constructor to initialize 'struct' member variables" id="INIT-15" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="INIT" desc="Prefer initialization to assignment in constructors" id="INIT-14" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All functions shall have a cyclomatic complexity number of 20 or less" id="JSF-003" origId="METRICS-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Follow the Essential Complexity limit of 1" id="JSF-003_b" origId="METRICS-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Capital 'L' shall be used instead of lowercase 'l' to indicate long" id="JSF-014" origId="PORT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Ensure that array indices are within the bounds of the array" id="JSF-015" origId="MISRA-004_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The error indicator 'errno' shall not be used" id="JSF-017" origId="MISRA2004-20_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The macro 'offsetof', in library &lt;stddef.h>, shall not be used" id="JSF-018" origId="MISRA2004-20_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="'setlocale' function shall not be used" id="JSF-019" origId="MISRA-121_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="&lt;locale.h> shall not be used" id="JSF-019_b" origId="MISRA-121_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The 'setjmp' macro and the 'longjmp' function shall not be used" id="JSF-020" origId="MISRA2004-20_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The standard header file &lt;setjmp.h> shall not be used" id="JSF-020_b" origId="MISRA2004-20_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The standard header file &lt;signal.h> shall not be used" id="JSF-021" origId="MISRA2004-20_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="JSF-021_b" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="The input/output library &lt;stdio.h> shall not be used" id="JSF-022" origId="PREPROC-18" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="The library functions atof, atoi and atol from library &lt;stdlib.h> shall not be used" id="JSF-023" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The library function 'abort' of &lt;stdlib.h> shall not be used" id="JSF-024" origId="PB-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The library function 'exit' of &lt;stdlib.h> shall not be used" id="JSF-024_b" origId="PB-75_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The library function 'getenv' of &lt;stdlib.h> shall not be used" id="JSF-024_c" origId="SECURITY-52" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The library function 'system' of &lt;stdlib.h> shall not be used" id="JSF-024_d" origId="SECURITY-48_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The time handling functions of library &lt;time.h> shall not be used" id="JSF-025" origId="MISRA2004-20_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="JSF-026" origId="PREPROC-11" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="The #if preprocessor directive should not be used" id="JSF-026_b" origId="PREPROC-11_b" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="#error directive shall not be used" id="JSF-026_c" origId="PREPROC-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The #pragma directive shall not be used" id="JSF-026_d" origId="PREPROC-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="#undef shall not be used" id="JSF-026_e" origId="PREPROC-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The #define pre-processor directive shall not be used to create inline macros" id="JSF-029" origId="MISRA2004-19_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The #define pre-processor directive shall not be used to define constant values" id="JSF-030" origId="CODSTA-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="20;" authUrg="0;" cat="JSF" desc="The #include directive shall use the &lt;filename.h> notation to include header files" id="JSF-033" origId="PREPROC-09" sev="2" total="20"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="User-specified C++ external identifiers should differ in the first 64 characters" id="JSF-046_a" origId="PORT-34_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="User-specified C++ internal identifiers should differ from external identifiers in the first 64 characters" id="JSF-046_b" origId="PORT-34_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="User-specified C++ internal identifiers declared in the same scope should differ in the first 64 characters" id="JSF-046_c" origId="PORT-34_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="Identifiers for constant and enumerator values shall be lowercase" id="JSF-052" origId="NAMING-42" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The following character sequences shall not appear in header file names: ', \, /*, //, or &quot; " id="JSF-053.1" origId="PB-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The statements forming the body of a 'while', 'do...while', 'switch' or 'for' statement shall always be enclosed in braces" id="JSF-059_a" origId="MISRA2004-14_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="JSF" desc="The statements forming the body of an 'if', 'else if' or 'else' statement shall always be enclosed in braces" id="JSF-059_b" origId="MISRA2004-14_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Declare both private copy constructor and copy assignment operator at the same time" id="JSF-068" origId="MRM-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Freed memory shall not be accessed under any circumstances" id="JSF-070.1" origId="MRM-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Destructor shall not be called manually" id="JSF-070.1_b" origId="MRM-31_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Public and protected methods shall not be invoked by class constructor" id="JSF-071" origId="PB-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A class's virtual functions shall not be invoked from any of its constructors" id="JSF-071.1" origId="OOP-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A class's virtual functions shall not be invoked from its destructor" id="JSF-071.1_b" origId="OOP-16_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All member variables shall be initialized in constructor" id="JSF-071_b" origId="INIT-06" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A class's virtual functions shall not be invoked from any of its constructors" id="JSF-071_c" origId="OOP-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Uninitialized nonstatic member variables shall not be used in base class constructors" id="JSF-071_d" origId="INIT-13_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Uninitialized nonstatic member variables of nonvirtual base classes shall not be used in virtual base class constructors" id="JSF-071_e" origId="INIT-13_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Possibly uninitialized nonstatic member variables of base classes shall not be used in base class constructors" id="JSF-071_f" origId="INIT-13_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Members of the initialization list shall be listed in the order in which they are declared in the class" id="JSF-075" origId="INIT-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A copy constructor and a copy assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors" id="JSF-076" origId="MRM-49" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A copy constructor shall copy all data members and bases" id="JSF-077" origId="MRM-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor" id="JSF-077.1" origId="PB-24" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All base classes with a virtual function shall define a virtual destructor" id="JSF-078" origId="OOP-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Call fclose() on pointer member in destructor if the pointer was used to open a file" id="JSF-079" origId="MRM-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Call delete on pointer members in destructors" id="JSF-079_b" origId="MRM-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The assignment operator shall handle self-assignment correctly" id="JSF-081" origId="OOP-34" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An assignment operator shall return a reference to *this" id="JSF-082" origId="CODSTA-CPP-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An assignment operator shall assign all data members" id="JSF-083_a" origId="INIT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An assignment operator shall assign all data bases" id="JSF-083_b" origId="MRM-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Multiple inheritance shall be limited to at most 1 protected implementation" id="JSF-088" origId="OOP-07_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A stateful virtual base shall be explicitly declared in each derived class that accesses it" id="JSF-088.1" origId="OOP-39_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Multiple inheritance shall not use any public implementations" id="JSF-088_b" origId="OOP-07_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A base class shall not be both virtual and non-virtual in the same hierarchy" id="JSF-089" origId="OOP-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An inherited nonvirtual function shall not be redefined in a derived class" id="JSF-094" origId="OOP-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Member functions declared in derived class shall not hide functions declared in base classes" id="JSF-094_b" origId="OOP-53" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An inherited default parameter shall never be redefined" id="JSF-095" origId="OOP-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Arrays shall not be treated polymorphically" id="JSF-096" origId="PB-57" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Arrays shall not be used in interfaces" id="JSF-097" origId="CODSTA-CPP-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Neither operand of an equality operator (== or !=) shall be a pointer to a virtual member function" id="JSF-097.1" origId="CODSTA-CPP-79" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Arrays shall not be used in private or protected methods" id="JSF-097_b" origId="CODSTA-CPP-55_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="Arrays shall not be used in global functions" id="JSF-097_c" origId="CODSTA-142" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="Arrays shall not be passed to functions as array/pointer parameters" id="JSF-097_d" origId="PB-41_b" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Functions which are called with array argument shall not be declared with pointer parameter" id="JSF-097_e" origId="CODSTA-142_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Functions shall always be declared at file scope" id="JSF-107" origId="MISRA2004-8_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Functions with variable numbers of arguments shall not be used" id="JSF-108" origId="MISRA-069" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A function shall not return a pointer or reference to a non-static local object" id="JSF-111" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A function shall not return a pointer or a reference to a parameter that is passed by const reference" id="JSF-111_a" origId="PB-39_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All exit points of value-returning functions shall be through return statements" id="JSF-114" origId="MISRA2004-16_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Functions shall not call themselves, either directly or indirectly" id="JSF-119" origId="MISRA2004-16_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Only valid C++ style comments (//) shall be used" id="JSF-126" origId="COMMENT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Code that is not used (commented out) shall be deleted" id="JSF-127" origId="MISRA2004-2_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="JSF-135_a" origId="MISRA2004-5_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifiers declared in an inner local scope shall not hide identifiers declared in an outer local scope" id="JSF-135_b" origId="MISRA2004-5_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifiers declared in a local scope shall not hide identifiers declared in a class scope" id="JSF-135_c" origId="CODSTA-CPP-83" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifiers declared in a class scope shall not hide identifiers declared in a global or namespace scope" id="JSF-135_d" origId="CODSTA-CPP-84" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifiers declared in an inner class scope shall not hide identifiers declared in outer class scope" id="JSF-135_e" origId="CODSTA-CPP-85" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="JSF-138_a" origId="MISRA-024" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="JSF-138_b" origId="MISRA2004-8_11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The register storage class specifier shall not be used" id="JSF-140" origId="MISRA-028" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All automatic variables shall have been assigned a value before being used" id="JSF-142_a" origId="MISRA-030" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All variables shall be initialized before use" id="JSF-142_b" origId="INIT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures" id="JSF-144" origId="INIT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="In an enumerator list, the '=' construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized" id="JSF-145" origId="MISRA2004-9_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The underlying bit representations of floating point numbers shall not be used in any way by the programmer" id="JSF-147" origId="MISRA-016" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Enumeration types shall be used instead of integer types (and constants) to select from a limited series of choices" id="JSF-148" origId="CODSTA-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Octal constants (other than zero) shall not be used" id="JSF-149" origId="MISRA2004-7_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A string literal shall not be modified" id="JSF-151.1" origId="PB-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Multiple variable declarations shall not be allowed on the same line" id="JSF-152" origId="FORMAT-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Unions shall not be used" id="JSF-153" origId="MISRA2004-18_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Bit-fields shall have explicitly unsigned integral or enumeration types only" id="JSF-154" origId="CODSTA-96" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All the members of a structure (or class) shall be named" id="JSF-156" origId="MISRA-113" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The right hand operand of a &amp;&amp; or || operator shall not contain side effects" id="JSF-157" origId="MISRA2004-12_4_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The operands of a logical &amp;&amp; or || shall be parenthesized if the operands contain binary operators" id="JSF-158" origId="CODSTA-104" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Operators ||, &amp;&amp; shall not be overloaded" id="JSF-159" origId="CODSTA-CPP-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Operator unary &amp; shall not be overloaded" id="JSF-159_b" origId="CODSTA-CPP-68" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An assignment expression shall be used only as the expression in an expression statement" id="JSF-160" origId="MISRA2004-13_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Signed and unsigned values shall not be mixed in comparison operations" id="JSF-162_a" origId="CODSTA-99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Signed and unsigned values shall not be mixed in second and third operand of conditional operator" id="JSF-162_b" origId="CODSTA-101" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Signed and unsigned values shall not be mixed in arithmetic operations" id="JSF-162_c" origId="CODSTA-100" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Unsigned arithmetic shall not be used" id="JSF-163" origId="PB-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="JSF" desc="The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the left-hand operand" id="JSF-164" origId="BD-PB-BADSHIFT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="JSF-164.1" origId="PB-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The unary minus operator shall not be applied to an unsigned expression" id="JSF-165" origId="MISRA2004-12_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Don't assign the dividend of two integers to a floating-point type" id="JSF-167_a" origId="PB-15" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The comma operator shall not be used" id="JSF-168_b" origId="MISRA2004-12_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="More than 2 levels of pointer indirection shall not be used" id="JSF-170" origId="MISRA-102" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="JSF" desc="Relational operators shall not be applied to pointer types except where they point to the same array" id="JSF-171" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist" id="JSF-173" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The null pointer shall not be de-referenced" id="JSF-174_a" origId="MISRA-107_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The null pointer shall not be de-referenced" id="JSF-174_b" origId="MISRA-107_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="NULL identifier shall not be used; use plain 0 instead" id="JSF-175" origId="CODSTA-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Down casting (casting from base to derived class) shall not be allowed" id="JSF-178" origId="OOP-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A pointer to a virtual base class shall not be converted to a pointer to a derived class" id="JSF-179" origId="OOP-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="JSF-180_a" origId="MISRA-043" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid implicit conversions from floating to integral type" id="JSF-180_b" origId="MISRA2004-10_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid implicit conversions from wider to narrower floating type" id="JSF-180_c" origId="MISRA2004-10_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid conversions of constant values to a narrower type" id="JSF-180_d" origId="PORT-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="JSF" desc="Avoid implicit conversions from signed to unsigned type" id="JSF-180_e" origId="PB-56" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="JSF-180_f" origId="MISRA-043_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="JSF-180_g" origId="MISRA-043_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Type casting from any type to or from pointers shall not be used" id="JSF-182" origId="CODSTA-135" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Floating point numbers shall not implicitly be converted to integers" id="JSF-184_a" origId="MISRA2004-10_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="JSF-185" origId="CODSTA-CPP-66" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code in 'else' block" id="JSF-186_a" origId="MISRA2004-14_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="JSF-186_b" origId="MISRA2004-14_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code in 'if', 'else', 'while' and 'for' block" id="JSF-186_c" origId="MISRA2004-14_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code in 'switch' statement" id="JSF-186_d" origId="MISRA2004-14_1_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code in 'for' loop" id="JSF-186_e" origId="MISRA2004-14_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="JSF-186_f" origId="MISRA2004-14_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There shall be no unreachable code after 'if' or 'switch' statement inside 'while', 'for' or 'do...while' loop" id="JSF-186_g" origId="MISRA2004-14_1_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Every defined function with internal linkage shall be used" id="JSF-186_h" origId="OPT-30" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All non-null statements shall potentially have a side-effect" id="JSF-187" origId="MISRA2004-14_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The goto statement shall not be used" id="JSF-189" origId="MISRA2004-14_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The continue statement shall not be used" id="JSF-190" origId="MISRA2004-14_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The break statement shall not be used (except to terminate the cases of a switch statement)" id="JSF-191" origId="MISRA-058" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="JSF-191_a" origId="CODSTA-79" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Every non-empty case clause in a switch statement shall be terminated with a break statement" id="JSF-193" origId="MISRA2004-15_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All switch statements that do not intend to test for every enumeration value shall contain a final default clause" id="JSF-194" origId="CODSTA-61" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Floating point variables shall not be used as loop counters" id="JSF-197" origId="MISRA-065" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Numeric variables being used within a for loop for iteration counting shall not be modified in the body of the loop" id="JSF-201" origId="MISRA2004-13_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Floating point variables shall not be tested for exact equality or inequality" id="JSF-202" origId="MISRA2004-13_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Evaluation of expressions shall not lead to overflow/underflow" id="JSF-203" origId="PB-73" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="JSF-204.1_a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Don't write code that depends on the order of evaluation of function arguments" id="JSF-204.1_b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="JSF-204.1_c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="JSF-204.1_d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="JSF-204.1_e" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Do not use more than one volatile in one expression" id="JSF-204.1_f" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Don't write code that depends on the order of evaluation of function calls" id="JSF-204.1_g" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A single operation with side-effect shall only be used in the proper context" id="JSF-204_a" origId="CODSTA-102" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A call of function with side-effect shall only be used in the proper context" id="JSF-204_b" origId="CODSTA-103" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The second or third operand of a ternary operator '?:' shall not contain side effects" id="JSF-204_d" origId="CODSTA-105" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The volatile keyword shall not be used" id="JSF-205" origId="MISRA-046_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Dynamic heap memory allocation shall not be used" id="JSF-206" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="1;" cat="JSF" desc="C++ exceptions shall not be used" id="JSF-208" origId="EXCEPT-05" sev="2" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Typedefs that indicate size and signedness shall be used in place of the basic types" id="JSF-209" origId="MISRA2004-6_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="JSF" desc="Typedefs that indicate size and signedness shall be used in place of the basic types" id="JSF-209_b" origId="MISRA2004-6_3_b" sev="2" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier" id="JSF-210.1" origId="PORT-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Algorithms shall not assume particular memory alignment" id="JSF-211" origId="MISRA2004-11_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Use parenthesis to clarify expression order if operators with precedence lower than arithmetic are used" id="JSF-213_e" origId="CODSTA-97" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Assuming that non-local static objects, in separate translation units, are initialized in a special order shall not be done" id="JSF-214" origId="INIT-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)" id="JSF-001" origId="METRICS-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="Only those characters specified in the C++ basic source character set will be used" id="JSF-009" origId="MISRA-005" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Values of character types will be restricted to a defined and documented subset of ISO 10646-1" id="JSF-010" origId="MISRA-006" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Trigraphs will not be used" id="JSF-011" origId="MISRA2004-4_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The following digraphs will not be used &lt;%, %>, &lt;:, :>, %:, %:%:" id="JSF-012" origId="CODSTA-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Wide string literals (for example L&quot;abc&quot;) will not be used" id="JSF-013" origId="MISRA-008" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="#ifndef, #define and #endif will be used to prevent multiple inclusions of the same header file" id="JSF-027" origId="PFO-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="JSF-028" origId="PREPROC-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="JSF-028_b" origId="PREPROC-10_b" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="The #define pre-processor directive will only be used as part of the technique to prevent multiple inclusions of the same header file" id="JSF-031" origId="PREPROC-01" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="0;" cat="JSF" desc="The #include pre-processor directive will only be used to include header (*.h) files" id="JSF-032" origId="PREPROC-08" sev="3" total="12"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A header file will contain a mechanism that prevents multiple inclusions of itself" id="JSF-035" origId="PFO-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Header files (*.h) will not contain non-const variable definitions or function definitions" id="JSF-039_a" origId="PFO-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="Source lines will be kept to a length of 120 characters or less" id="JSF-041" origId="METRICS-26" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Each expression-statement will be on a separate line" id="JSF-042" origId="FORMAT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All indentations will be consistent" id="JSF-044" origId="FORMAT-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Identifiers will not begin with the underscore character &quot;_&quot;" id="JSF-047" origId="NAMING-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" id="JSF-048" origId="NAMING-45" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Begin class, struct, union, enum, and typedef names with an uppercase letter" id="JSF-050" origId="NAMING-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="All letters contained in function and variable names will be composed entirely of lowercase letters" id="JSF-051" origId="NAMING-44" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Header files will always have a file name extension of &quot;.h&quot;" id="JSF-053" origId="NAMING-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="JSF" desc="Implementation files will always have a file name extension of &quot;.cpp&quot;" id="JSF-054" origId="NAMING-49" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The public section of a class will be declared before the protected section and before the private section" id="JSF-057_a" origId="CODSTA-CPP-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The protected section of a class will be declared before the private section" id="JSF-057_b" origId="CODSTA-CPP-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="When declaring functions with more than 2 parameters, the leading parenthesis and the first argument are to be written on the same line as the function name, each additional argument will be written on a separate line" id="JSF-058" origId="FORMAT-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="23;" authUrg="1;" cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="JSF-060_a" origId="FORMAT-42" sev="3" total="23"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="19;" authUrg="1;" cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" id="JSF-060_b" origId="FORMAT-43" sev="3" total="19"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will not have an empty line after &quot;{&quot; nor before &quot;}&quot;" id="JSF-060_c" origId="FORMAT-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="23;" authUrg="1;" cat="JSF" desc="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" id="JSF-061" origId="FORMAT-42" sev="3" total="23"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="JSF" desc="The dereference operator '*' and the address-of operator '&amp;' will be directly connected with the type-specifier" id="JSF-062" origId="FORMAT-32" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There will be no white space following '.' or '->' operator" id="JSF-063_a" origId="FORMAT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There will be no white space preceding '.' or '->' operator" id="JSF-063_b" origId="FORMAT-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There will be no space between a unary operator '!' or '~' and its operand" id="JSF-063_c" origId="FORMAT-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There will be no space between a increment/decrement operator (++/--) and its operand" id="JSF-063_d" origId="FORMAT-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There will be no space between a unary operator '&amp;', '*', '+', '-' and its operand" id="JSF-063_e" origId="FORMAT-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="There should be no space between an increment/decrement operator (++/--) and its operand in macro definition" id="JSF-063_f" origId="FORMAT-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A member function that does not affect the state of an object will be declared const" id="JSF-069" origId="CODSTA-CPP-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Initialization of nonstatic class members will be performed through the member initialization list rather than through assignment in the body of a constructor" id="JSF-074" origId="INIT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="When two operators are opposites (such as == and !=), both will be defined" id="JSF-085" origId="CODSTA-CPP-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="When one of opposite operators (== and !=) is defined, the other should be defined too and one will be defined in terms of the other" id="JSF-085_a" origId="CODSTA-CPP-86" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Namespaces will not be nested more than two levels deep" id="JSF-099" origId="CODSTA-CPP-57" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All partial and explicit specializations for a template should be declared in the same file as the declaration of their primary template" id="JSF-104" origId="TEMPL-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Functions with more than 7 arguments will not be used" id="JSF-110" origId="METRICS-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="Functions will have a single exit point" id="JSF-113" origId="MISRA2004-14_7" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="If a function returns error information, then that error information will be tested" id="JSF-115" origId="MISRA2004-16_10" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="10;" authUrg="1;" cat="JSF" desc="Each variable declaration will be commented" id="JSF-132_a" origId="COMMENT-05" sev="3" total="10"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Each typedef will be commented" id="JSF-132_b" origId="COMMENT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Each enumeration value will be commented" id="JSF-132_c" origId="COMMENT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Each structure member variable will be commented" id="JSF-132_d" origId="COMMENT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="0;" cat="JSF" desc="Every source file will be documented with an introductory comment that provides information on the file" id="JSF-133_a" origId="COMMENT-03" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="JSF" desc="Every source file will contain copyright information" id="JSF-133_b" origId="COMMENT-02" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="External objects will not be declared in more than one file" id="JSF-139" origId="MISRA-027" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="External objects will not be declared in implementation files" id="JSF-139_b" origId="MISRA-027_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A class, structure, or enumeration will not be declared in the definition of its type" id="JSF-141" origId="CODSTA-CPP-56" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Variables will not be introduced until they can be initialized with meaningful values" id="JSF-143" origId="OPT-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid unused local variables" id="JSF-143_a" origId="OPT-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Hexadecimal constants will be represented using all uppercase letters" id="JSF-150" origId="CODSTA-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="JSF" desc="Numeric values in code will not be used; symbolic values will be used instead" id="JSF-151" origId="CODSTA-26" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The sizeof operator will not be used on expressions that contain side effects" id="JSF-166" origId="MISRA2004-12_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The sizeof operator will not be used on expressions that contain side effects" id="JSF-166_b" origId="MISRA2004-12_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The sizeof operator will not be used on expressions that contain side effects" id="JSF-166_c" origId="MISRA2004-12_3_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The implementation of integer division shall be documented" id="JSF-167" origId="MISRA-041" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A typedef will be used to simplify program syntax when declaring function pointers" id="JSF-176" origId="CODSTA-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Redundant explicit casts will not be used" id="JSF-181_a" origId="OPT-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid explicit cast from derived to a base class" id="JSF-181_b" origId="OOP-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Labels will not be used, except in switch statements" id="JSF-188" origId="MISRA-055" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All 'if...else if' constructs will contain either a final else clause or a comment indicating why a final else clause is not necessary" id="JSF-192" origId="CODSTA-98" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A switch expression will not represent a Boolean value" id="JSF-195" origId="MISRA2004-15_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Every switch statement will have at least two cases and a potential default" id="JSF-196" origId="CODSTA-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The initialization expression in a for loop will perform no actions other than to initialize the value of a single for loop parameter" id="JSF-198" origId="CODSTA-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The increment expression in a for loop will perform no action other than to change a single loop parameter to the next value for the loop" id="JSF-199" origId="CODSTA-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Null initialize or increment expressions in for loops will not be used; a while loop will be used instead" id="JSF-200" origId="CODSTA-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Unencapsulated global data will be avoided" id="JSF-207" origId="CODSTA-CPP-82" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A file should directly include only headers containing declarations and definitions needed to a compilation" id="JSF-037" origId="OPT-41" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Tabs should be avoided" id="JSF-043" origId="FORMAT-01" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Public data should only be used in structs, not in classes" id="JSF-067_a" origId="OOP-18" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="JSF" desc="Protected data should only be used in structs, not in classes" id="JSF-067_b" origId="OOP-19" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid using the friend mechanism" id="JSF-070" origId="OOP-11" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Hierarchies should be based on abstract classes" id="JSF-087" origId="OOP-40" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="JSF" desc="Every nonlocal name, except main(), should be placed in some namespace" id="JSF-098" origId="CODSTA-CPP-36" sev="4" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Don't write namespace usings in a header file or before an #include" id="JSF-100" origId="CODSTA-CPP-39" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="In a class template with a dependent base, any name that may be found in that dependent base should be referred to using a qualifier" id="JSF-105" origId="TEMPL-12" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A function definition should not be placed in a class specification" id="JSF-109" origId="CODSTA-CPP-32" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Dereferenced local pointer initialized by new in function scope should not be returned" id="JSF-112" origId="MRM-23" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="Value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="JSF-115_a" origId="CODSTA-CPP-58" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Built-in-types should be passed by value unless you are modifying them" id="JSF-116" origId="CODSTA-36" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Arguments should be passed by reference" id="JSF-117" origId="OPT-14" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="An object should be passed as const reference if the function should not change the value of the object" id="JSF-117.1" origId="CODSTA-CPP-43" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor" id="JSF-117_b" origId="PB-23" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="JSF-118" origId="MISRA2004-16_7" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="JSF-118_b" origId="MISRA2004-16_7_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Only functions with 1 or 2 statements should be considered candidates for inline functions" id="JSF-121" origId="OPT-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Trivial accessor and mutator functions should be inlined" id="JSF-122" origId="OPT-23" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Classes which have only getters/setters (accessors/mutators) are not allowed" id="JSF-123" origId="CODSTA-CPP-81" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Trivial forwarding functions should be inlined" id="JSF-124" origId="OPT-24" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Pass and return by reference when possible" id="JSF-125_a" origId="OPT-14" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="7;" authUrg="0;" cat="JSF" desc="Document functions in comments that precede function definitions" id="JSF-134" origId="COMMENT-04" sev="4" total="7"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Document functions in comments that precede function declarations" id="JSF-134_b" origId="COMMENT-04_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="JSF" desc="Objects should be defined at block scope if they are only accessed from within a single function" id="JSF-136_a" origId="MISRA2004-8_7" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="JSF" desc="Declarations of local variables should be at the smallest feasible scope" id="JSF-136_b" origId="OPT-01" sev="4" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="All declarations at file scope should be static where possible" id="JSF-137" origId="MISRA-023" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Pointers to pointers should be avoided" id="JSF-169" origId="CODSTA-05" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="User-defined conversion functions should be avoided" id="JSF-177" origId="CODSTA-CPP-05" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Constructors allowing for conversion should be made explicit" id="JSF-177_b" origId="CODSTA-CPP-04" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Every possible measure should be taken to avoid type casting" id="JSF-183" origId="CODSTA-31" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid using static_cast on pointers" id="JSF-183_a" origId="CODSTA-CPP-34" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Avoid using reinterpret_cast" id="JSF-183_b" origId="CODSTA-CPP-09" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Pointer arithmetic will not be used" id="JSF-215" origId="MISRA-101" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="JSF" desc="Consider using op= instead of stand-alone op" id="JSF-125_b" origId="OPT-19" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of blocks of code in a function" id="METRICS-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="METRICS" desc="Number of function calls within function" id="METRICS-04" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Class inheritance level" id="METRICS-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of data member(s) per class should not exceed 15" id="METRICS-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of methods per class" id="METRICS-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of parameter(s) per method should not exceed 10" id="METRICS-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of private data member(s) per class" id="METRICS-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of private methods per class" id="METRICS-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of protected data member(s) per class" id="METRICS-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of protected methods per class" id="METRICS-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of public data member(s) per class" id="METRICS-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Number of public methods per class" id="METRICS-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid functions with more than 5 parameters" id="METRICS-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Macros should not use more than 5 parameters" id="METRICS-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Follow the Cyclomatic Complexity limit of 10" id="METRICS-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="1;" cat="METRICS" desc="The percentage of comment lines versus the total number of module lines should be between 20 and 60" id="METRICS-19" sev="3" total="12"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid too long functions (declarations and statements)" id="METRICS-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid too long functions (blocks)" id="METRICS-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid functions with over 75 lines of code" id="METRICS-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Nested block depth should not be higher than 5" id="METRICS-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Any one function (or method) will contain no more than 200 logical source lines of code (L-SLOCs)" id="METRICS-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="METRICS" desc="Source lines will be kept to a length of 120 characters or less" id="METRICS-26" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Functions with more than 7 parameters will not be used" id="METRICS-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Follow the Cyclomatic Complexity limit of 20" id="METRICS-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="No function should be longer than 60 lines of code" id="METRICS-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="6;" authUrg="1;" cat="METRICS" desc="The assertion density of the code should average to a minimum of two assertions per function" id="METRICS-31" sev="3" total="6"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="METRICS" desc="All functions with more than 20 lines should contain at least 2 assertions" id="METRICS-32" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="A global function should not be called from more than 5 different functions" id="METRICS-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="A function should not call more than 7 different functions" id="METRICS-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="The number of statements within function should be in range 1 - 50" id="METRICS-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="The value of VOCF metric for a function should not be higher than 4" id="METRICS-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Statements within function should not be nested deeper than 4 levels" id="METRICS-40" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="The number of blocks of comments before and inside function to the number of statements in function should be > 0.2" id="METRICS-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Report the value of Halstead's delivered bugs (B) for a function" id="METRICS-43" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid functions with over 50 lines" id="METRICS-01" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid switch statements with many cases" id="METRICS-02" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid structs, unions, or classes with more than 20 fields" id="METRICS-17" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Avoid source files that are longer than 500 lines" id="METRICS-24" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="8;" authUrg="1;" cat="METRICS" desc="Report Cyclomatic Complexity" id="METRICS-29" sev="5" total="8"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="8;" authUrg="1;" cat="METRICS" desc="Report Essential Complexity" id="METRICS-33" sev="5" total="8"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Follow the Essential Complexity limit of 4" id="METRICS-34" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Follow the Essential Complexity limit of 10" id="METRICS-35" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="METRICS" desc="Follow the Essential Complexity limit of 1" id="METRICS-42" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA" desc="Only use characters defined in the ISO C standard" id="MISRA-005" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Values of character types shall be restricted to a defined and documented subset of ISO 10646-1" id="MISRA-006" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use wide string literals" id="MISRA-008" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="0;" cat="MISRA" desc="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" id="MISRA-013" sev="3" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Explicitly declare 'char' type as signed or unsigned" id="MISRA-014" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The underlying bit representations of floating point numbers shall not be used" id="MISRA-016" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="All functions shall be declared before use" id="MISRA-020" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Identifiers shall not simultaneously have both internal and external linkage in the same translation unit" id="MISRA-024" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="External object should not be declared in more than one file" id="MISRA-027" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="External objects should not be declared in implementation files" id="MISRA-027_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The use of a tag shall agree with its declaration" id="MISRA-029" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="All automatic variables shall have been assigned a value before being used" id="MISRA-030" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="MISRA-038" origId="MISRA2004-12_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The comma operator shall not be used, except in the control expression of a for loop" id="MISRA-042" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Implicit conversions from wider to narrower integral type which may result in a loss of information shall not be used" id="MISRA-043" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Avoid mixing arithmetic of different precisions in the same expression" id="MISRA-043_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Implicit conversions from integral to floating type which may result in a loss of information shall not be used" id="MISRA-043_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Implicit conversions from integral constant to floating type which may result in a loss of information shall not be used" id="MISRA-043_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Redundant explicit cast to the same type is not allowed" id="MISRA-044" origId="OPT-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use the volatile keyword" id="MISRA-046_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Assignment statements should not be nested within other assignment statements" id="MISRA-046_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Avoid possible integer overflow in expressions in which the result is cast to a wider integer type" id="MISRA-048_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Don't cast the dividend of two integers to a floating-point type" id="MISRA-048_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="MISRA-048_c" origId="PB-65" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Avoid unintentionally discarding the remainder of integer division" id="MISRA-048_d" origId="PB-15_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="A null statement shall only occur on a line by itself" id="MISRA-054" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use the break statement" id="MISRA-058" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use floating point variables as loop counters" id="MISRA-065" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use functions with variable numbers of arguments" id="MISRA-069" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call" id="MISRA-071_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Functions shall always have visible prototype at the function call" id="MISRA-071_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Provide none or all identifiers for function arguments" id="MISRA-073" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Provide expression for return statement of non-void functions" id="MISRA-083" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Avoid expressions in return statements of void functions" id="MISRA-084" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA-089" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Enclose in parentheses whole definition of a function-like macro" id="MISRA-096" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Use only non-ambiguous forms of defined pre-processor operator" id="MISRA-100" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Pointer arithmetic should not be used" id="MISRA-101" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use non-constant pointers to functions" id="MISRA-104" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="All the functions pointed to by a single pointer to function shall be identical in the number and type of parameters and the return type" id="MISRA-105" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The NULL pointer shall not be dereferenced" id="MISRA-107_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The NULL pointer shall not be dereferenced" id="MISRA-107_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="All members of structure or union should be fully specified" id="MISRA-108" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Unions shall not be used to access the sub-parts of larger data structure" id="MISRA-110" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="All the members of a structure (or class/union) shall be named" id="MISRA-113" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Standard library function names shall not be reused" id="MISRA-115" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The 'setlocale' function should not be used" id="MISRA-121_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not include &lt;locale.h> header" id="MISRA-121_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Objects or functions with external linkage shall be declared in a header file" id="MISRA-023" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Provisions should be made for appropriate run-time checking" id="MISRA-004_a" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Provisions should be made for appropriate run-time checking" id="MISRA-004_b" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_a" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_b" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_c" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Use type suffix for numeric constants" id="MISRA-018_d" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA" desc="Declare objects at function scope" id="MISRA-022" sev="5" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="The 'register' storage class specifier shall not be used" id="MISRA-028" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Document integer division" id="MISRA-041" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="MISRA-051" origId="PB-73" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA" desc="Do not use labels" id="MISRA-055" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRA2004-12_2_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions between signed and unsigned integer types" id="MISRA2004-10_1_a" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no implicit conversions from integral to floating type" id="MISRA2004-10_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions of complex expressions" id="MISRA2004-10_1_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions from wider to narrower types" id="MISRA2004-10_1_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions of function return expressions" id="MISRA2004-10_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions of complex expressions" id="MISRA2004-10_1_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions of function arguments" id="MISRA2004-10_1_g" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions of complex expressions" id="MISRA2004-10_1_i" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions from floating to integral type" id="MISRA2004-10_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions from wider to narrower floating type" id="MISRA2004-10_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions from narrower to wider floating type" id="MISRA2004-10_2_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid implicit conversions of floating point numbers from wider to narrower floating type" id="MISRA2004-10_2_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The value of a complex expression of integer type shall only be cast to a type  of the same signedness that is no wider than the underlying type of the expression" id="MISRA2004-10_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The value of a complex expression of floating type should not be cast to a wider floating type" id="MISRA2004-10_4" origId="CODSTA-198" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The value of a complex expression of floating type should not be cast to an integer type" id="MISRA2004-10_4_b" origId="CODSTA-198_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="If the bitwise operators ~ and &lt;&lt; are applied to an operand of underlying type unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" id="MISRA2004-10_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Conversions shall not be performed between a pointer to a function and any type other than an integral type" id="MISRA2004-11_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void" id="MISRA2004-11_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void" id="MISRA2004-11_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Conversions shall not be performed between a pointer to object and any type other than an integral type, another pointer to object type or a pointer to void" id="MISRA2004-11_2_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A cast should not convert a pointer type to an integral type" id="MISRA2004-11_3_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A cast should not convert an integral type to a pointer type" id="MISRA2004-11_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A cast should not be performed between a pointer to object type and a different pointer to object type" id="MISRA2004-11_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A cast shall not remove any 'const' or 'volatile' qualification from the type of a pointer or reference" id="MISRA2004-11_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The comma operator shall not be used" id="MISRA2004-12_10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The underlying bit representations of floating-point values shall not be used" id="MISRA2004-12_12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The increment (++) and decrement (--) operators should not be mixed with other operators in an expression" id="MISRA2004-12_13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Use parenthesis for the right-hand operand of an assignment operator when it contains an assignment expression" id="MISRA2004-12_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="MISRA2004-12_1_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Use parentheses unless all operators in the expression are the same" id="MISRA2004-12_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2004-12_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRA2004-12_2_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRA2004-12_2_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRA2004-12_2_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRA2004-12_2_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRA2004-12_2_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="MISRA2004-12_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="MISRA2004-12_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The function call that causes the side effect shall not be the operand of the sizeof operator" id="MISRA2004-12_3_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRA2004-12_4_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The operands of a logical &amp;&amp; or || shall be primary-expressions" id="MISRA2004-12_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The operands of logical operators (&amp;&amp;, || and !) should be effectively Boolean" id="MISRA2004-12_6_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Expressions that are effectively Boolean should not be used as operands to operators other than (&amp;&amp;, ||, !, =, ==, !=, ?:)" id="MISRA2004-12_6_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Bitwise operators shall not be applied to operands whose underlying type is signed" id="MISRA2004-12_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The right-hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left-hand operand" id="MISRA2004-12_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="MISRA2004-12_9" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Assignment operators shall not be used in expressions that yield a Boolean value" id="MISRA2004-13_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="MISRA2004-13_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Floating-point expressions shall not be tested for equality or inequality" id="MISRA2004-13_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The controlling expression of a for statement shall not contain any objects of floating type" id="MISRA2004-13_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The three expressions of a for statement shall be concerned only with loop control" id="MISRA2004-13_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not modify for loop counter within a body of the loop" id="MISRA2004-13_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_aa" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ab" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ac" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ad" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ae" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_af" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ag" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ah" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ai" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_aj" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_ak" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_j" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_k" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_l" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_m" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_n" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_s" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_t" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_u" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_v" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_w" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_x" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_y" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Boolean operations whose results are invariant shall not be permitted" id="MISRA2004-13_7_z" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="MISRA2004-14_10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code in &quot;else&quot; block" id="MISRA2004-14_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="MISRA2004-14_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="MISRA2004-14_1_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code in switch statement" id="MISRA2004-14_1_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code in 'for' loop" id="MISRA2004-14_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRA2004-14_1_f" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="MISRA2004-14_1_g" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRA2004-14_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A null statement shall occur on a line by itself or be followed by a comment" id="MISRA2004-14_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The goto statement shall not be used" id="MISRA2004-14_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The continue statement shall not be used" id="MISRA2004-14_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="For any iteration statement there shall be at most one break statement used for loop termination" id="MISRA2004-14_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2004" desc="A function shall have a single point of exit at the end of the function" id="MISRA2004-14_7" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="MISRA2004-14_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="MISRA2004" desc="'if' and 'else' should be followed by a compound statement" id="MISRA2004-14_9" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A break statement should be placed only at the end of switch clause" id="MISRA2004-15_0_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRA2004-15_0_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2004-15_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRA2004-15_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRA2004-15_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The final clause of a switch statement shall be the default clause" id="MISRA2004-15_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRA2004-15_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRA2004-15_4_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Every switch statement shall have at least one case clause" id="MISRA2004-15_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Functions shall not be defined with a variable number of arguments" id="MISRA2004-16_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2004" desc="If a function returns error information, then that error information shall be tested" id="MISRA2004-16_10" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Functions shall not call themselves, either directly or indirectly" id="MISRA2004-16_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Identifiers shall be given for all of the parameters in a function prototype declaration" id="MISRA2004-16_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRA2004-16_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Functions with no parameters shall be declared with parameter type void" id="MISRA2004-16_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The number of arguments passed to a function shall match the number of parameters" id="MISRA2004-16_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRA2004-16_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRA2004-16_7_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRA2004-16_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRA2004-16_8_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A function identifier shall only be used with either a preceding '&amp;', or with a parenthesised parameter list, which may be empty" id="MISRA2004-16_9" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not apply arithmetic to pointers that don't address an array or array element" id="MISRA2004-17_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Pointer subtraction shall only be applied to pointers that address elements of the same array" id="MISRA2004-17_2" origId="CODSTA-13_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc=">, >=, &lt;, &lt;= shall not be applied to pointer types except where they point to the same array" id="MISRA2004-17_3" origId="CODSTA-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Array indexing shall be the only allowed form of pointer arithmetic" id="MISRA2004-17_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="MISRA2004-17_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRA2004-17_6_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2004-17_6_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All structure and union types shall be complete at the end of a translation unit" id="MISRA2004-18_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="An object shall not be assigned to an overlapping object" id="MISRA2004-18_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="An object shall not be assigned to an overlapping object" id="MISRA2004-18_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Unions shall not be used" id="MISRA2004-18_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="MISRA2004-19_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="MISRA2004-19_10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRA2004-19_11_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be at most one occurrence of the # or ## preprocessor operators in a single macro definition" id="MISRA2004-19_12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The # and ## preprocessor operators should not be used" id="MISRA2004-19_13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The defined preprocessor operator shall only be used in one of the two standard forms" id="MISRA2004-19_14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Precautions shall be taken in order to prevent the contents of a header file being included twice" id="MISRA2004-19_15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="MISRA2004-19_16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRA2004-19_17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Non-standard characters should not occur in header file names in #include directives" id="MISRA2004-19_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA2004-19_3" origId="MISRA-089" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Avoid keywords and basic types in macros" id="MISRA2004-19_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Macros shall not be #define'd or #undef'd within a block" id="MISRA2004-19_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="#undef shall not be used" id="MISRA2004-19_6" origId="PREPROC-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A function should be used in preference to a function-like macro" id="MISRA2004-19_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A function-like macro shall not be invoked without all of its arguments" id="MISRA2004-19_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRA2004-19_9" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2004" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="MISRA2004-20_10" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRA2004-20_11" origId="PB-75" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRA2004-20_11_b" origId="PB-75_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRA2004-20_11_c" origId="SECURITY-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRA2004-20_11_d" origId="SECURITY-48_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The standard header files &lt;time.h> or &lt;ctime> shall not be used" id="MISRA2004-20_12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not #define or #undef identifiers with names which start with underscore" id="MISRA2004-20_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not redefine reserved words" id="MISRA2004-20_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="MISRA2004-20_1_c" origId="CODSTA-92_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not #define nor #undef identifier 'defined'" id="MISRA2004-20_1_e" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The names of standard library macros, objects and functions shall not be reused" id="MISRA2004-20_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The names of standard library macros, objects and functions shall not be reused (C90)" id="MISRA2004-20_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The names of standard library macros, objects and functions shall not be reused (C99)" id="MISRA2004-20_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2004" desc="The validity of values passed to library functions shall be checked" id="MISRA2004-20_3" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Dynamic heap memory allocation shall not be used" id="MISRA2004-20_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The error indicator 'errno' shall not be used" id="MISRA2004-20_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The macro offsetof, in library stddef.h, shall not be used" id="MISRA2004-20_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The facilities provided by &lt;setjmp.h> should not be used" id="MISRA2004-20_7" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="MISRA2004-20_7_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The standard header files &lt;signal.h> or &lt;csignal> shall not be used" id="MISRA2004-20_8" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="MISRA2004-20_8_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2004" desc="The input/output library stdio.h shall not be used" id="MISRA2004-20_9" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Assembly language shall be encapsulated and isolated" id="MISRA2004-2_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Source code shall only use /* ... */ style comments" id="MISRA2004-2_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The character sequence /* shall not be used within a C-style comment" id="MISRA2004-2_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All uses of the #pragma directive shall be documented and explained" id="MISRA2004-3_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not mix bit-fields and other data within the same structure" id="MISRA2004-3_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Only those escape sequences that are defined in the ISO C standard shall be used" id="MISRA2004-4_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Trigraphs shall not be used" id="MISRA2004-4_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="User-specified C external identifiers should differ in the first 31 characters" id="MISRA2004-5_1_a" origId="PORT-35_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="User-specified C internal identifiers should differ from external identifiers in the first 31 characters" id="MISRA2004-5_1_b" origId="PORT-35_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="User-specified C internal identifiers declared in the same scope should differ in the first 31 characters" id="MISRA2004-5_1_c" origId="PORT-35_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="MISRA2004-5_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="MISRA2004-5_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not reuse typedef names" id="MISRA2004-5_3_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Do not reuse typedef names as a typedef name" id="MISRA2004-5_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2004" desc="A tag name shall not be reused for other purpose within the program" id="MISRA2004-5_4_a" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A tag name shall not be reused to define a different tag" id="MISRA2004-5_4_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The name of typedef should not be the same as the name of type that is typedef'd" id="MISRA2004-5_4_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The plain char type shall be used only for the storage and use of character values" id="MISRA2004-6_1" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="signed and unsigned char type shall be used only for the storage and use of numeric values" id="MISRA2004-6_2" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="typedefs to basic types should contain some digits in their name" id="MISRA2004-6_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="MISRA2004" desc="typedefs should be used in place of the basic types" id="MISRA2004-6_3_b" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="MISRA2004-6_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRA2004-6_5" origId="CODSTA-71" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Unnamed bit-fields with signed integer type shall have a length of more than one bit" id="MISRA2004-6_5_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Octal constants (other than zero) shall not be used" id="MISRA2004-7_1_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Octal escape sequences shall not be used" id="MISRA2004-7_1_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRA2004-8_11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="MISRA2004-8_12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Functions shall have prototype declarations and the prototype shall be visible at both the function definition and call" id="MISRA2004-8_1_a" origId="MISRA-071_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Functions shall always have visible prototype at the function call" id="MISRA2004-8_1_b" origId="MISRA-071_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Whenever a function is declared or defined, its type shall be explicitly stated" id="MISRA2004-8_2_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Whenever an object is declared or defined, its type shall be explicitly stated" id="MISRA2004-8_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Use identical types in declaration and definition" id="MISRA2004-8_3_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Use identical types in declaration and definition" id="MISRA2004-8_3_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRA2004-8_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="There shall be no definitions of objects or functions in a header file" id="MISRA2004-8_5" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Always declare functions at file scope" id="MISRA2004-8_6" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2004" desc="Objects shall be defined at block scope if they are only accessed from within a single function" id="MISRA2004-8_7" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="All automatic variables shall have been assigned a value before being used" id="MISRA2004-9_1" origId="MISRA-030" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The initializer for an aggregate or union shall be enclosed in braces" id="MISRA2004-9_2" origId="INIT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Arrays shall not be partially initialized" id="MISRA2004-9_2_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="The non-zero initialization of structures requires an explicit initializer for each element" id="MISRA2004-9_2_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="In an enumerator list, the &quot;=&quot; construct shall not be used to explicitly initialise members other than the first, unless all items are explicitly initialised" id="MISRA2004-9_3" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Sections of code should not be &quot;commented out&quot;" id="MISRA2004-2_4" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="No object or function identifier with static storage duration should be reused" id="MISRA2004-5_5_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="No object or function identifier with static storage duration should be reused" id="MISRA2004-5_5_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="No identifier in one name space should have the same spelling as an identifier in another name space, with the exception of structure and union member names" id="MISRA2004-5_6" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="No identifier name should be reused" id="MISRA2004-5_7" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Objects or functions with external linkage shall be declared in a header file" id="MISRA2004-8_10" origId="MISRA-023" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="A 'U' suffix shall be applied to all constants of unsigned type" id="MISRA2004-10_6" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="MISRA2004-12_1_b" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="No parentheses are required for the operand of a unary operator" id="MISRA2004-12_1_c" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2004" desc="Limited dependence should be placed on C's operator precedence rules in expressions" id="MISRA2004-12_1_f" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Every defined function with internal linkage shall be used" id="MISRA2008-0_1_10" origId="OPT-30" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Every defined function with external linkage shall be used" id="MISRA2008-0_1_10_b" origId="GLOBAL-UNUSEDFUNC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no unused parameters (named or unnamed) in nonvirtual functions" id="MISRA2008-0_1_11" origId="OPT-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no unused parameters (named or unnamed) in the set of parameters for a virtual function and all the functions that override it" id="MISRA2008-0_1_12" origId="GLOBAL-UNUSEDVIRTPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code in 'else' block" id="MISRA2008-0_1_1_a" origId="MISRA2004-14_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="MISRA2008-0_1_1_b" origId="MISRA2004-14_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code in 'if/else/while/for' block" id="MISRA2008-0_1_1_c" origId="MISRA2004-14_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code in switch statement" id="MISRA2008-0_1_1_d" origId="MISRA2004-14_1_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code in 'for' loop" id="MISRA2008-0_1_1_e" origId="MISRA2004-14_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code after 'if' or 'switch' statement outside 'for/while/catch' block" id="MISRA2008-0_1_1_f" origId="MISRA2004-14_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unreachable code after 'if' or 'switch' statement inside 'while/for/catch' block" id="MISRA2008-0_1_1_g" origId="MISRA2004-14_1_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_a" origId="MISRA2004-13_7_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_aa" origId="BD-PB-CC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_b" origId="MISRA2004-13_7_aa" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_c" origId="MISRA2004-13_7_ab" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_d" origId="MISRA2004-13_7_ac" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_e" origId="MISRA2004-13_7_ad" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_f" origId="MISRA2004-13_7_ae" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_g" origId="MISRA2004-13_7_af" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_h" origId="MISRA2004-13_7_ag" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_i" origId="MISRA2004-13_7_ah" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_j" origId="MISRA2004-13_7_ai" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_k" origId="MISRA2004-13_7_aj" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_l" origId="MISRA2004-13_7_ak" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_m" origId="MISRA2004-13_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_n" origId="MISRA2004-13_7_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_o" origId="MISRA2004-13_7_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_p" origId="MISRA2004-13_7_j" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_q" origId="MISRA2004-13_7_k" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_r" origId="MISRA2004-13_7_l" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_rz" origId="MISRA2004-13_7_z" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_s" origId="MISRA2004-13_7_m" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_sz" origId="MISRA2004-13_7_v" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_t" origId="MISRA2004-13_7_n" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_u" origId="MISRA2004-13_7_s" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_v" origId="MISRA2004-13_7_t" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_w" origId="MISRA2004-13_7_u" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_x" origId="MISRA2004-13_7_w" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_y" origId="MISRA2004-13_7_x" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain infeasible paths" id="MISRA2008-0_1_2_z" origId="MISRA2004-13_7_y" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unused variables" id="MISRA2008-0_1_3_a" origId="OPT-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Eliminate unused private member variables" id="MISRA2008-0_1_3_c" origId="OPT-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="5;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain non-volatile POD variables having only one use" id="MISRA2008-0_1_4" origId="GLOBAL-ONEUSEVAR" sev="2" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A project shall not contain unused type declarations" id="MISRA2008-0_1_5" origId="GLOBAL-UNUSEDTYPE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid unused values" id="MISRA2008-0_1_6" origId="BD-PB-VOVR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2008" desc="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" id="MISRA2008-0_1_7" origId="CODSTA-CPP-58" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All functions with void return type shall have external side effect(s)" id="MISRA2008-0_1_8" origId="OPT-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2008" desc="All functions with void return type shall have external side effect(s)" id="MISRA2008-0_1_8_b" origId="OPT-32_b" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRA2008-0_1_9" origId="MISRA2004-14_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An object shall not be assigned to an overlapping object" id="MISRA2008-0_2_1_a" origId="MISRA2004-18_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An object shall not be assigned to an overlapping object" id="MISRA2008-0_2_1_b" origId="PB-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="If a function generates error information, then that error information shall be tested" id="MISRA2008-0_3_2" origId="MISRA2004-16_10" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A base class shall only be declared virtual if it is used in a diamond hierarchy" id="MISRA2008-10_1_2" origId="GLOBAL-VIRTBASECLASS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An accessible base class shall not be both virtual and non-virtual in the same hierarchy" id="MISRA2008-10_1_3" origId="OOP-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy" id="MISRA2008-10_3_1" origId="OOP-44" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Each overriding virtual function shall be declared with the virtual keyword" id="MISRA2008-10_3_2" origId="OOP-21" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" id="MISRA2008-10_3_3" origId="OOP-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRA2008" desc="Member data in non-POD class types shall be private" id="MISRA2008-11_0_1" origId="OOP-48" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not use dynamic type of an object under construction" id="MISRA2008-12_1_1" origId="BD-PB-VCTOR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All constructors that are callable with a single argument of fundamental type shall be declared explicit" id="MISRA2008-12_1_3" origId="OOP-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A copy constructor shall only initialize its base classes and the nonstatic members of the class of which it is a member" id="MISRA2008-12_8_1" origId="OOP-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The copy assignment operator shall be declared protected or private in an abstract class" id="MISRA2008-12_8_2" origId="OOP-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not declare non-member generic functions in associated namespaces" id="MISRA2008-14_5_1" origId="TEMPL-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="MISRA2008-14_5_2" origId="TEMPL-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="MISRA2008-14_5_3" origId="TEMPL-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="MISRA2008-14_6_1" origId="TEMPL-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The function shall resolve to a function declared previously in the translation unit" id="MISRA2008-14_6_2" origId="TEMPL-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All class templates, function templates, class template member functions and class template static members shall be instantiated at least one." id="MISRA2008-14_7_1" origId="GLOBAL-TEMPLNOINST" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="MISRA2008-14_7_3" origId="TEMPL-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Overloaded function templates shall not be explicitly specialized" id="MISRA2008-14_8_1" origId="TEMPL-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Control shall not be transferred into a try or catch block using a goto or a switch statement" id="MISRA2008-15_0_3" origId="EXCEPT-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The assignment-expression of a throw statement shall not itself cause an exception to be thrown" id="MISRA2008-15_1_1" origId="EXCEPT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="NULL shall not be thrown explicitly" id="MISRA2008-15_1_2" origId="EXCEPT-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An empty throw (throw;) shall only be used in the compound statement of a catch handler" id="MISRA2008-15_1_3" origId="EXCEPT-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Exceptions shall be raised only after start-up and before termination of the program" id="MISRA2008-15_3_1" origId="EXCEPT-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Handlers of a function-try-block implementation of a class constructor or destructor shall not reference non-static members from this class or its bases" id="MISRA2008-15_3_3" origId="EXCEPT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="MISRA2008-15_3_4_a" origId="EXCEPT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="MISRA2008-15_3_4_b" origId="EXCEPT-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="A class type exception shall always be caught by reference" id="MISRA2008-15_3_5" origId="EXCEPT-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="MISRA2008-15_3_6" origId="EXCEPT-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block, any ellipsis (catch-all) handler shall occur last" id="MISRA2008-15_3_7" origId="EXCEPT-24" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If a function is declared with an exception-specification, then all declarations of the same function (in other translation units) shall be declared with the same set of type-ids" id="MISRA2008-15_4_1" origId="GLOBAL-EXCSPECDECL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A class destructor shall not exit with an exception" id="MISRA2008-15_5_1" origId="EXCEPT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="MISRA2008-15_5_2" origId="EXCEPT-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid throwing exceptions from functions that are declared not to throw" id="MISRA2008-15_5_2_b" origId="BD-PB-NOEXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="MISRA2008-15_5_3" origId="PB-44" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Never allow an exception to be thrown from a destructor, deallocation, and swap" id="MISRA2008-15_5_3_b" origId="EXCEPT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not throw from within destructor" id="MISRA2008-15_5_3_c" origId="EXCEPT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRA2008" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="MISRA2008-15_5_3_d" origId="EXCEPT-06" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An empty throw (throw;) shall only be used in the compound-statement of a catch handler" id="MISRA2008-15_5_3_e" origId="EXCEPT-07" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Exceptions shall be raised only after start-up and before termination of the program" id="MISRA2008-15_5_3_f" origId="EXCEPT-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Each exception explicitly thrown in the code shall have a handler of a compatible type in all call paths that could lead to that point" id="MISRA2008-15_5_3_g" origId="EXCEPT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Where a function's declaration includes an exception-specification, the function shall only be capable of throwing exceptions of the indicated type(s)" id="MISRA2008-15_5_3_h" origId="EXCEPT-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Function called in global or namespace scope shall not throw unhandled exceptions" id="MISRA2008-15_5_3_i" origId="EXCEPT-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Always catch exceptions" id="MISRA2008-15_5_3_j" origId="BD-PB-EXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Properly define exit handlers" id="MISRA2008-15_5_3_k" origId="BD-PB-EXITHAN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid throwing exceptions from functions that are declared not to throw" id="MISRA2008-15_5_3_l" origId="BD-PB-NOEXCEPT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="#include directives in a file shall only be preceded by other preprocessor directives or comments" id="MISRA2008-16_0_1" origId="MISRA2004-19_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Macros shall only be #define'd or #undef'd in the global namespace" id="MISRA2008-16_0_2" origId="MISRA2004-19_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="#undef shall not be used" id="MISRA2008-16_0_3" origId="PREPROC-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Function-like macros shall not be defined" id="MISRA2008-16_0_4" origId="MISRA2004-19_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRA2008-16_0_5" origId="MISRA2004-19_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="In the definition of a function-like macro, each instance of a parameter shall be enclosed in parentheses, unless it is used as the operand of # or ##" id="MISRA2008-16_0_6" origId="MISRA2004-19_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRA2008-16_0_7_b" origId="MISRA2004-19_11_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If the # token appears as the first token on a line, then it shall be immediately followed by a preprocessing token" id="MISRA2008-16_0_8" origId="MISRA2004-19_16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The defined preprocessor operator shall only be used in one of the two standard forms" id="MISRA2008-16_1_1" origId="MISRA2004-19_14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRA2008-16_1_2" origId="MISRA2004-19_17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="Avoid using macro definitions" id="MISRA2008-16_2_1_a" origId="PREPROC-01" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="MISRA2008-16_2_1_b" origId="PREPROC-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="MISRA2008-16_2_1_c" origId="PREPROC-11" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="MISRA2008-16_2_1_d" origId="PREPROC-10_b" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="MISRA2008-16_2_1_e" origId="PREPROC-10_c" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="#error directive shall not be used" id="MISRA2008-16_2_1_f" origId="PREPROC-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The #pragma directive shall not be used" id="MISRA2008-16_2_1_g" origId="PREPROC-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="#undef shall not be used" id="MISRA2008-16_2_1_h" origId="PREPROC-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="C++ macros shall only be used for: include guards, type qualifiers, or storage class specifiers" id="MISRA2008-16_2_2" origId="PREPROC-12" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Include guards shall be provided" id="MISRA2008-16_2_3" origId="PFO-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="MISRA2008-16_2_4" origId="NAMING-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA2008-16_2_6" origId="MISRA-089" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be at most one occurrence of the # or ## operators in a single macro definition" id="MISRA2008-16_3_1" origId="MISRA2004-19_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_a" origId="MISRA2004-20_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_b" origId="MISRA2004-20_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_c" origId="CODSTA-92_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_d" origId="CODSTA-92_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Reserved identifiers, macros and functions in the standard library shall not be defined, redefined or undefined" id="MISRA2008-17_0_1_e" origId="MISRA2004-20_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The names of standard library macros and objects shall not be reused" id="MISRA2008-17_0_2" origId="CODSTA-92" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The names of standard library functions shall not be overridden" id="MISRA2008-17_0_3" origId="CODSTA-93" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The setjmp macro and the longjmp function shall not be used" id="MISRA2008-17_0_5" origId="MISRA2004-20_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The standard header file &lt;setjmp.h> shall not be used" id="MISRA2008-17_0_5_b" origId="MISRA2004-20_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="The C library shall not be used" id="MISRA2008-18_0_1" origId="CODSTA-CPP-59" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2008" desc="The library functions atof, atoi and atol from library &lt;cstdlib> shall not be used" id="MISRA2008-18_0_2" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The library function 'abort' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3" origId="PB-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The library function 'exit' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3_b" origId="PB-75_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The library function 'getenv' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3_c" origId="SECURITY-52" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The library function 'system' of &lt;stdlib.h> shall not be used" id="MISRA2008-18_0_3_d" origId="SECURITY-48_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The standard header file &lt;ctime> shall not be used" id="MISRA2008-18_0_4" origId="MISRA2004-20_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The unbounded functions of library &lt;cstring> shall not be used" id="MISRA2008-18_0_5" origId="PB-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The macro offsetof shall not be used" id="MISRA2008-18_2_1" origId="MISRA2004-20_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Dynamic heap memory allocation shall not be used" id="MISRA2008-18_4_1" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The standard header file &lt;csignal> shall not be used" id="MISRA2008-18_7_1" origId="MISRA2004-20_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The signal handling facilities of &lt;csignal> shall not be used" id="MISRA2008-18_7_1_b" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The error indicator errno shall not be used" id="MISRA2008-19_3_1" origId="MISRA2004-20_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="The stream input/output library &lt;cstdio> shall not be used" id="MISRA2008-27_0_1" origId="MISRA2004-20_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="Different identifiers shall be typographically unambiguous" id="MISRA2008-2_10_1" origId="NAMING-47" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2008-2_10_2_a" origId="MISRA2004-5_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Identifiers declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2008-2_10_2_b" origId="MISRA2004-5_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A typedef name (including qualification, if any) shall be a unique identifier" id="MISRA2008-2_10_3" origId="GLOBAL-UNIQUETYPEDEF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A class, union or enum name (including qualification, if any) shall be a unique identifier" id="MISRA2008-2_10_4" origId="GLOBAL-UNIQUETYPE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="MISRA2008-2_10_6_a" origId="CODSTA-CPP-87_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="MISRA2008-2_10_6_b" origId="CODSTA-CPP-87_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If an identifier refers to a type, it shall not also refer to an object or a function in the same scope" id="MISRA2008-2_10_6_c" origId="CODSTA-CPP-87_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Only those escape sequences that are defined in ISO/IEC 14882:2003 shall be used" id="MISRA2008-2_13_1" origId="CODSTA-CPP-60" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Octal constants (other than zero) shall not be used" id="MISRA2008-2_13_2_a" origId="MISRA2004-7_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Octal escape sequences (other than &quot;\0&quot;) shall not be used" id="MISRA2008-2_13_2_b" origId="MISRA2004-7_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A &quot;U&quot; suffix shall be applied to all octal or hexadecimal integer literals of unsigned type" id="MISRA2008-2_13_3" origId="CODSTA-68" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Literal suffixes shall be upper case" id="MISRA2008-2_13_4" origId="CODSTA-51" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Narrow and wide string literals shall not be concatenated" id="MISRA2008-2_13_5" origId="PB-38" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Trigraphs shall not be used" id="MISRA2008-2_3_1" origId="MISRA2004-4_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The character sequence /* shall not be used within a C-style comment" id="MISRA2008-2_7_1" origId="MISRA2004-2_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Sections of code shall not be &quot;commented out&quot; using C-style comments" id="MISRA2008-2_7_2" origId="MISRA2004-2_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="It shall be possible to include any header file in multiple translation units without violating the One Definition Rule" id="MISRA2008-3_1_1" origId="PFO-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Functions shall not be declared at block scope" id="MISRA2008-3_1_2" origId="MISRA2004-8_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="When an array is declared, its size shall either be stated explicitly or defined implicitly by initialization" id="MISRA2008-3_1_3" origId="MISRA2004-8_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All declarations of an object or function shall have compatible types" id="MISRA2008-3_2_1" origId="GLOBAL-COMPATDECLS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The One Definition Rule shall not be violated" id="MISRA2008-3_2_2" origId="GLOBAL-ONEDEFRULE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="MISRA2008" desc="A type, object or function that is used in multiple translation units shall be declared in one and only one file" id="MISRA2008-3_2_3" origId="GLOBAL-ONEFILEDECL" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="MISRA2008" desc="An identifier with external linkage shall have exactly one external definition" id="MISRA2008-3_2_4" origId="GLOBAL-ONEEXTERNDEF" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Objects or functions with external linkage shall be declared in a header file" id="MISRA2008-3_3_1" origId="MISRA-023" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If a function has internal linkage then all re-declarations shall include the static storage class specifier" id="MISRA2008-3_3_2" origId="CODSTA-81" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2008" desc="An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" id="MISRA2008-3_4_1_a" origId="OPT-01" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" id="MISRA2008-3_4_1_b" origId="OPT-45" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The types used for an object, a function return type, or a function parameter shall be token-for-token identical in all declarations and re-declarations" id="MISRA2008-3_9_1" origId="CODSTA-67" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The underlying bit representations of floating-point values shall not be used" id="MISRA2008-3_9_3" origId="MISRA2004-12_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="NULL shall not be used as an integer value" id="MISRA2008-4_10_1" origId="CODSTA-CPP-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="MISRA2008-4_10_2" origId="CODSTA-CPP-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Expressions with type bool shall not be used as operands to built-in operators other than the assignment operator =, the logical operators &amp;&amp;, ||, !, the equality operators == and !=, the unary &amp; operator, and the conditional operator" id="MISRA2008-4_5_1" origId="MISRA2004-12_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Expressions with type enum shall not be used as operands to built-in operators other than [ ], =, ==, !=, &lt;, &lt;=, >, >=, and the unary &amp; operator" id="MISRA2008-4_5_2" origId="CODSTA-70" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Expressions with type (plain) char and wchar_t shall not be used as operands to built-in operators other than the assignment operator =, the equality operators == and !=, and the unary &amp; operator" id="MISRA2008-4_5_3" origId="CODSTA-69" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If the bitwise operators ~ and &lt;&lt; are applied to an operand with an underlying type of unsigned char or unsigned short, the result shall be immediately cast to the underlying type of the operand" id="MISRA2008-5_0_10" origId="MISRA2004-10_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The plain char type shall only be used for the storage and use of character values" id="MISRA2008-5_0_11" origId="MISRA2004-6_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="signed char and unsigned char type shall only be used for the storage and use of numeric values" id="MISRA2008-5_0_12" origId="MISRA2004-6_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The condition of an if-statement and the condition of an iteration-statement shall have type bool" id="MISRA2008-5_0_13" origId="CODSTA-CPP-64" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The first operand of a conditional-operator shall have type bool" id="MISRA2008-5_0_14" origId="CODSTA-CPP-65" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Array indexing shall be the only form of pointer arithmetic" id="MISRA2008-5_0_15" origId="MISRA2004-17_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid accessing arrays out of bounds" id="MISRA2008-5_0_16_a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRA2008-5_0_16_b" origId="BD-PB-PTRARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Subtraction between pointers shall only be applied to pointers that address elements of the same array" id="MISRA2008-5_0_17" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc=">, >=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array" id="MISRA2008-5_0_18" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The declaration of objects shall contain no more than two levels of pointer indirection" id="MISRA2008-5_0_19" origId="MISRA2004-17_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_e" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_f" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2008-5_0_1_g" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Non-constant operands to a binary bitwise operator shall have the same underlying type" id="MISRA2008-5_0_20" origId="CODSTA-66" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Bitwise operators shall only be applied to operands of unsigned underlying type" id="MISRA2008-5_0_21" origId="CODSTA-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A cvalue expression shall not be implicitly converted to a different underlying type" id="MISRA2008-5_0_3_a" origId="MISRA2004-10_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A cvalue expression shall not be implicitly converted to a different underlying type" id="MISRA2008-5_0_3_b" origId="MISRA2004-10_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A cvalue expression shall not be implicitly converted to a different underlying type" id="MISRA2008-5_0_3_c" origId="MISRA2004-10_1_i" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRA2008" desc="An implicit integral conversion shall not change the signedness of the underlying type" id="MISRA2008-5_0_4_a" origId="MISRA2004-10_1_a" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no implicit floating-integral conversions" id="MISRA2008-5_0_5_a" origId="MISRA2004-10_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no implicit floating-integral conversions" id="MISRA2008-5_0_5_b" origId="MISRA2004-10_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An implicit integral or floating-point conversion shall not reduce the size of the underlying type" id="MISRA2008-5_0_6_a" origId="CODSTA-222" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An implicit integral or floating-point conversion shall not reduce the size of the underlying type" id="MISRA2008-5_0_6_b" origId="MISRA2004-10_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An implicit integral or floating-point conversion shall not reduce the size of the underlying type" id="MISRA2008-5_0_6_c" origId="MISRA2004-10_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no explicit floating-integral conversions of a cvalue expression" id="MISRA2008-5_0_7_a" origId="MISRA2004-10_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no explicit floating-integral conversions of a cvalue expression" id="MISRA2008-5_0_7_b" origId="CODSTA-198_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression" id="MISRA2008-5_0_8" origId="MISRA2004-10_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An explicit integral or floating-point conversion shall not increase the size of the underlying type of a cvalue expression" id="MISRA2008-5_0_8_b" origId="CODSTA-198" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An explicit integral conversion shall not change the signedness of the underlying type of a cvalue expression" id="MISRA2008-5_0_9" origId="MISRA2004-10_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The right hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRA2008-5_14_1" origId="MISRA2004-12_4_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The overloaded binary operator should be implemented in terms of its corresponding compound assignment operator" id="MISRA2008-5_17_1" origId="CODSTA-CPP-91" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The comma operator shall not be used" id="MISRA2008-5_18_1" origId="MISRA2004-12_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Each operand of a logical &amp;&amp; or || shall be a postfix-expression" id="MISRA2008-5_2_1" origId="CODSTA-90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The &amp;&amp; operator and the || operator shall not be overloaded" id="MISRA2008-5_2_11" origId="CODSTA-CPP-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The comma &quot;,&quot; operator shall not be overloaded" id="MISRA2008-5_2_11_b" origId="CODSTA-CPP-80" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="MISRA2008-5_2_12" origId="PB-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="MISRA2008-5_2_2" origId="OOP-50" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="C-style casts (other than void casts) and functional notation casts (other than explicit constructor calls) shall not be used" id="MISRA2008-5_2_4" origId="CODSTA-CPP-66" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A cast shall not remove any const or volatile qualification from the type of a pointer or reference" id="MISRA2008-5_2_5" origId="MISRA2004-11_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A cast shall not convert a pointer to a function to any other pointer type, including a pointer to function type" id="MISRA2008-5_2_6" origId="CODSTA-62" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An object with pointer type shall not be converted to an unrelated pointer type, either directly or indirectly" id="MISRA2008-5_2_7" origId="MISRA2004-11_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An object with integer type or pointer to void type shall not be converted to an object with pointer type" id="MISRA2008-5_2_8" origId="CODSTA-65" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Each operand of the ! operator, the logical &amp;&amp; or the logical || operators shall have type bool" id="MISRA2008-5_3_1" origId="CODSTA-CPP-67" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The unary minus operator shall not be applied to an expression whose underlying type is unsigned" id="MISRA2008-5_3_2" origId="MISRA2004-12_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The unary &amp; operator shall not be overloaded" id="MISRA2008-5_3_3" origId="CODSTA-CPP-68" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Evaluation of the operand to the sizeof operator shall not contain side effects" id="MISRA2008-5_3_4" origId="MISRA2004-12_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Evaluation of the operand to the sizeof operator shall not contain side effects" id="MISRA2008-5_3_4_b" origId="MISRA2004-12_3_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Evaluation of the operand to the sizeof operator shall not contain side effects" id="MISRA2008-5_3_4_c" origId="MISRA2004-12_3_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The right hand operand of a shift operator shall lie between zero and one less than the width in bits of the underlying type of the left hand operand" id="MISRA2008-5_8_1" origId="MISRA2004-12_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Assignment operators shall not be used in sub-expressions" id="MISRA2008-6_2_1" origId="MISRA2004-13_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Floating-point expressions shall not be directly or indirectly tested for equality or inequality" id="MISRA2008-6_2_2" origId="MISRA2004-13_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Before preprocessing, a null statement shall only occur on a line by itself; it may be followed by a comment, provided that the first character following the null statement is a white-space character" id="MISRA2008-6_2_3" origId="MISRA2004-14_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The statement forming the body of a switch, while, do while or for statement shall be a compound statement" id="MISRA2008-6_3_1" origId="MISRA2004-14_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="MISRA2008" desc="An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement" id="MISRA2008-6_4_1" origId="MISRA2004-14_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All if ... else if constructs shall be terminated with an else clause" id="MISRA2008-6_4_2" origId="MISRA2004-14_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_a" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_b" origId="CODSTA-64" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_c" origId="CODSTA-61" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_d" origId="MISRA2004-15_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A switch statement shall be a well-formed switch statement" id="MISRA2008-6_4_3_e" origId="MISRA2004-15_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A switch-label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2008-6_4_4" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An unconditional throw or break statement shall terminate every non-empty switch-clause" id="MISRA2008-6_4_5" origId="CODSTA-64" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The final clause of a switch statement shall be the default-clause" id="MISRA2008-6_4_6" origId="CODSTA-61" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The condition of a switch statement shall not have bool type" id="MISRA2008-6_4_7" origId="MISRA2004-15_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Every switch statement shall have at least one case-clause" id="MISRA2008-6_4_8" origId="MISRA2004-15_5" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A for loop shall contain a single loop-counter which shall not have floating type" id="MISRA2008-6_5_1" origId="CODSTA-CPP-69" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If loop-counter is not modified by -- or ++, then, within condition, the loop-counter shall only be used as an operand to &lt;=, &lt;, > or >=" id="MISRA2008-6_5_2" origId="CODSTA-CPP-70" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The loop-counter shall not be modified within condition or statement" id="MISRA2008-6_5_3" origId="MISRA2004-13_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The loop-counter shall be modified by one of: --, ++, -=n, or +=n; where n remains constant for the duration of the loop" id="MISRA2008-6_5_4" origId="CODSTA-CPP-71" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A loop-control-variable other than the loop-counter shall not be modified within condition or expression" id="MISRA2008-6_5_5" origId="CODSTA-CPP-72" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A loop-control-variable other than the loop-counter which is modified in statement within a body of the loop shall have type bool" id="MISRA2008-6_5_6" origId="CODSTA-CPP-73" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="MISRA2008-6_6_1" origId="CODSTA-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The goto statement shall jump to a label declared later in the same function body" id="MISRA2008-6_6_2" origId="CODSTA-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The continue statement shall only be used within a well-formed for loop" id="MISRA2008-6_6_3" origId="CODSTA-80" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="MISRA2008-6_6_4" origId="CODSTA-79" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2008" desc="A function shall have a single point of exit at the end of the function" id="MISRA2008-6_6_5" origId="MISRA2004-14_7" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="1;" cat="MISRA2008" desc="Declare local variable as const whenever possible" id="MISRA2008-7_1_1" origId="CODSTA-CPP-53" sev="2" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A pointer parameter in a function shall be declared as pointer to const if the corresponding object is not modified" id="MISRA2008-7_1_2_a" origId="MISRA2004-16_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A reference parameter in a function shall be declared as reference to const if the corresponding object is not modified" id="MISRA2008-7_1_2_b" origId="CODSTA-CPP-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRA2008-7_1_2_c" origId="MISRA2004-16_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="MISRA2008-7_2_1" origId="PB-70" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="MISRA2008" desc="The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" id="MISRA2008-7_3_1" origId="CODSTA-CPP-36" sev="2" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The identifier main shall not be used for a function other than the global function main" id="MISRA2008-7_3_2" origId="CODSTA-76" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="There shall be no unnamed namespaces in header files" id="MISRA2008-7_3_3" origId="CODSTA-CPP-74" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2008" desc="using-directives shall not be used" id="MISRA2008-7_3_4" origId="CODSTA-CPP-75" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Multiple declarations for an identifier in the same namespace shall not straddle a using-declaration for that identifier" id="MISRA2008-7_3_5" origId="CODSTA-CPP-76" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="using-directives and using-declarations (excluding class scope or function scope using-declarations) shall not be used in header files" id="MISRA2008-7_3_6" origId="CODSTA-CPP-90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Assembler instructions shall only be introduced using the asm declaration" id="MISRA2008-7_4_2" origId="CODSTA-73" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Assembly language shall be encapsulated and isolated" id="MISRA2008-7_4_3" origId="CODSTA-114" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A function shall not return a reference or a pointer to an automatic variable (including parameters), defined within the function" id="MISRA2008-7_5_1" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2008-7_5_2_a" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2008-7_5_2_b" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference" id="MISRA2008-7_5_3" origId="PB-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An init-declarator-list or a member-declarator-list shall consist of a single init-declarator or member-declarator respectively" id="MISRA2008-8_0_1" origId="FORMAT-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Parameters in an overriding virtual function shall either use the same default arguments as the function they override, or else shall not specify any default arguments" id="MISRA2008-8_3_1" origId="OOP-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Functions shall not be defined using the ellipsis notation" id="MISRA2008-8_4_1" origId="MISRA-069" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The identifiers used for the parameters in a re-declaration of a function shall be identical to those in the declaration" id="MISRA2008-8_4_2" origId="MISRA2004-16_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRA2008-8_4_3" origId="MISRA2004-16_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A function identifier shall either be used to call the function or it shall be preceded by '&amp;'" id="MISRA2008-8_4_4" origId="MISRA2004-16_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All variables shall have a defined value before they are used" id="MISRA2008-8_5_1" origId="MISRA-030" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Braces shall be used to indicate and match the structure in the non-zero initialization of arrays and structures" id="MISRA2008-8_5_2" origId="INIT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Arrays shall not be partially initialized" id="MISRA2008-8_5_2_b" origId="MISRA2004-9_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Structures shall not be partially initialized" id="MISRA2008-8_5_2_c" origId="MISRA2004-9_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="In an enumerator list, the = construct shall not be used to explicitly initialize members other than the first, unless all items are explicitly initialized" id="MISRA2008-8_5_3" origId="MISRA2004-9_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="const member functions shall not return non-const pointers or references to class-data" id="MISRA2008-9_3_1" origId="CODSTA-CPP-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Protected member functions shall not return non-const handles to class-data" id="MISRA2008-9_3_2_a" origId="OOP-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Public member functions shall not return non-const handles to class-data" id="MISRA2008-9_3_2_b" origId="OOP-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="If a member function can be made static then it shall be made static, otherwise if it can be made const then it shall be made const" id="MISRA2008-9_3_3" origId="CODSTA-CPP-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Unions shall not be used" id="MISRA2008-9_5_1" origId="MISRA2004-18_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Bit-fields shall be either bool type or an explicitly unsigned or signed integral type" id="MISRA2008-9_6_2" origId="CODSTA-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Bit-fields shall not have enum type" id="MISRA2008-9_6_3" origId="CODSTA-74" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRA2008-9_6_4" origId="CODSTA-71" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Classes should not be derived from virtual bases" id="MISRA2008-10_1_1" origId="OOP-47" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All accessible entity names within a multiple inheritance hierarchy should be unique" id="MISRA2008-10_2_1" origId="CODSTA-CPP-92" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="MISRA2008-12_1_2" origId="PB-43" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The viable function set for a function call should either contain no function specializations, or only contain function specializations" id="MISRA2008-14_8_2" origId="TEMPL-08" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="An exception object should not have pointer type" id="MISRA2008-15_0_2" origId="EXCEPT-09" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="MISRA2008" desc="There should be at least one exception handler to catch all otherwise unhandled exceptions" id="MISRA2008-15_3_2" origId="EXCEPT-06" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The \ character should not occur in a header file name" id="MISRA2008-16_2_5" origId="NAMING-48" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The # and ## operators should not be used" id="MISRA2008-16_3_2" origId="MISRA2004-19_13" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The identifier name of a non-member object or function with static storage duration should not be reused" id="MISRA2008-2_10_5_a" origId="GLOBAL-REUSEDEXTVAR" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="MISRA2008" desc="The identifier name of a non-member object or function with static storage duration should not be reused" id="MISRA2008-2_10_5_b" origId="GLOBAL-REUSEDEXTFUN" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Digraphs should not be used" id="MISRA2008-2_5_1" origId="CODSTA-48" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Sections of code should not be &quot;commented out&quot; using C++ comments" id="MISRA2008-2_7_3" origId="MISRA2004-2_4" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="0;" cat="MISRA2008" desc="typedefs that indicate size and signedness should be used in place of the basic numerical types" id="MISRA2008-3_9_2" origId="MISRA-013" sev="4" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_a" origId="MISRA2004-12_1_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_b" origId="MISRA2004-12_1_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_c" origId="MISRA2004-12_1_c" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_d" origId="MISRA2004-12_1_d" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_e" origId="MISRA2004-12_1_e" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Limited dependence should be placed on C++ operator precedence rules in expressions" id="MISRA2008-5_0_2_f" origId="MISRA2004-12_1_f" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRA2008-5_19_1_a" origId="PB-66_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRA2008-5_19_1_b" origId="PB-66_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="The increment (++) and decrement (--) operators should not be mixed with arithmetic operators in an expression" id="MISRA2008-5_2_10" origId="CODSTA-232" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Casts from a base class to a derived class should not be performed on polymorphic types" id="MISRA2008-5_2_3" origId="OOP-49" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="A cast should not convert a pointer type to an integral type" id="MISRA2008-5_2_9" origId="MISRA2004-11_3_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Functions should not call themselves, either directly or indirectly" id="MISRA2008-7_5_4" origId="MISRA2004-16_2" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid accessing arrays out of bounds" id="MISRA2008-0_3_1_a" origId="BD-PB-ARRAY" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid null pointer dereferencing" id="MISRA2008-0_3_1_b" origId="BD-PB-NP" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid division by zero" id="MISRA2008-0_3_1_c" origId="BD-PB-ZERO" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRA2008-0_3_1_d" origId="BD-PB-OVERFFMT" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid overflow due to reading a not zero terminated string" id="MISRA2008-0_3_1_e" origId="BD-PB-OVERFNZT" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not check for null after dereferencing" id="MISRA2008-0_3_1_f" origId="BD-PB-DEREF" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid overflow when reading from a buffer" id="MISRA2008-0_3_1_g" origId="BD-PB-OVERFRD" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Avoid overflow when writing to a buffer" id="MISRA2008-0_3_1_h" origId="BD-PB-OVERFWR" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRA2008-0_3_1_i" origId="BD-PB-PTRSUB" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Do not compare two unrelated pointers" id="MISRA2008-0_3_1_j" origId="BD-PB-PTRCMP" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="Use of floating-point arithmetic shall be documented" id="MISRA2008-0_4_2" origId="COMMENT-10" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All uses of the #pragma directive shall be documented" id="MISRA2008-16_6_1" origId="MISRA2004-3_4" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2008" desc="All usage of assembler shall be documented" id="MISRA2008-7_4_1" origId="COMMENT-09" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Precautions shall be taken in order to prevent the contents of a header file being included more than once" id="MISRA2012-DIR-4_10" origId="PFO-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Validate values passed to library functions" id="MISRA2012-DIR-4_11" origId="BD-API-VALPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Dynamic memory allocation shall not be used" id="MISRA2012-DIR-4_12" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid tainted data in array indexes" id="MISRA2012-DIR-4_14_a" origId="BD-SECURITY-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Protect against integer overflow/underflow from tainted data" id="MISRA2012-DIR-4_14_b" origId="BD-SECURITY-INTOVERF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid buffer read overflow from tainted data" id="MISRA2012-DIR-4_14_c" origId="BD-SECURITY-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid buffer write overflow from tainted data" id="MISRA2012-DIR-4_14_d" origId="BD-SECURITY-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Protect against command injection" id="MISRA2012-DIR-4_14_e" origId="BD-SECURITY-TDCMD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Protect against file name injection" id="MISRA2012-DIR-4_14_f" origId="BD-SECURITY-TDFNAMES" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Protect against SQL injection" id="MISRA2012-DIR-4_14_g" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Prevent buffer overflows from tainted data" id="MISRA2012-DIR-4_14_h" origId="BD-SECURITY-BUFWRITE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="MISRA2012-DIR-4_14_i" origId="BD-SECURITY-OVERFFMT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Protect against environment injection" id="MISRA2012-DIR-4_14_j" origId="BD-SECURITY-TDENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid printing tainted data on the output console" id="MISRA2012-DIR-4_14_k" origId="BD-SECURITY-TDCONSOLE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Exclude unsanitized user input from format strings" id="MISRA2012-DIR-4_14_l" origId="BD-SECURITY-TDINPUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid accessing arrays out of bounds" id="MISRA2012-DIR-4_1_a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid null pointer dereferencing" id="MISRA2012-DIR-4_1_b" origId="BD-PB-NP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid division by zero" id="MISRA2012-DIR-4_1_c" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRA2012-DIR-4_1_d" origId="BD-PB-OVERFFMT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid overflow due to reading a not zero terminated string" id="MISRA2012-DIR-4_1_e" origId="BD-PB-OVERFNZT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not check for null after dereferencing" id="MISRA2012-DIR-4_1_f" origId="BD-PB-DEREF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid overflow when reading from a buffer" id="MISRA2012-DIR-4_1_g" origId="BD-PB-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid overflow when writing to a buffer" id="MISRA2012-DIR-4_1_h" origId="BD-PB-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRA2012-DIR-4_1_i" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not compare two unrelated pointers" id="MISRA2012-DIR-4_1_j" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid wraparounds when performing arithmetic integer operations" id="MISRA2012-DIR-4_1_k" origId="BD-PB-INTWRAP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Assembly language shall be encapsulated and isolated" id="MISRA2012-DIR-4_3" origId="MISRA2004-2_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Consistently check the returned value of non-void functions" id="MISRA2012-DIR-4_7_a" origId="BD-PB-CHECKRET" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Always check the returned value of non-void function" id="MISRA2012-DIR-4_7_b" origId="BD-PB-CHECKRETGEN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="All resources obtained dynamically by means of Standard Library functions shall be explicitly released" id="MISRA2012-DIR-4_13_a" origId="BD-RES-LEAKS" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not use resources that have been freed" id="MISRA2012-DIR-4_13_b" origId="BD-RES-FREE" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not free resources using invalid pointers" id="MISRA2012-DIR-4_13_c" origId="BD-RES-INVFREE" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not abandon unreleased locks" id="MISRA2012-DIR-4_13_d" origId="BD-TRS-LOCK" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Avoid double locking" id="MISRA2012-DIR-4_13_e" origId="BD-TRS-DLOCK" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Do not release a lock that has not been acquired" id="MISRA2012-DIR-4_13_f" origId="BD-TRS-REVLOCK" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="All usage of assembly language should be documented" id="MISRA2012-DIR-4_2" origId="COMMENT-09" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Sections of code should not be &quot;commented out&quot;" id="MISRA2012-DIR-4_4" origId="MISRA2004-2_4" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="MISRA2012-DIR-4_5" origId="NAMING-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="typedefs to basic types should contain some digits in their name" id="MISRA2012-DIR-4_6_a" origId="MISRA2004-6_3" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="MISRA2012-DIR" desc="typedefs should be used in place of the basic types" id="MISRA2012-DIR-4_6_b" origId="MISRA2004-6_3_b" sev="4" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="Use typedefs from stdint.h instead of declaring your own in C99 code" id="MISRA2012-DIR-4_6_c" origId="CODSTA-155" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="MISRA2012-DIR-4_8" origId="CODSTA-115" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-DIR" desc="A function should be used in preference to a function-like macro where they are interchangeable" id="MISRA2012-DIR-4_9" origId="MISRA2004-19_7" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="MISRA2012-RULE-12_5" origId="CODSTA-182" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A function shall not be declared implicitly" id="MISRA2012-RULE-17_3" origId="MISRA-071_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRA2012-RULE-17_4" origId="MISRA2004-16_8" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRA2012-RULE-17_4_b" origId="MISRA2004-16_8_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="MISRA2012-RULE-17_6" origId="CODSTA-160" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An object shall not be assigned or copied to an overlapping object" id="MISRA2012-RULE-19_1_a" origId="MISRA2004-18_2" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An object shall not be assigned or copied to an overlapping object" id="MISRA2012-RULE-19_1_b" origId="MISRA2004-18_2_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An object shall not be assigned or copied to an overlapping object" id="MISRA2012-RULE-19_1_c" origId="BD-PB-OVERLAP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Any value passed to a function in &lt;ctype.h> shall be representable as an 'unsigned char' or be the value 'EOF'" id="MISRA2012-RULE-21_13" origId="BD-API-CTYPE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid overflow due to reading a not zero terminated string" id="MISRA2012-RULE-21_17_a" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid overflow when writing to a buffer" id="MISRA2012-RULE-21_17_b" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The 'size_t' argument passed to any function in &lt;string.h> shall have an appropriate value" id="MISRA2012-RULE-21_18" origId="BD-API-STRSIZE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="MISRA2012-RULE-21_19_a" origId="CODSTA-185_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="MISRA2012-RULE-21_19_b" origId="CODSTA-185_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="MISRA2012-RULE-21_20" origId="BD-PB-INVRET" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use resources that have been freed" id="MISRA2012-RULE-22_2_a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not free resources using invalid pointers" id="MISRA2012-RULE-22_2_b" origId="BD-RES-INVFREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid writing to a stream which has been opened as read only" id="MISRA2012-RULE-22_4" origId="BD-PB-WRROS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A pointer to a FILE object shall not be dereferenced" id="MISRA2012-RULE-22_5_a" origId="CODSTA-166_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A pointer to a FILE object shall not be dereferenced by a library function" id="MISRA2012-RULE-22_5_b" origId="CODSTA-166_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of a pointer to a FILE shall not be used after the associated stream has been closed" id="MISRA2012-RULE-22_6" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid use before initialization" id="MISRA2012-RULE-9_1" origId="BD-PB-NOTINIT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="MISRA2012-RULE-10_1_a" origId="CODSTA-161_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="MISRA2012-RULE-10_1_b" origId="CODSTA-161_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="MISRA2012-RULE-10_1_c" origId="CODSTA-161_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="MISRA2012-RULE-10_1_d" origId="CODSTA-161_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="MISRA2012-RULE-10_1_e" origId="CODSTA-161_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An operand of essentially signed or enum type should not be used as right hand side operand to the bitwise shifting operator" id="MISRA2012-RULE-10_1_f" origId="CODSTA-161_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="MISRA2012-RULE-10_1_g" origId="CODSTA-161_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="MISRA2012-RULE-10_2" origId="CODSTA-162" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="MISRA2012-RULE-10_3_a" origId="CODSTA-163_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="MISRA2012-RULE-10_3_b" origId="CODSTA-163_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="MISRA2012-RULE-10_4_a" origId="CODSTA-164_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The second and third operands of the ternary operator shall have the same essential type category" id="MISRA2012-RULE-10_4_b" origId="CODSTA-164_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="MISRA2012-RULE-10_6" origId="CODSTA-157" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="MISRA2012-RULE-10_7_a" origId="CODSTA-156_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="MISRA2012-RULE-10_7_b" origId="CODSTA-156_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="MISRA2012-RULE-10_8" origId="CODSTA-152" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Conversions shall not be performed between a pointer to a function and any other type" id="MISRA2012-RULE-11_1_a" origId="CODSTA-124_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Conversions shall not be performed between a pointer to a function and any other type" id="MISRA2012-RULE-11_1_b" origId="CODSTA-124_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="MISRA2012-RULE-11_2" origId="CODSTA-125" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="MISRA2012-RULE-11_3" origId="CODSTA-126" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="MISRA2012-RULE-11_6" origId="CODSTA-129_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="MISRA2012-RULE-11_7" origId="CODSTA-130" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A conversion shall not remove any 'const', 'volatile' or '_Atomic' qualification from the type pointed to by a pointer" id="MISRA2012-RULE-11_8" origId="CODSTA-301" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The macro NULL shall be the only permitted form of integer null pointer constant" id="MISRA2012-RULE-11_9_a" origId="CODSTA-CPP-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The macro NULL shall be the only permitted form of integer null pointer constant" id="MISRA2012-RULE-11_9_b" origId="CODSTA-131" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid incorrect shift operations" id="MISRA2012-RULE-12_2" origId="BD-PB-BADSHIFT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Initializer lists shall not contain persistent side effects" id="MISRA2012-RULE-13_1_a" origId="CODSTA-141_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2012-RULE-13_2_a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRA2012-RULE-13_2_b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRA2012-RULE-13_2_c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRA2012-RULE-13_2_d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRA2012-RULE-13_2_e" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use more than one volatile in one expression" id="MISRA2012-RULE-13_2_f" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRA2012-RULE-13_2_g" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The right hand operand of a logical &amp;&amp; or || operator shall not contain persistent side effects" id="MISRA2012-RULE-13_5" origId="MISRA2004-12_4_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The operand of the sizeof operator shall not contain any expression which has potential side effects" id="MISRA2012-RULE-13_6_a" origId="MISRA2004-12_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The operand of the sizeof operator shall not contain any expression which has potential side effects" id="MISRA2012-RULE-13_6_b" origId="MISRA2004-12_3_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The operand of the sizeof operator shall not contain any expression which has potential side effects" id="MISRA2012-RULE-13_6_c" origId="CODSTA-137" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A loop counter in a 'for' loop shall not have essentially floating type" id="MISRA2012-RULE-14_1_a" origId="CODSTA-167_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="MISRA2012-RULE-14_1_b" origId="CODSTA-167_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="MISRA2012-RULE-14_2_a" origId="CODSTA-168" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The first clause of a 'for' loop shall be well-formed" id="MISRA2012-RULE-14_2_b" origId="CODSTA-169_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The second clause of a 'for' loop shall be well-formed" id="MISRA2012-RULE-14_2_c" origId="CODSTA-169_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The third clause of a 'for' statement shall be well-formed" id="MISRA2012-RULE-14_2_d" origId="CODSTA-169_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Controlling expressions shall not be invariant" id="MISRA2012-RULE-14_3_zc" origId="BD-PB-CC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The controlling expression of an if statement and the controlling expression of an iteration-statement shall have essentially Boolean type" id="MISRA2012-RULE-14_4" origId="MISRA2004-13_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The goto statement shall jump to a label declared later in the same function" id="MISRA2012-RULE-15_2" origId="CODSTA-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Any label referenced by a goto statement shall be declared in the same block, or in any block enclosing the goto statement" id="MISRA2012-RULE-15_3" origId="CODSTA-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The body of an iteration-statement or a selection-statement shall be a compound-statement" id="MISRA2012-RULE-15_6_a" origId="MISRA2004-14_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="MISRA2012-RULE" desc="The body of an iteration-statement or a selection-statement shall be a compound-statement" id="MISRA2012-RULE-15_6_b" origId="MISRA2004-14_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All 'if ... else if' constructs shall be terminated with an 'else' statement" id="MISRA2012-RULE-15_7" origId="MISRA2004-14_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRA2012-RULE-16_1_a" origId="MISRA2004-15_0_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2012-RULE-16_1_b" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRA2012-RULE-16_1_c" origId="MISRA2004-15_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRA2012-RULE-16_1_d" origId="MISRA2004-15_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Always provide a default branch for switch statements" id="MISRA2012-RULE-16_1_e" origId="CODSTA-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRA2012-RULE-16_1_f" origId="CODSTA-119" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRA2012-RULE-16_1_g" origId="CODSTA-116" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Every switch statement shall have at least two switch-clauses" id="MISRA2012-RULE-16_1_h" origId="OPT-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRA2012-RULE-16_2" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every switch-clause" id="MISRA2012-RULE-16_3_a" origId="MISRA2004-15_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An unconditional break statement shall terminate every switch-clause" id="MISRA2012-RULE-16_3_b" origId="MISRA2004-15_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Every 'switch' statement shall have a 'default' label" id="MISRA2012-RULE-16_4_a" origId="CODSTA-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRA2012-RULE-16_4_b" origId="CODSTA-119" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A default label shall appear as either the first or the last switch label of a switch statement" id="MISRA2012-RULE-16_5" origId="CODSTA-116" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Every switch statement shall have at least two switch-clauses" id="MISRA2012-RULE-16_6" origId="OPT-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A switch-expression shall not have essentially Boolean type" id="MISRA2012-RULE-16_7_a" origId="MISRA2004-15_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A switch-expression shall not have essentially Boolean type" id="MISRA2012-RULE-16_7_b" origId="MISRA2004-15_4_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The features of &lt;stdarg.h> shall not be used" id="MISRA2012-RULE-17_1_a" origId="CODSTA-136_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The features of &lt;stdarg.h> shall not be used" id="MISRA2012-RULE-17_1_b" origId="CODSTA-136_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Functions shall not call themselves, either directly or indirectly" id="MISRA2012-RULE-17_2" origId="MISRA2004-16_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="MISRA2012-RULE-17_5" origId="CODSTA-134" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2012-RULE" desc="The value returned by a function having non-void return type shall be used" id="MISRA2012-RULE-17_7_a" origId="CODSTA-122_a" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value returned by a function having non-void return type shall be used" id="MISRA2012-RULE-17_7_b" origId="CODSTA-122_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid accessing arrays out of bounds" id="MISRA2012-RULE-18_1_a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid accessing arrays and pointers out of bounds" id="MISRA2012-RULE-18_1_b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRA2012-RULE-18_1_c" origId="BD-PB-PTRARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Subtraction between pointers shall only be applied to pointers that address elements of the same array" id="MISRA2012-RULE-18_2" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc=">, >=, &lt;, &lt;= shall not be applied to objects of pointer type, except where they point to the same array" id="MISRA2012-RULE-18_3" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRA2012-RULE-18_6_a" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRA2012-RULE-18_6_b" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Flexible array members shall not be declared" id="MISRA2012-RULE-18_7" origId="CODSTA-113" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Variable-length arrays should not be used" id="MISRA2012-RULE-18_8" origId="CODSTA-112" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRA2012-RULE-1_1_a_c90" origId="CODSTA-174_a_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRA2012-RULE-1_1_a_c99" origId="CODSTA-174_a_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRA2012-RULE-1_1_b_c90" origId="CODSTA-174_b_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRA2012-RULE-1_1_b_c99" origId="CODSTA-174_b_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid division by zero" id="MISRA2012-RULE-1_3_a" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid use before initialization" id="MISRA2012-RULE-1_3_b" origId="BD-PB-NOTINIT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use resources that have been freed" id="MISRA2012-RULE-1_3_c" origId="BD-RES-FREE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid overflow when reading from a buffer" id="MISRA2012-RULE-1_3_d" origId="BD-PB-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid overflow when writing to a buffer" id="MISRA2012-RULE-1_3_e" origId="BD-PB-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRA2012-RULE-1_3_f" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRA2012-RULE-1_3_g" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRA2012-RULE-1_3_h" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRA2012-RULE-1_3_i" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRA2012-RULE-1_3_j" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use more than one volatile in one expression" id="MISRA2012-RULE-1_3_k" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRA2012-RULE-1_3_l" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A function shall not return a pointer or reference to a non-static local object" id="MISRA2012-RULE-1_3_m" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The address of an object with automatic storage shall not be assigned to an object which persists after the object has ceased to exist" id="MISRA2012-RULE-1_3_n" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="MISRA2012-RULE-1_3_o" origId="PB-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'" id="MISRA2012-RULE-1_4_j" origId="CODSTA-215" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The 'rsize_t' type should not be used" id="MISRA2012-RULE-1_4_k" origId="CODSTA-212" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The 'errno_t' type should not be used" id="MISRA2012-RULE-1_4_l" origId="CODSTA-217" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use following macros: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S" id="MISRA2012-RULE-1_4_m" origId="CODSTA-218" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use the functions defined in Annex K of ISO/IEC 9899:2011 standard" id="MISRA2012-RULE-1_4_n" origId="CODSTA-219" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="MISRA2012-RULE-20_11" origId="PREPROC-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="MISRA2012-RULE-20_12" origId="PREPROC-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A line whose first token is # shall be a valid preprocessing directive" id="MISRA2012-RULE-20_13" origId="MISRA2004-19_16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if, #ifdef or #ifndef directive to which they are related" id="MISRA2012-RULE-20_14" origId="MISRA2004-19_17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The ', &amp; or \ characters and the /* or // character sequences shall not occur in a header file name" id="MISRA2012-RULE-20_2_a" origId="NAMING-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The ', &amp; or \ characters and the /* or // character sequences shall not occur in a header file name" id="MISRA2012-RULE-20_2_b" origId="NAMING-48" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRA2012-RULE-20_3" origId="MISRA-089" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A macro shall not be defined with the same name as a keyword" id="MISRA2012-RULE-20_4_a" origId="CODSTA-133_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A macro shall not be defined with the same name as a keyword" id="MISRA2012-RULE-20_4_b" origId="CODSTA-133_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Tokens that look like a preprocessing directive shall not occur within a macro argument" id="MISRA2012-RULE-20_6" origId="MISRA2004-19_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Expressions resulting from the expansion of macro parameters shall be enclosed in parentheses" id="MISRA2012-RULE-20_7" origId="MISRA2004-19_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="MISRA2012-RULE-20_8" origId="PREPROC-19" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All identifiers used in the controlling expression of #if or #elif preprocessing directives shall be #define'd before evaluation" id="MISRA2012-RULE-20_9_b" origId="MISRA2004-19_11_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The standard header file &lt;time.h> shall not be used" id="MISRA2012-RULE-21_10" origId="MISRA2004-20_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The standard header file &lt;tgmath.h> shall not be used" id="MISRA2012-RULE-21_11" origId="CODSTA-108" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The features provided by &lt;fenv.h> should not be used" id="MISRA2012-RULE-21_12" origId="CODSTA-109" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The Standard Library function 'memcmp' shall not be used to compare null-terminated strings" id="MISRA2012-RULE-21_14" origId="BD-PB-MCCSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="MISRA2012-RULE-21_15" origId="CODSTA-183" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="MISRA2012-RULE-21_16" origId="CODSTA-184" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not #define or #undef identifiers with names which start with underscore" id="MISRA2012-RULE-21_1_a" origId="MISRA2004-20_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="#define and #undef shall not be used on a reserved identifier or reserved macro name (for C90 code)" id="MISRA2012-RULE-21_1_b" origId="CODSTA-92_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="#define and #undef shall not be used on a reserved identifier or reserved macro name (for C99 code)" id="MISRA2012-RULE-21_1_c" origId="CODSTA-92_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not #define nor #undef identifier 'defined'" id="MISRA2012-RULE-21_1_d" origId="MISRA2004-20_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The library function 'system' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_21" origId="SECURITY-48_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An identifier with name which starts with underscore shall not be declared" id="MISRA2012-RULE-21_2_a" origId="MISRA2004-20_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A reserved identifier or macro name shall not be declared (for C90 code)" id="MISRA2012-RULE-21_2_b" origId="MISRA2004-20_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A reserved identifier or macro name shall not be declared (for C99 code)" id="MISRA2012-RULE-21_2_c" origId="MISRA2004-20_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The memory allocation and deallocation functions of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_3" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The standard header file &lt;setjmp.h> shall not be used" id="MISRA2012-RULE-21_4_a" origId="MISRA2004-20_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The standard header file &lt;setjmp.h> shall not be used" id="MISRA2012-RULE-21_4_b" origId="MISRA2004-20_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The standard header file &lt;signal.h> shall not be used" id="MISRA2012-RULE-21_5_a" origId="MISRA2004-20_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The standard header file &lt;signal.h> shall not be used" id="MISRA2012-RULE-21_5_b" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRA2012-RULE" desc="The Standard Library input/output functions shall not be used" id="MISRA2012-RULE-21_6" origId="CODSTA-110" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2012-RULE" desc="The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_7" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The library function 'abort' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_8" origId="PB-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The library function 'exit' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_8_b" origId="PB-75_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The library functions 'quick_exit' and '_Exit' of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_8_c" origId="PB-75_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" id="MISRA2012-RULE-21_9" origId="CODSTA-107" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All resources obtained dynamically by means of Standard Library functions shall be explicitly released" id="MISRA2012-RULE-22_1" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of 'errno' shall only be tested when the last function to be called was an errno-setting-function" id="MISRA2012-RULE-22_10" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The same file shall not be opened for read and write access at the same time on different stream" id="MISRA2012-RULE-22_3" origId="BD-PB-WRRDSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The macro 'EOF' should be compared with the unmodified return value from the Standard Library function" id="MISRA2012-RULE-22_7" origId="BD-PB-EOFCOMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of 'errno' shall be set to zero prior to a call to an errno-setting-function" id="MISRA2012-RULE-22_8" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The value of 'errno' shall be tested against zero after calling an errno-setting-function" id="MISRA2012-RULE-22_9" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'else' block" id="MISRA2012-RULE-2_1_a" origId="MISRA2004-14_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code after 'return', 'break', 'continue', and 'goto' statements" id="MISRA2012-RULE-2_1_b" origId="MISRA2004-14_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'if', 'else', 'while', 'for' block" id="MISRA2012-RULE-2_1_c" origId="MISRA2004-14_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'switch' statement" id="MISRA2012-RULE-2_1_d" origId="MISRA2004-14_1_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code in 'for' loop" id="MISRA2012-RULE-2_1_e" origId="MISRA2004-14_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRA2012-RULE-2_1_f" origId="MISRA2004-14_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There shall be no unreachable code after 'if' or 'switch' statement inside 'while'/'for'/'do...while' loop" id="MISRA2012-RULE-2_1_g" origId="MISRA2004-14_1_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRA2012-RULE-2_2_a" origId="MISRA2004-14_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Avoid unused values" id="MISRA2012-RULE-2_2_b" origId="BD-PB-VOVR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The character sequence /* shall not be used within a C-style comment" id="MISRA2012-RULE-3_1_a" origId="MISRA2004-2_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The character sequence // shall not be used within a C-style comment" id="MISRA2012-RULE-3_1_b" origId="COMMENT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The character sequence /* shall not be used within a C++-style comment" id="MISRA2012-RULE-3_1_c" origId="COMMENT-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Line-splicing shall not be used in // comments" id="MISRA2012-RULE-3_2" origId="COMMENT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Octal and hexadecimal escape sequences shall be terminated" id="MISRA2012-RULE-4_1" origId="CODSTA-117" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="External identifiers shall be distinct" id="MISRA2012-RULE-5_1" origId="CODSTA-178" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="MISRA2012-RULE-5_2_a_c90" origId="CODSTA-179_a_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="MISRA2012-RULE-5_2_a_c99" origId="CODSTA-179_a_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="MISRA2012-RULE-5_2_b_c90" origId="CODSTA-179_b_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="MISRA2012-RULE-5_2_b_c99" origId="CODSTA-179_b_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2012-RULE-5_3_a" origId="MISRA2004-5_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An identifier declared in an inner scope shall not hide an identifier declared in an outer scope" id="MISRA2012-RULE-5_3_b" origId="MISRA2004-5_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of its parameters(c90)" id="MISRA2012-RULE-5_4_a_c90" origId="CODSTA-171_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of its parameters(c99)" id="MISRA2012-RULE-5_4_a_c99" origId="CODSTA-171_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="MISRA2012-RULE-5_4_b_c90" origId="CODSTA-172_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="MISRA2012-RULE-5_4_b_c99" origId="CODSTA-172_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers shall be distinct from macro names (c90)" id="MISRA2012-RULE-5_5_c90" origId="CODSTA-170_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers shall be distinct from macro names (c99)" id="MISRA2012-RULE-5_5_c99" origId="CODSTA-170_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A typedef name shall be a unique identifier" id="MISRA2012-RULE-5_6_a" origId="GLOBAL-UNIQUETYPEDEFC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="10;" authUrg="0;" cat="MISRA2012-RULE" desc="A tag name shall be a unique identifier" id="MISRA2012-RULE-5_7_a" origId="GLOBAL-UNIQUETYPEC" sev="2" total="10"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers that define objects with external linkage shall be unique" id="MISRA2012-RULE-5_8" origId="GLOBAL-REUSEDEXTVAR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Bit-fields shall only be declared with an appropriate type" id="MISRA2012-RULE-6_1" origId="MISRA2004-6_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Single-bit named bit fields shall not be of a signed type" id="MISRA2012-RULE-6_2" origId="CODSTA-71" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Octal constants shall not be used" id="MISRA2012-RULE-7_1" origId="MISRA2004-7_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A 'u' or 'U' suffix shall be applied to all integer constants that are represented in an unsigned type" id="MISRA2012-RULE-7_2" origId="MISRA2004-10_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The lowercase character 'l' shall not be used in a literal suffix" id="MISRA2012-RULE-7_3" origId="PORT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A string literal shall not be assigned to an object unless the object's type is pointer to const-qualified char" id="MISRA2012-RULE-7_4" origId="PB-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An inline function shall be declared with the static storage class" id="MISRA2012-RULE-8_10" origId="CODSTA-120" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="MISRA2012-RULE-8_12" origId="PB-58" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The restrict type qualifier shall not be used" id="MISRA2012-RULE-8_14" origId="CODSTA-121" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Whenever a function is declared or defined, its type shall be explicitly stated" id="MISRA2012-RULE-8_1_a" origId="MISRA2004-8_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Whenever an object is declared or defined, its type shall be explicitly stated" id="MISRA2012-RULE-8_1_b" origId="MISRA2004-8_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers shall be given for all of the parameters in a function prototype declaration" id="MISRA2012-RULE-8_2_a" origId="MISRA2004-16_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Function types shall have named parameters" id="MISRA2012-RULE-8_2_b" origId="CODSTA-158" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Function types shall be in prototype form" id="MISRA2012-RULE-8_2_c" origId="CODSTA-159" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRA2012-RULE-8_3_a" origId="MISRA2004-8_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRA2012-RULE-8_3_b" origId="MISRA2004-16_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="All declarations of an object or function shall have compatible types" id="MISRA2012-RULE-8_3_c" origId="GLOBAL-COMPATDECLS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A compatible declaration shall be visible when an object or function with external linkage is defined" id="MISRA2012-RULE-8_4_a" origId="CODSTA-118" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A compatible declaration shall be visible when an object or function with external linkage is defined" id="MISRA2012-RULE-8_4_b" origId="MISRA2004-8_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An external object or function shall not have more than one non-defining declaration in translation unit" id="MISRA2012-RULE-8_5" origId="CODSTA-154" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="MISRA2012-RULE" desc="An identifier with external linkage shall have exactly one external definition" id="MISRA2012-RULE-8_6" origId="GLOBAL-ONEEXTERNDEF" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The static storage class specifier shall be used in all declarations of objects and functions that have internal linkage" id="MISRA2012-RULE-8_8" origId="MISRA2004-8_11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The initializer for an aggregate or union shall be enclosed in braces" id="MISRA2012-RULE-9_2" origId="INIT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Arrays shall not be partially initialized" id="MISRA2012-RULE-9_3" origId="MISRA2004-9_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="An element of an object shall not be initialized more than once" id="MISRA2012-RULE-9_4" origId="PB-69" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="MISRA2012-RULE-9_5" origId="CODSTA-186" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The cast operation to essentially enumeration type is not allowed" id="MISRA2012-RULE-10_5_a" origId="CODSTA-165_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not cast from or to essentially Boolean type" id="MISRA2012-RULE-10_5_b" origId="CODSTA-165_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Do not use casts between essentially character types and essentially floating types" id="MISRA2012-RULE-10_5_c" origId="CODSTA-165_c" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A conversion should not be performed between a pointer to object and an integer type" id="MISRA2012-RULE-11_4" origId="CODSTA-127" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A conversion should not be performed from pointer to void into pointer to object" id="MISRA2012-RULE-11_5" origId="CODSTA-128" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Use parentheses to indicate the precedence of operators in expressions" id="MISRA2012-RULE-12_1_a" origId="FORMAT-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Parenthesis shall be used with 'sizeof' statement" id="MISRA2012-RULE-12_1_c" origId="FORMAT-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The comma operator should not be used" id="MISRA2012-RULE-12_3" origId="MISRA2004-12_10" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRA2012-RULE-12_4_a" origId="PB-66_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRA2012-RULE-12_4_b" origId="PB-66_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects other than that caused by the increment or decrement operator" id="MISRA2012-RULE-13_3" origId="CODSTA-123" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The result of an assignment operator should not be used" id="MISRA2012-RULE-13_4" origId="CODSTA-138" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The goto statement should not be used" id="MISRA2012-RULE-15_1" origId="MISRA2004-14_4" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There should be no more than one break or goto statement used to terminate any iteration statement" id="MISRA2012-RULE-15_4" origId="CODSTA-79" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2012-RULE" desc="A function should have a single point of exit at the end" id="MISRA2012-RULE-15_5" origId="MISRA2004-14_7" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A function parameter should not be modified" id="MISRA2012-RULE-17_8" origId="CODSTA-132" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The +, -, += and -= operators should not be applied to an expression of pointer type" id="MISRA2012-RULE-18_4" origId="CODSTA-181" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Declarations should contain no more than two levels of pointer nesting" id="MISRA2012-RULE-18_5" origId="MISRA2004-17_5" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The union keyword should not be used" id="MISRA2012-RULE-19_2" origId="CODSTA-111" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="#include directives should only be preceded by preprocessor directives or comments" id="MISRA2012-RULE-20_1" origId="MISRA2004-19_1" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="The # and ## preprocessor operators should not be used" id="MISRA2012-RULE-20_10" origId="MISRA2004-19_13" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="#undef should not be used" id="MISRA2012-RULE-20_5" origId="PREPROC-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A function should not contain unused type declarations" id="MISRA2012-RULE-2_3_a" origId="CODSTA-175_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A source file should not contain unused type declarations" id="MISRA2012-RULE-2_3_b" origId="CODSTA-175_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A function should not contain unused local tag declarations" id="MISRA2012-RULE-2_4_a" origId="CODSTA-176_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A source file should not contain unused tag declarations" id="MISRA2012-RULE-2_4_b" origId="CODSTA-176_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A source file should not contain unused macro definitions" id="MISRA2012-RULE-2_5" origId="CODSTA-177" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A function should not contain unused label declarations" id="MISRA2012-RULE-2_6" origId="OPT-37" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="There should be no unused parameters in functions" id="MISRA2012-RULE-2_7" origId="OPT-38" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Trigraphs should not be used" id="MISRA2012-RULE-4_2" origId="MISRA2004-4_2" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers that define objects with internal linkage should be unique" id="MISRA2012-RULE-5_9_a" origId="GLOBAL-REUSEDSTATVAR" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Identifiers that define functions with internal linkage should be unique" id="MISRA2012-RULE-5_9_b" origId="GLOBAL-REUSEDSTATFUN" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="When an array with external linkage is declared, its size should be explicitly specified" id="MISRA2012-RULE-8_11" origId="MISRA2004-8_12" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRA2012-RULE-8_13_a" origId="MISRA2004-16_7" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRA2012-RULE-8_13_b" origId="MISRA2004-16_7_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRA2012-RULE" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="MISRA2012-RULE-8_7" origId="GLOBAL-AVOIDEXTERN" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRA2012-RULE" desc="An object should be defined at block scope if its identifier only appears in a single function" id="MISRA2012-RULE-8_9" origId="MISRA2004-8_7" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid accessing arrays out of bounds" id="MISRAC2012-DIR_4_1-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid null pointer dereferencing" id="MISRAC2012-DIR_4_1-b" origId="BD-PB-NP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid division by zero" id="MISRAC2012-DIR_4_1-c" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid buffer overflow due to defining incorrect format limits" id="MISRAC2012-DIR_4_1-d" origId="BD-PB-OVERFFMT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid overflow due to reading a not zero terminated string" id="MISRAC2012-DIR_4_1-e" origId="BD-PB-OVERFNZT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Do not check for null after dereferencing" id="MISRAC2012-DIR_4_1-f" origId="BD-PB-DEREF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid overflow when reading from a buffer" id="MISRAC2012-DIR_4_1-g" origId="BD-PB-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-DIR_4_1-h" origId="BD-PB-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRAC2012-DIR_4_1-i" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Do not compare two unrelated pointers" id="MISRAC2012-DIR_4_1-j" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_1" desc="Avoid wraparounds when performing arithmetic integer operations" id="MISRAC2012-DIR_4_1-k" origId="BD-PB-INTWRAP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_10" desc="Use multiple include guards" id="MISRAC2012-DIR_4_10-a" origId="PFO-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_11" desc="Validate values passed to library functions" id="MISRAC2012-DIR_4_11-a" origId="BD-API-VALPARAM" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_12" desc="Dynamic heap memory allocation shall not be used" id="MISRAC2012-DIR_4_12-a" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Ensure resources are freed" id="MISRAC2012-DIR_4_13-a" origId="BD-RES-LEAKS" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not use resources that have been freed" id="MISRAC2012-DIR_4_13-b" origId="BD-RES-FREE" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not free resources using invalid pointers" id="MISRAC2012-DIR_4_13-c" origId="BD-RES-INVFREE" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not abandon unreleased locks" id="MISRAC2012-DIR_4_13-d" origId="BD-TRS-LOCK" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Avoid double locking" id="MISRAC2012-DIR_4_13-e" origId="BD-TRS-DLOCK" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_13" desc="Do not release a lock that has not been acquired" id="MISRAC2012-DIR_4_13-f" origId="BD-TRS-REVLOCK" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid tainted data in array indexes" id="MISRAC2012-DIR_4_14-a" origId="BD-SECURITY-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against integer overflow/underflow from tainted data" id="MISRAC2012-DIR_4_14-b" origId="BD-SECURITY-INTOVERF" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid buffer read overflow from tainted data" id="MISRAC2012-DIR_4_14-c" origId="BD-SECURITY-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid buffer write overflow from tainted data" id="MISRAC2012-DIR_4_14-d" origId="BD-SECURITY-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against command injection" id="MISRAC2012-DIR_4_14-e" origId="BD-SECURITY-TDCMD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against file name injection" id="MISRAC2012-DIR_4_14-f" origId="BD-SECURITY-TDFNAMES" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against SQL injection" id="MISRAC2012-DIR_4_14-g" origId="BD-SECURITY-TDSQL" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Prevent buffer overflows from tainted data" id="MISRAC2012-DIR_4_14-h" origId="BD-SECURITY-BUFWRITE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="MISRAC2012-DIR_4_14-i" origId="BD-SECURITY-OVERFFMT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Protect against environment injection" id="MISRAC2012-DIR_4_14-j" origId="BD-SECURITY-TDENV" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Avoid printing tainted data on the output console" id="MISRAC2012-DIR_4_14-k" origId="BD-SECURITY-TDCONSOLE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_14" desc="Exclude unsanitized user input from format strings" id="MISRAC2012-DIR_4_14-l" origId="BD-SECURITY-TDINPUT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_2" desc="All usage of assembler shall be documented" id="MISRAC2012-DIR_4_2-a" origId="COMMENT-09" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_3" desc="Assembly language shall be encapsulated and isolated" id="MISRAC2012-DIR_4_3-a" origId="MISRA2004-2_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_4" desc="Sections of code should not be &quot;commented out&quot;" id="MISRAC2012-DIR_4_4-a" origId="MISRA2004-2_4" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_5" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="MISRAC2012-DIR_4_5-a" origId="NAMING-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_6" desc="typedefs to basic types should contain some digits in their name" id="MISRAC2012-DIR_4_6-a" origId="MISRA2004-6_3" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="MISRAC2012-DIR_4_6" desc="typedefs should be used in place of the basic types" id="MISRAC2012-DIR_4_6-b" origId="MISRA2004-6_3_b" sev="4" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_6" desc="Use typedefs from stdint.h instead of declaring your own in C99 code" id="MISRAC2012-DIR_4_6-c" origId="CODSTA-155" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_7" desc="Consistently check the returned value of non-void functions" id="MISRAC2012-DIR_4_7-a" origId="BD-PB-CHECKRET" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_7" desc="Always check the returned value of non-void function" id="MISRAC2012-DIR_4_7-b" origId="BD-PB-CHECKRETGEN" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_8" desc="If a pointer to a structure or union is never dereferenced within a translation unit, then the implementation of the object should be hidden" id="MISRAC2012-DIR_4_8-a" origId="CODSTA-115" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-DIR_4_9" desc="A function should be used in preference to a function-like macro" id="MISRAC2012-DIR_4_9-a" origId="MISRA2004-19_7" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An expression of essentially Boolean type should always be used where an operand is interpreted as a Boolean value" id="MISRAC2012-RULE_10_1-a" origId="CODSTA-161_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially Boolean type should not be used where an operand is interpreted as a numeric value" id="MISRAC2012-RULE_10_1-b" origId="CODSTA-161_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially character type should not be used where an operand is interpreted as a numeric value" id="MISRAC2012-RULE_10_1-c" origId="CODSTA-161_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially enum type should not be used in an arithmetic operation" id="MISRAC2012-RULE_10_1-d" origId="CODSTA-161_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="Shift and bitwise operations should not be performed on operands of essentially signed or enum type" id="MISRAC2012-RULE_10_1-e" origId="CODSTA-161_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially signed or enum type should not be used as the right hand operand to the bitwise shifting operator" id="MISRAC2012-RULE_10_1-f" origId="CODSTA-161_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_1" desc="An operand of essentially unsigned type should not be used as the operand to the unary minus operator" id="MISRAC2012-RULE_10_1-g" origId="CODSTA-161_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_2" desc="Expressions of essentially character type shall not be used inappropriately in addition and subtraction operations" id="MISRAC2012-RULE_10_2-a" origId="CODSTA-162" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_3" desc="The value of an expression shall not be assigned to an object with a narrower essential type" id="MISRAC2012-RULE_10_3-a" origId="CODSTA-163_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_3" desc="The value of an expression shall not be assigned to an object of a different essential type category" id="MISRAC2012-RULE_10_3-b" origId="CODSTA-163_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_4" desc="Both operands of an operator in which the usual arithmetic conversions are performed shall have the same essential type category" id="MISRAC2012-RULE_10_4-a" origId="CODSTA-164_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_4" desc="The second and third operands of the ternary operator shall have the same essential type category" id="MISRAC2012-RULE_10_4-b" origId="CODSTA-164_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_5" desc="The cast operation to essentially enumeration type is not allowed" id="MISRAC2012-RULE_10_5-a" origId="CODSTA-165_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_5" desc="Do not cast from or to essentially Boolean type" id="MISRAC2012-RULE_10_5-b" origId="CODSTA-165_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_5" desc="Do not use casts between essentially character types and essentially floating types" id="MISRAC2012-RULE_10_5-c" origId="CODSTA-165_c" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_6" desc="The value of a composite expression shall not be assigned to an object with wider essential type" id="MISRAC2012-RULE_10_6-a" origId="CODSTA-157" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_7" desc="If a composite expression is used as one operand of an operator in which the usual arithmetic conversions are performed then the other operand shall not have wider essential type" id="MISRAC2012-RULE_10_7-a" origId="CODSTA-156_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_7" desc="If a composite expression is used as one (second or third) operand of a conditional operator then the other operand shall not have wider essential type" id="MISRAC2012-RULE_10_7-b" origId="CODSTA-156_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_10_8" desc="The value of a composite expression shall not be cast to a different essential type category or a wider essential type" id="MISRAC2012-RULE_10_8-a" origId="CODSTA-152" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_1" desc="Conversions shall not be performed between a pointer to a function and any other type than pointer to function" id="MISRAC2012-RULE_11_1-a" origId="CODSTA-124_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_1" desc="Conversions shall not be performed between non compatible pointer to a function types" id="MISRAC2012-RULE_11_1-b" origId="CODSTA-124_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_2" desc="Conversions shall not be performed between a pointer to an incomplete type and any other type" id="MISRAC2012-RULE_11_2-a" origId="CODSTA-125" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_3" desc="A cast shall not be performed between a pointer to object type and a pointer to a different object type" id="MISRAC2012-RULE_11_3-a" origId="CODSTA-126" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_4" desc="A conversion should not be performed between a pointer to object and an integer type" id="MISRAC2012-RULE_11_4-a" origId="CODSTA-127" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_5" desc="A conversion should not be performed from pointer to void into pointer to object" id="MISRAC2012-RULE_11_5-a" origId="CODSTA-128" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_6" desc="A cast shall not be performed between pointer to void and an arithmetic type" id="MISRAC2012-RULE_11_6-a" origId="CODSTA-129_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_7" desc="A cast shall not be performed between pointer to object and a non-integer arithmetic type" id="MISRAC2012-RULE_11_7-a" origId="CODSTA-130" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_8" desc="A conversion shall not remove any 'const', 'volatile' or '_Atomic' qualification from the type pointed to by a pointer" id="MISRAC2012-RULE_11_8-a" origId="CODSTA-301" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_9" desc="Literal zero (0) shall not be used as the null-pointer-constant" id="MISRAC2012-RULE_11_9-a" origId="CODSTA-CPP-63" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_11_9" desc="Use NULL instead of literal zero (0) as the null-pointer-constant" id="MISRAC2012-RULE_11_9-b" origId="CODSTA-131" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_1" desc="Use parentheses to indicate the precedence of operators in expressions" id="MISRAC2012-RULE_12_1-a" origId="FORMAT-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_1" desc="The operand of the 'sizeof' operator should be enclosed in parentheses" id="MISRAC2012-RULE_12_1-c" origId="FORMAT-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_2" desc="Avoid incorrect shift operations" id="MISRAC2012-RULE_12_2-a" origId="BD-PB-BADSHIFT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_3" desc="The comma operator shall not be used" id="MISRAC2012-RULE_12_3-a" origId="MISRA2004-12_10" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_4" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="MISRAC2012-RULE_12_4-a" origId="PB-66_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_4" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="MISRAC2012-RULE_12_4-b" origId="PB-66_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_12_5" desc="The 'sizeof' operator shall not have an operand which is a function parameter declared as &quot;array of type&quot;" id="MISRAC2012-RULE_12_5-a" origId="CODSTA-182" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_1" desc="Initializer lists shall not contain persistent side effects" id="MISRAC2012-RULE_13_1-a" origId="CODSTA-141_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRAC2012-RULE_13_2-a" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRAC2012-RULE_13_2-b" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRAC2012-RULE_13_2-c" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRAC2012-RULE_13_2-d" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRAC2012-RULE_13_2-e" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRAC2012-RULE_13_2-f" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_2" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRAC2012-RULE_13_2-g" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_3" desc="A full expression containing an increment (++) or decrement (--) operator should have no other potential side effects" id="MISRAC2012-RULE_13_3-a" origId="CODSTA-123" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_4" desc="The result of a built-in assignment operator should not be used" id="MISRAC2012-RULE_13_4-a" origId="CODSTA-138" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_5" desc="The right-hand operand of a logical &amp;&amp; or || operator shall not contain side effects" id="MISRAC2012-RULE_13_5-a" origId="MISRA2004-12_4_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_6" desc="The operand of the sizeof operator shall not contain any expression which has side effects" id="MISRAC2012-RULE_13_6-a" origId="MISRA2004-12_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_6" desc="Object designated by a volatile lvalue should not be accessed in the operand of the sizeof operator" id="MISRAC2012-RULE_13_6-b" origId="MISRA2004-12_3_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_13_6" desc="The function call shall not be the operand of the sizeof operator" id="MISRAC2012-RULE_13_6-c" origId="CODSTA-137" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_1" desc="A loop counter in a 'for' loop shall not have essentially floating type" id="MISRAC2012-RULE_14_1-a" origId="CODSTA-167_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_1" desc="A loop counter in 'while' and 'do-while' loops shall not have essentially floating type" id="MISRAC2012-RULE_14_1-b" origId="CODSTA-167_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="There shall only be one loop counter in a 'for' loop, which shall not be modified in the 'for' loop body" id="MISRAC2012-RULE_14_2-a" origId="CODSTA-168" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="The first clause of a 'for' loop shall be well-formed" id="MISRAC2012-RULE_14_2-b" origId="CODSTA-169_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="The second clause of a 'for' loop shall be well-formed" id="MISRAC2012-RULE_14_2-c" origId="CODSTA-169_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_2" desc="The third clause of a 'for' statement shall be well-formed" id="MISRAC2012-RULE_14_2-d" origId="CODSTA-169_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_3" desc="Avoid conditions that always evaluate to the same value" id="MISRAC2012-RULE_14_3-ac" origId="BD-PB-CC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_14_4" desc="Tests of a value against zero should be made explicit, unless the operand is effectively Boolean" id="MISRAC2012-RULE_14_4-a" origId="MISRA2004-13_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_1" desc="The goto statement shall not be used" id="MISRAC2012-RULE_15_1-a" origId="MISRA2004-14_4" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_2" desc="The goto statement shall jump to a label declared later in the same function body" id="MISRAC2012-RULE_15_2-a" origId="CODSTA-77" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_3" desc="Any label referenced by a goto statement shall be declared in the same block, or in a block enclosing the goto statement" id="MISRAC2012-RULE_15_3-a" origId="CODSTA-78" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_4" desc="For any iteration statement there shall be no more than one break or goto statement used for loop termination" id="MISRAC2012-RULE_15_4-a" origId="CODSTA-79" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_15_5" desc="A function shall have a single point of exit at the end of the function" id="MISRAC2012-RULE_15_5-a" origId="MISRA2004-14_7" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_6" desc="The statement forming the body of a 'switch', 'while', 'do...while' or 'for' statement shall be a compound statement" id="MISRAC2012-RULE_15_6-a" origId="MISRA2004-14_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="MISRAC2012-RULE_15_6" desc="'if' and 'else' should be followed by a compound statement" id="MISRAC2012-RULE_15_6-b" origId="MISRA2004-14_9" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_15_7" desc="All 'if...else-if' constructs shall be terminated with an 'else' clause" id="MISRAC2012-RULE_15_7-a" origId="MISRA2004-14_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A switch statement shall only contain switch labels and switch clauses, and no other code" id="MISRAC2012-RULE_16_1-a" origId="MISRA2004-15_0_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRAC2012-RULE_16_1-b" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRAC2012-RULE_16_1-c" origId="MISRA2004-15_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRAC2012-RULE_16_1-d" origId="MISRA2004-15_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="Always provide a default branch for switch statements" id="MISRAC2012-RULE_16_1-e" origId="CODSTA-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRAC2012-RULE_16_1-f" origId="CODSTA-119" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRAC2012-RULE_16_1-g" origId="CODSTA-116" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_1" desc="Every switch statement shall have at least two switch-clauses" id="MISRAC2012-RULE_16_1-h" origId="OPT-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_2" desc="A switch label shall only be used when the most closely-enclosing compound statement is the body of a switch statement" id="MISRAC2012-RULE_16_2-a" origId="MISRA2004-15_1" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_3" desc="An unconditional break statement shall terminate every non-empty case clause" id="MISRAC2012-RULE_16_3-a" origId="MISRA2004-15_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_3" desc="An unconditional break statement shall terminate every non-empty default clause" id="MISRAC2012-RULE_16_3-b" origId="MISRA2004-15_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_4" desc="Always provide a default branch for switch statements" id="MISRAC2012-RULE_16_4-a" origId="CODSTA-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_4" desc="A 'default' label shall have a statement or a comment before terminating 'break'" id="MISRAC2012-RULE_16_4-b" origId="CODSTA-119" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_5" desc="A 'default' label, if it exists, shall appear as either the first or the last switch label of a switch statement" id="MISRAC2012-RULE_16_5-a" origId="CODSTA-116" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_6" desc="Every switch statement shall have at least two switch-clauses" id="MISRAC2012-RULE_16_6-a" origId="OPT-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRAC2012-RULE_16_7-a" origId="MISRA2004-15_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_16_7" desc="A switch expression shall not represent a value that is effectively Boolean" id="MISRAC2012-RULE_16_7-b" origId="MISRA2004-15_4_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_1" desc="The identifiers va_list, va_arg, va_start, va_end, va_copy should not be used" id="MISRAC2012-RULE_17_1-a" origId="CODSTA-136_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_1" desc="The identifiers va_list, va_arg, va_start, va_end should not be used" id="MISRAC2012-RULE_17_1-b" origId="CODSTA-136_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_2" desc="Functions shall not call themselves, either directly or indirectly" id="MISRAC2012-RULE_17_2-a" origId="MISRA2004-16_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_3" desc="Functions shall always have visible prototype at the function call" id="MISRAC2012-RULE_17_3-a" origId="MISRA-071_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_4" desc="All exit paths from a function with non-void return type shall have an explicit return statement with an expression" id="MISRAC2012-RULE_17_4-a" origId="MISRA2004-16_8" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_4" desc="All exit paths from a function, except main(), with non-void return type shall have an explicit return statement with an expression" id="MISRAC2012-RULE_17_4-b" origId="MISRA2004-16_8_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_5" desc="The function argument corresponding to a parameter declared to have an array type shall have an appropriate number of elements" id="MISRAC2012-RULE_17_5-a" origId="CODSTA-134" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_6" desc="The declaration of an array parameter shall not contain the 'static' keyword between the [ ]" id="MISRAC2012-RULE_17_6-a" origId="CODSTA-160" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_17_7" desc="The value returned by a function having non-void return type shall be used" id="MISRAC2012-RULE_17_7-a" origId="CODSTA-122_a" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_7" desc="The value returned by a function having non-void return type shall be used" id="MISRAC2012-RULE_17_7-b" origId="CODSTA-122_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_17_8" desc="A function parameter should not be modified" id="MISRAC2012-RULE_17_8-a" origId="CODSTA-132" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_1" desc="Avoid accessing arrays out of bounds" id="MISRAC2012-RULE_18_1-a" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_1" desc="Avoid accessing arrays and pointers out of bounds" id="MISRAC2012-RULE_18_1-b" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_1" desc="A pointer operand and any pointer resulting from pointer arithmetic using that operand shall both address elements of the same array" id="MISRAC2012-RULE_18_1-c" origId="BD-PB-PTRARR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_2" desc="Do not subtract two pointers that do not address elements of the same array" id="MISRAC2012-RULE_18_2-a" origId="BD-PB-PTRSUB" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_3" desc="Do not compare two unrelated pointers" id="MISRAC2012-RULE_18_3-a" origId="BD-PB-PTRCMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_4" desc="The +, -, += and -= operators should not be applied to an expression of pointer type" id="MISRAC2012-RULE_18_4-a" origId="CODSTA-181" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_5" desc="The declaration of objects should contain no more than 2 levels of pointer indirection" id="MISRAC2012-RULE_18_5-a" origId="MISRA2004-17_5" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_6" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRAC2012-RULE_18_6-a" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_6" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRAC2012-RULE_18_6-b" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_7" desc="Flexible array members shall not be declared" id="MISRAC2012-RULE_18_7-a" origId="CODSTA-113" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_18_8" desc="Variable-length arrays should not be used" id="MISRAC2012-RULE_18_8-a" origId="CODSTA-112" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned to an overlapping object" id="MISRAC2012-RULE_19_1-a" origId="MISRA2004-18_2" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned to an overlapping object" id="MISRAC2012-RULE_19_1-b" origId="MISRA2004-18_2_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_1" desc="An object shall not be assigned or copied to an overlapping object" id="MISRAC2012-RULE_19_1-c" origId="BD-PB-OVERLAP" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_19_2" desc="The union keyword should not be used" id="MISRAC2012-RULE_19_2-a" origId="CODSTA-111" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRAC2012-RULE_1_1-a" origId="CODSTA-174_a_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRAC2012-RULE_1_1-b" origId="CODSTA-174_a_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c90)" id="MISRAC2012-RULE_1_1-c" origId="CODSTA-174_b_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_1" desc="A program should not exceed the translation limits imposed by The Standard (c99)" id="MISRAC2012-RULE_1_1-d" origId="CODSTA-174_b_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid division by zero" id="MISRAC2012-RULE_1_3-a" origId="BD-PB-ZERO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid use before initialization" id="MISRAC2012-RULE_1_3-b" origId="BD-PB-NOTINIT" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_1_3-c" origId="BD-RES-FREE" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid overflow when reading from a buffer" id="MISRAC2012-RULE_1_3-d" origId="BD-PB-OVERFRD" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-RULE_1_3-e" origId="BD-PB-OVERFWR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The value of an expression shall be the same under any order of evaluation that the standard permits" id="MISRAC2012-RULE_1_3-f" origId="MISRA2004-12_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function arguments" id="MISRAC2012-RULE_1_3-g" origId="MISRA2004-12_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function designator and function arguments" id="MISRAC2012-RULE_1_3-h" origId="MISRA2004-12_2_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of expression that involves a function call" id="MISRAC2012-RULE_1_3-i" origId="MISRA2004-12_2_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Between sequence points an object shall have its stored value modified at most once by the evaluation of an expression" id="MISRAC2012-RULE_1_3-j" origId="MISRA2004-12_2_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Do not use more than one volatile between two adjacent sequence points" id="MISRAC2012-RULE_1_3-k" origId="MISRA2004-12_2_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="Don't write code that depends on the order of evaluation of function calls" id="MISRAC2012-RULE_1_3-l" origId="MISRA2004-12_2_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The address of an object with automatic storage shall not be returned from a function" id="MISRAC2012-RULE_1_3-m" origId="MISRA2004-17_6_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The address of an object with automatic storage shall not be assigned to another object that may persist after the first object has ceased to exist" id="MISRAC2012-RULE_1_3-n" origId="MISRA2004-17_6_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_3" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="MISRAC2012-RULE_1_3-o" origId="PB-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The '__STDC_WANT_LIB_EXT1__' macro should not be defined to the value other than '0'" id="MISRAC2012-RULE_1_4-j" origId="CODSTA-215" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The 'rsize_t' type should not be used" id="MISRAC2012-RULE_1_4-k" origId="CODSTA-212" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="The 'errno_t' type should not be used" id="MISRAC2012-RULE_1_4-l" origId="CODSTA-217" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="Do not use following macros: RSIZE_MAX, L_tmpnam_s, TMP_MAX_S" id="MISRAC2012-RULE_1_4-m" origId="CODSTA-218" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_1_4" desc="Do not use the functions defined in Annex K of ISO/IEC 9899:2011 standard" id="MISRAC2012-RULE_1_4-n" origId="CODSTA-219" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_1" desc="#include statements in a file should only be preceded by other preprocessor directives or comments" id="MISRAC2012-RULE_20_1-a" origId="MISRA2004-19_1" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_10" desc="The # and ## preprocessor operators should not be used" id="MISRAC2012-RULE_20_10-a" origId="MISRA2004-19_13" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_11" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="MISRAC2012-RULE_20_11-a" origId="PREPROC-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_12" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="MISRAC2012-RULE_20_12-a" origId="PREPROC-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_13" desc="Preprocessing directives shall be syntactically meaningful even when excluded by the preprocessor" id="MISRAC2012-RULE_20_13-a" origId="MISRA2004-19_16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_14" desc="All #else, #elif and #endif preprocessor directives shall reside in the same file as the #if or #ifdef directive to which they are related" id="MISRAC2012-RULE_20_14-a" origId="MISRA2004-19_17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_2" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="MISRAC2012-RULE_20_2-a" origId="NAMING-46" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_2" desc="The \ character should not occur in a header file name" id="MISRAC2012-RULE_20_2-b" origId="NAMING-48" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_3" desc="The #include directive shall be followed by either a &lt;filename> or &quot;filename&quot; sequence" id="MISRAC2012-RULE_20_3-a" origId="MISRA-089" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_4" desc="A macro shall not be defined with the same name as a keyword in C90" id="MISRAC2012-RULE_20_4-a" origId="CODSTA-133_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_4" desc="A macro shall not be defined with the same name as a keyword in C99" id="MISRAC2012-RULE_20_4-b" origId="CODSTA-133_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_5" desc="#undef shall not be used" id="MISRAC2012-RULE_20_5-a" origId="PREPROC-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_6" desc="Arguments to a function-like macro shall not contain tokens that look like preprocessing directives" id="MISRAC2012-RULE_20_6-a" origId="MISRA2004-19_9" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_7" desc="In the definition of a function-like macro each instance of a parameter shall be enclosed in parentheses unless it is used as the operand of # or ##" id="MISRAC2012-RULE_20_7-a" origId="MISRA2004-19_10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_8" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="MISRAC2012-RULE_20_8-a" origId="PREPROC-19" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_20_9" desc="Do not use in preprocessor directives #if and #elif macros not defined in translation unit" id="MISRAC2012-RULE_20_9-b" origId="MISRA2004-19_11_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Do not #define or #undef identifiers with names which start with underscore" id="MISRAC2012-RULE_21_1-a" origId="MISRA2004-20_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C90 code)" id="MISRAC2012-RULE_21_1-b" origId="CODSTA-92_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Reserved identifiers, macros and functions in the standard library, shall not be defined, redefined or undefined (C99 code)" id="MISRAC2012-RULE_21_1-c" origId="CODSTA-92_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_1" desc="Do not #define nor #undef identifier 'defined'" id="MISRAC2012-RULE_21_1-d" origId="MISRA2004-20_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_10" desc="The standard header files &lt;time.h> or &lt;ctime> shall not be used" id="MISRAC2012-RULE_21_10-a" origId="MISRA2004-20_12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_11" desc="The standard header file &lt;tgmath.h> shall not be used" id="MISRAC2012-RULE_21_11-a" origId="CODSTA-108" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_12" desc="The features provided by &lt;fenv.h> should not be used" id="MISRAC2012-RULE_21_12-a" origId="CODSTA-109" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_13" desc="Do not pass incorrect values to ctype.h library functions" id="MISRAC2012-RULE_21_13-a" origId="BD-API-CTYPE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_14" desc="The Standard Library function memcmp shall not be used to compare null terminated strings" id="MISRAC2012-RULE_21_14-a" origId="BD-PB-MCCSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_15" desc="The pointer arguments to the Standard Library functions 'memcmp', 'memmove' and 'memcmp' shall be pointers to qualified or unqualified versions of compatible types" id="MISRAC2012-RULE_21_15-a" origId="CODSTA-183" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_16" desc="The pointer arguments to the Standard Library function 'memcmp' shall point to either a pointer type, an essentially signed type, an essentially unsigned type, an essentially Boolean type or an essentially enum type" id="MISRAC2012-RULE_21_16-a" origId="CODSTA-184" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_17" desc="Avoid overflow due to reading a not zero terminated string" id="MISRAC2012-RULE_21_17-a" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_17" desc="Avoid overflow when writing to a buffer" id="MISRAC2012-RULE_21_17-b" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_18" desc="The size_t argument passed to any function in string.h shall have an appropriate value" id="MISRAC2012-RULE_21_18-a" origId="BD-API-STRSIZE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_19" desc="The pointers returned by the Standard Library functions 'localeconv', 'getenv', 'setlocale' or, 'strerror' shall only be used as if they have pointer to const-qualified type" id="MISRAC2012-RULE_21_19-a" origId="CODSTA-185_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_19" desc="Strings pointed by members of the structure 'lconv' should not be modified" id="MISRAC2012-RULE_21_19-b" origId="CODSTA-185_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused" id="MISRAC2012-RULE_21_2-a" origId="MISRA2004-20_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused (C90)" id="MISRAC2012-RULE_21_2-b" origId="MISRA2004-20_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_2" desc="The names of standard library macros, objects and functions shall not be reused (C99)" id="MISRAC2012-RULE_21_2-c" origId="MISRA2004-20_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_20" desc="Pointers returned by certain Standard Library functions should not be used following a subsequent call to the same or related function" id="MISRAC2012-RULE_21_20-a" origId="BD-PB-INVRET" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_21" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_21-a" origId="SECURITY-48_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_3" desc="Dynamic heap memory allocation shall not be used" id="MISRAC2012-RULE_21_3-a" origId="MISRA2004-20_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_4" desc="The facilities provided by &lt;setjmp.h> should not be used" id="MISRAC2012-RULE_21_4-a" origId="MISRA2004-20_7" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_4" desc="The standard header files &lt;setjmp.h> or &lt;csetjmp> shall not be used" id="MISRAC2012-RULE_21_4-b" origId="MISRA2004-20_7_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_5" desc="The standard header files &lt;signal.h> or &lt;csignal> shall not be used" id="MISRAC2012-RULE_21_5-a" origId="MISRA2004-20_8" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_5" desc="The signal handling facilities of &lt;signal.h> shall not be used" id="MISRAC2012-RULE_21_5-b" origId="MISRA2004-20_8_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MISRAC2012-RULE_21_6" desc="The Standard Library input/output functions shall not be used" id="MISRAC2012-RULE_21_6-a" origId="CODSTA-110" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_21_7" desc="The library functions atof, atoi and atol from library stdlib.h shall not be used" id="MISRAC2012-RULE_21_7-a" origId="MISRA2004-20_10" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_8" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-a" origId="PB-75" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_8" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-b" origId="PB-75_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_8" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="MISRAC2012-RULE_21_8-c" origId="PB-75_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_21_9" desc="The library functions bsearch and qsort of &lt;stdlib.h> shall not be used" id="MISRAC2012-RULE_21_9-a" origId="CODSTA-107" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_1" desc="Ensure resources are freed" id="MISRAC2012-RULE_22_1-a" origId="BD-RES-LEAKS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_10" desc="Properly use errno value" id="MISRAC2012-RULE_22_10-a" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_2" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_22_2-a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_2" desc="Do not free resources using invalid pointers" id="MISRAC2012-RULE_22_2-b" origId="BD-RES-INVFREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_3" desc="The same file shall not be opened for read and write access at the same time on different streams" id="MISRAC2012-RULE_22_3-a" origId="BD-PB-WRRDSTR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_4" desc="Avoid writing to a stream which has been opened as read only" id="MISRAC2012-RULE_22_4-a" origId="BD-PB-WRROS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_5" desc="A pointer to a FILE object shall not be dereferenced" id="MISRAC2012-RULE_22_5-a" origId="CODSTA-166_a" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_5" desc="A pointer to a FILE object shall not be dereferenced by a library function" id="MISRAC2012-RULE_22_5-b" origId="CODSTA-166_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_6" desc="Do not use resources that have been freed" id="MISRAC2012-RULE_22_6-a" origId="BD-RES-FREE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_7" desc="The macro EOF should be compared with the unmodified return value from the Standard Library function" id="MISRAC2012-RULE_22_7-a" origId="BD-PB-EOFCOMP" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_8" desc="Properly use errno value" id="MISRAC2012-RULE_22_8-a" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_22_9" desc="Properly use errno value" id="MISRAC2012-RULE_22_9-a" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in &quot;else&quot; block" id="MISRAC2012-RULE_2_1-a" origId="MISRA2004-14_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after 'return', 'break', 'continue', 'goto', 'throw' statements, and after calls to functions with the 'noreturn' attribute" id="MISRAC2012-RULE_2_1-b" origId="MISRA2004-14_1_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in &quot;if/else/while/for&quot; block" id="MISRAC2012-RULE_2_1-c" origId="MISRA2004-14_1_c" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in switch statement" id="MISRAC2012-RULE_2_1-d" origId="MISRA2004-14_1_d" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code in 'for' loop" id="MISRAC2012-RULE_2_1-e" origId="MISRA2004-14_1_e" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after 'if' or 'switch' statement" id="MISRAC2012-RULE_2_1-f" origId="MISRA2004-14_1_f" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_1" desc="There shall be no unreachable code after &quot;if&quot; or &quot;switch&quot; statement inside while/for/do...while loop" id="MISRAC2012-RULE_2_1-g" origId="MISRA2004-14_1_g" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_2" desc="All non-null statements shall either have at least one side-effect however executed or cause control flow to change" id="MISRAC2012-RULE_2_2-a" origId="MISRA2004-14_2" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_2" desc="Avoid unused values" id="MISRAC2012-RULE_2_2-b" origId="BD-PB-VOVR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_3" desc="A function should not contain unused type declarations" id="MISRAC2012-RULE_2_3-a" origId="CODSTA-175_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_3" desc="A source file should not contain unused type declarations" id="MISRAC2012-RULE_2_3-b" origId="CODSTA-175_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_4" desc="A function should not contain unused local tag declarations" id="MISRAC2012-RULE_2_4-a" origId="CODSTA-176_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_4" desc="A source file should not contain unused tag declarations" id="MISRAC2012-RULE_2_4-b" origId="CODSTA-176_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_5" desc="A source file should not contain unused macro definitions" id="MISRAC2012-RULE_2_5-a" origId="CODSTA-177" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_6" desc="A function should not contain unused label declarations" id="MISRAC2012-RULE_2_6-a" origId="OPT-37" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_2_7" desc="There should be no unused parameters in functions" id="MISRAC2012-RULE_2_7-a" origId="OPT-38" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_1" desc="The character sequence /* shall not be used within a C-style comment" id="MISRAC2012-RULE_3_1-a" origId="MISRA2004-2_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_1" desc="The character sequence // shall not be used within a C-style comment" id="MISRAC2012-RULE_3_1-b" origId="COMMENT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_1" desc="The character sequence /* shall not be used within a C++-style comment" id="MISRAC2012-RULE_3_1-c" origId="COMMENT-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_3_2" desc="Line-splicing shall not be used in // comments" id="MISRAC2012-RULE_3_2-a" origId="COMMENT-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_4_1" desc="Octal and hexadecimal escape sequences shall be terminated" id="MISRAC2012-RULE_4_1-a" origId="CODSTA-117" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_4_2" desc="Trigraphs shall not be used" id="MISRAC2012-RULE_4_2-a" origId="MISRA2004-4_2" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_1" desc="External identifiers shall be distinct" id="MISRAC2012-RULE_5_1-a" origId="CODSTA-178" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c90)" id="MISRAC2012-RULE_5_2-a" origId="CODSTA-179_a_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the file scope and in the same name space shall be distinct (c99)" id="MISRAC2012-RULE_5_2-b" origId="CODSTA-179_a_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the same block scope and name space shall be distinct (c90)" id="MISRAC2012-RULE_5_2-c" origId="CODSTA-179_b_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_2" desc="Identifiers declared in the same block scope and name space shall be distinct (c99)" id="MISRAC2012-RULE_5_2-d" origId="CODSTA-179_b_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_3" desc="Identifier declared in a local or function prototype scope shall not hide an identifier declared in a global or namespace scope" id="MISRAC2012-RULE_5_3-a" origId="MISRA2004-5_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_3" desc="Identifiers declared in an inner local scope should not hide identifiers declared in an outer local scope" id="MISRAC2012-RULE_5_3-b" origId="MISRA2004-5_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of its parameters(c90)" id="MISRAC2012-RULE_5_4-a" origId="CODSTA-171_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of its parameters(c99)" id="MISRAC2012-RULE_5_4-b" origId="CODSTA-171_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c90)" id="MISRAC2012-RULE_5_4-c" origId="CODSTA-172_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_4" desc="The name of a macro should be distinct from the names of other macros that are currently defined(c99)" id="MISRAC2012-RULE_5_4-d" origId="CODSTA-172_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_5" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c90)" id="MISRAC2012-RULE_5_5-a" origId="CODSTA-170_c90" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_5" desc="The names of macros that exist prior to preprocessing should be distinct from the identifiers that exist after preprocessing (c99)" id="MISRAC2012-RULE_5_5-b" origId="CODSTA-170_c99" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_6" desc="A typedef name shall be a unique identifier" id="MISRAC2012-RULE_5_6-a" origId="GLOBAL-UNIQUETYPEDEFC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="10;" authUrg="0;" cat="MISRAC2012-RULE_5_7" desc="A tag name shall be a unique identifier" id="MISRAC2012-RULE_5_7-a" origId="GLOBAL-UNIQUETYPEC" sev="2" total="10"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_8" desc="Identifiers that define objects with external linkage shall be unique" id="MISRAC2012-RULE_5_8-a" origId="GLOBAL-REUSEDEXTVAR" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_9" desc="Identifiers that define objects with internal linkage shall be unique" id="MISRAC2012-RULE_5_9-a" origId="GLOBAL-REUSEDSTATVAR" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_5_9" desc="Identifiers that define functions with internal linkage shall be unique" id="MISRAC2012-RULE_5_9-b" origId="GLOBAL-REUSEDSTATFUN" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_6_1" desc="Bit fields shall only be defined to be of type unsigned int or signed int" id="MISRAC2012-RULE_6_1-a" origId="MISRA2004-6_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_6_2" desc="Named bit-fields with signed integer type shall have a length of more than one bit" id="MISRAC2012-RULE_6_2-a" origId="CODSTA-71" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_1" desc="Octal constants (other than zero) shall not be used" id="MISRAC2012-RULE_7_1-a" origId="MISRA2004-7_1_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_2" desc="A 'U' suffix shall be applied to all constants of unsigned type" id="MISRAC2012-RULE_7_2-a" origId="MISRA2004-10_6" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_3" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="MISRAC2012-RULE_7_3-a" origId="PORT-01" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_7_4" desc="A string literal shall not be modified" id="MISRAC2012-RULE_7_4-a" origId="PB-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_1" desc="Whenever a function is declared or defined, its type shall be explicitly stated" id="MISRAC2012-RULE_8_1-a" origId="MISRA2004-8_2_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_1" desc="Whenever an object is declared or defined, its type shall be explicitly stated" id="MISRAC2012-RULE_8_1-b" origId="MISRA2004-8_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_10" desc="An inline function shall be declared with the static storage class" id="MISRAC2012-RULE_8_10-a" origId="CODSTA-120" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_11" desc="When an array is declared with external linkage, its size shall be stated explicitly or defined implicitly by initialisation" id="MISRAC2012-RULE_8_11-a" origId="MISRA2004-8_12" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_12" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="MISRAC2012-RULE_8_12-a" origId="PB-58" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_13" desc="A pointer parameter in a function prototype should be declared as pointer to const if the pointer is not used to modify the addressed object" id="MISRAC2012-RULE_8_13-a" origId="MISRA2004-16_7" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_13" desc="Declare a type of parameter as typedef to pointer to const if the pointer is not used to modify the addressed object" id="MISRAC2012-RULE_8_13-b" origId="MISRA2004-16_7_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_14" desc="The restrict type qualifier shall not be used" id="MISRAC2012-RULE_8_14-a" origId="CODSTA-121" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_2" desc="Identifiers shall be given for all of the parameters in a function prototype declaration" id="MISRAC2012-RULE_8_2-a" origId="MISRA2004-16_3" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_2" desc="Function types shall have named parameters" id="MISRAC2012-RULE_8_2-b" origId="CODSTA-158" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_2" desc="Function types shall be in prototype form" id="MISRAC2012-RULE_8_2-c" origId="CODSTA-159" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_3" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRAC2012-RULE_8_3-a" origId="MISRA2004-8_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_3" desc="The identifiers used in the declaration and definition of a function shall be identical" id="MISRAC2012-RULE_8_3-b" origId="MISRA2004-16_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_3" desc="All declarations of an object or function shall have compatible types" id="MISRAC2012-RULE_8_3-c" origId="GLOBAL-COMPATDECLS" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_4" desc="A declaration shall be visible when an object or function with external linkage is defined" id="MISRAC2012-RULE_8_4-a" origId="CODSTA-118" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_4" desc="If objects or functions are declared more than once their types shall be compatible" id="MISRAC2012-RULE_8_4-b" origId="MISRA2004-8_4" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_5" desc="An external object or function shall not have more than one non-defining declaration in translation unit" id="MISRAC2012-RULE_8_5-a" origId="CODSTA-154" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="4;" authUrg="0;" cat="MISRAC2012-RULE_8_6" desc="An identifier with external linkage shall have no more then one external definition" id="MISRAC2012-RULE_8_6-a" origId="GLOBAL-ONEEXTERNDEF" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.global" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_7" desc="Functions and objects should not be defined with external linkage if they are referenced in only one translation unit" id="MISRAC2012-RULE_8_7-a" origId="GLOBAL-AVOIDEXTERN" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_8_8" desc="The static storage class specifier shall be used in definitions and declarations of objects and functions that have internal linkage" id="MISRAC2012-RULE_8_8-a" origId="MISRA2004-8_11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="MISRAC2012-RULE_8_9" desc="Objects shall be defined at block scope if they are only accessed from within a single function" id="MISRAC2012-RULE_8_9-a" origId="MISRA2004-8_7" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_1" desc="Avoid use before initialization" id="MISRAC2012-RULE_9_1-a" origId="BD-PB-NOTINIT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_2" desc="The initializer for an aggregate or union shall be enclosed in braces" id="MISRAC2012-RULE_9_2-a" origId="INIT-16" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_3" desc="Arrays shall not be partially initialized" id="MISRAC2012-RULE_9_3-a" origId="MISRA2004-9_2_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_4" desc="An element of an object shall not be initialized more than once" id="MISRAC2012-RULE_9_4-a" origId="PB-69" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MISRAC2012-RULE_9_5" desc="Where designated initializers are used to initialize an array object the size of the array shall be specified explicitly" id="MISRAC2012-RULE_9_5-a" origId="CODSTA-186" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not allocate resources in function argument list because the order of evaluation of a function's parameters is undefined" id="MRM-01" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Use the same form in corresponding calls to new/malloc and delete/free" id="MRM-06" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not invoke malloc/realloc for objects having constructors" id="MRM-08" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Avoid hiding the global new" id="MRM-32" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Declare a copy assignment operator for classes with dynamically allocated memory" id="MRM-37" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Declare a copy constructor for classes with dynamically allocated memory" id="MRM-38" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Never return a dereferenced local pointer initialized by new in this function scope" id="MRM-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Call delete on pointer members in destructors" id="MRM-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Provide error handling for file opening errors right next to the call to fopen" id="MRM-39" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="A copy constructor shall copy all data members and bases" id="MRM-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Call fclose() on pointer member in destructor if the pointer was used to open a file" id="MRM-42" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="An assignment operator shall assign all data bases" id="MRM-43" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not pass a pointer that has insufficient storage capacity or that is not suitably aligned for the object being constructed to placement 'new'" id="MRM-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not allocate more than one resource in a single statement" id="MRM-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MRM" desc="All classes should contain the assignment operator or appropriate comment" id="MRM-04" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MRM" desc="All classes should contain the copy constructor or appropriate comment" id="MRM-05" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Don't memcpy or memcmp non-PODs" id="MRM-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Always assign a new value to an expression that points to deallocated memory" id="MRM-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Always assign a new value to global or member variable that points to deallocated memory" id="MRM-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Always assign a new value to parameter or local variable that points to deallocated memory" id="MRM-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Adhere to convention when writing new and delete" id="MRM-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Adhere to convention when writing new" id="MRM-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="If a class defines any overload of operator new, it should provide overloads of all three of plain, in-place, and non-throwing operator new" id="MRM-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="If a class defines any overload of operator new[], it should provide overloads of all three of plain, in-place, and non-throwing operator new[]" id="MRM-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="If a class defines any overload of operator delete, it should provide overloads of all three of plain, in-place, and non-throwing operator delete" id="MRM-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="If a class defines any overload of operator delete[], it should provide overloads of all three of plain, in-place, and non-throwing operator delete[]" id="MRM-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not allocate memory and expect that someone else will deallocate it later" id="MRM-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not allocate memory and expect that someone else will deallocate it later" id="MRM-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not allocate memory and expect that someone else will deallocate it later" id="MRM-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Use objects to manage resources" id="MRM-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Use objects to manage resources" id="MRM-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Store newed objects in smart pointers in standalone statements" id="MRM-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Write operator delete if you write operator new" id="MRM-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Write operator delete[] if you write operator new[]" id="MRM-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Always provide new and delete together" id="MRM-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Always provide new[] and delete[] together" id="MRM-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Use allocation by declaration rather than by new or malloc" id="MRM-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Freed memory shouldn't be accessed under any circumstances" id="MRM-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Destructor should not be called manually" id="MRM-31_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Check the return value of new" id="MRM-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Never provide brackets ([]) for delete when deallocating non-arrays" id="MRM-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Always provide empty brackets ([]) for delete when deallocating arrays" id="MRM-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Copy and destroy consistently" id="MRM-40" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="A copy assignment operator should be declared when a copy constructor is declared (and vice versa)" id="MRM-40_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Both the copy constructor and copy assignment operator should have the same public/protected/private permission" id="MRM-40_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="If you have a non-trivial copy constructor or copy assignment operator, you should also declare a destructor" id="MRM-40_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Both copy constructor and copy assignment operator should be declared for classes with a nontrivial destructor" id="MRM-40_d" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not use sizeof operator on pointer type to specify the size of the memory to be allocated via 'malloc', 'calloc' or 'realloc' function" id="MRM-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not use calloc, malloc, realloc and free functions" id="MRM-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MRM" desc="Classes containing at least one non-static member variable should declare the assignment operator or contain appropriate comment" id="MRM-47" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="MRM" desc="Classes containing at least one non-static member variable should declare the copy constructor or contain appropriate comment" id="MRM-48" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="A copy constructor and a copy assignment operator shall be declared for classes that contain pointers to data items or nontrivial destructors" id="MRM-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Do not use 'delete' on pointers to a void type" id="MRM-51" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="The user defined 'new' operator should throw the 'std::bad_alloc' exception when the allocation fails" id="MRM-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Avoid using the default operator 'new' for over-aligned types" id="MRM-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="An overhead should be used when an array of objects is passed to the placement 'new' allocation function" id="MRM-55_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Copy assignment operators should not have side effects that could affect copying the object" id="MRM-56" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Move assignment operators should not have side effects that could affect moving the object" id="MRM-57" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Declare both private copy constructor and copy assignment operator at the same time" id="MRM-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="MRM" desc="Use RAII to prevent resource leaks" id="MRM-52" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Identifiers for constant and enumerator values shall be lowercase" id="NAMING-42" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="All &quot;#define&quot; constants shall be in uppercase" id="NAMING-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="In an enumerated list, list members (elements) shall be in uppercase and names or tags for the list shall be in lowercase" id="NAMING-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Use lowercase for file names" id="NAMING-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Global prefixes should only be used for global variables" id="NAMING-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin local variable names with a lowercase letters" id="NAMING-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Begin global variable names with a lowercase letters" id="NAMING-06" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin member variable names with a lowercase letters" id="NAMING-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all boolean type variables with 'b'" id="NAMING-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin class, struct, union, enum, and typedef names with an uppercase letter" id="NAMING-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="The names of abstract data types, structures, typedefs, and enumerated types are to begin with an uppercase letter" id="NAMING-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="The name of enumeration type shall begin with an uppercase letter and contain a suffix '_t' at the end" id="NAMING-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="The names of structures shall begin with an uppercase letter and contain a suffix '_t' at the end" id="NAMING-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Begin constant variables with 'c'" id="NAMING-13" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="NAMING" desc="Begin class data member names with 'its'" id="NAMING-14" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all double type variable with 'd'" id="NAMING-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all float type variables with 'f'" id="NAMING-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="1;" cat="NAMING" desc="Begin all function names with uppercase letter" id="NAMING-17" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Begin global variable names with 'the'" id="NAMING-18" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all integer type variable with 'i'" id="NAMING-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Functions that begin with 'is' should return boolean values" id="NAMING-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all long integer variables with 'li'" id="NAMING-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Prefix a variable type 'pointer' with a 'p' character" id="NAMING-22" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all short integer variables with 'si'" id="NAMING-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all signed character variables with 'c'" id="NAMING-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Begin all terminated characters string variables with 'sz'" id="NAMING-25" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all unsigned character type variables with 'uc'" id="NAMING-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Begin all unsigned integer type variables with 'ui'" id="NAMING-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Use lowercase letters for structure and union member names" id="NAMING-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Append names of non-scalar typedefs with &quot;_t&quot;" id="NAMING-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Implementation files in C always have the file name extension &quot;.c&quot;" id="NAMING-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Do not use typenames that differ only by the use of uppercase and lowercase letters" id="NAMING-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="An include file for a class should have a file name of the form &lt;class name> + extension" id="NAMING-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Do not use identifiers which begin with one or two underscores (`_' or `__')" id="NAMING-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Global function names should start with lowercase" id="NAMING-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="Member function names should start with lowercase" id="NAMING-35" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Names of parameters in declaration and definition should be identical" id="NAMING-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Include files in C++ always have the file name extension '.hh'" id="NAMING-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="1;" cat="NAMING" desc="Implementation files in C++ always have the file name extension &quot;.cc&quot;" id="NAMING-38" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="NAMING" desc="Inline definition files always have the file name extension &quot;.icc&quot;" id="NAMING-39" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="NAMING" desc="Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter" id="NAMING-40" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Header files will always have a file name extension of '.h'" id="NAMING-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="NAMING" desc="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" id="NAMING-43" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING" desc="All letters contained in function and variable names will be composed entirely of lowercase letters" id="NAMING-44" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="NAMING" desc="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" id="NAMING-45" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="The ', &quot;, /* or // characters shall not occur in a header file name" id="NAMING-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="NAMING" desc="Different identifiers shall be typographically unambiguous" id="NAMING-47" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="The \ character should not occur in a header file name" id="NAMING-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="User defined suffixes of the user defined literal operators shall start with underscore followed by one or more letters" id="NAMING-51" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Universal character names shall be used only inside character or string literals" id="NAMING-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="0;" cat="NAMING" desc="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" id="NAMING-53" sev="3" total="12"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Use visually distinct identifiers" id="NAMING-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="NAMING" desc="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" id="NAMING-49" sev="4" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING" desc="Identifiers in the same name space with overlapping visibility should be typographically unambiguous" id="NAMING-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for array variables and parameters" id="NAMING-HN-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for bool types" id="NAMING-HN-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for bool pointer, array, or reference types" id="NAMING-HN-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for byte types" id="NAMING-HN-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for byte pointer, array, or reference types" id="NAMING-HN-05" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for char types" id="NAMING-HN-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for array of char types" id="NAMING-HN-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for pointer, array, or reference to array of char types" id="NAMING-HN-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for char pointer, array, or reference types" id="NAMING-HN-09" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for char pointer or reference types" id="NAMING-HN-10" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for constant parameters" id="NAMING-HN-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for double-precision floating point types" id="NAMING-HN-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for double-precision floating point pointer, array, or reference types" id="NAMING-HN-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for dword types" id="NAMING-HN-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for dword pointer, array, or reference types" id="NAMING-HN-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for dynamically allocated array" id="NAMING-HN-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for floating point types" id="NAMING-HN-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for floating point pointer, array, or reference types" id="NAMING-HN-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for class declaration" id="NAMING-HN-19" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for structs declaration" id="NAMING-HN-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for ifstream type variables and parameters" id="NAMING-HN-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="5;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for int types" id="NAMING-HN-22" sev="3" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for int pointer, array, or reference types" id="NAMING-HN-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for istream type parameters and variables" id="NAMING-HN-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for long int types" id="NAMING-HN-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for long double-precision floating point types" id="NAMING-HN-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for long double-precision floating point pointer, array, or reference types" id="NAMING-HN-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for long int pointer, array, or reference types" id="NAMING-HN-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for member variables" id="NAMING-HN-29" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="5;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for int types" id="NAMING-HN-30" sev="3" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for int pointer, array, or reference types" id="NAMING-HN-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for ofstream type parameters and variables" id="NAMING-HN-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for ostream type parameters and variables" id="NAMING-HN-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for pointer" id="NAMING-HN-34" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for reference parameters" id="NAMING-HN-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for short int types" id="NAMING-HN-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for short int pointer, array, or reference types" id="NAMING-HN-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for static variables" id="NAMING-HN-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for string types" id="NAMING-HN-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for string pointer, array, or reference types" id="NAMING-HN-40" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for unsigned types" id="NAMING-HN-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for void pointer types" id="NAMING-HN-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="5;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for word types" id="NAMING-HN-43" sev="3" total="5"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="NAMING-HN" desc="Hungarian notation for word pointer, array, or reference types" id="NAMING-HN-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Class cannot inherit other class more than once unless it is virtual inheritance" id="OOP-03" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Be wary about using multiple inheritance of classes that are not abstract interfaces" id="OOP-07" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Do not directly access global data from a constructor" id="OOP-08" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid calling virtual functions from constructors" id="OOP-16" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid calling virtual functions from destructors" id="OOP-16_b" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Define a virtual destructor in classes used as base classes which have virtual functions" id="OOP-22" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Make destructors virtual in base classes" id="OOP-24" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A pointer to an abstract class shall not be converted to a pointer of a class that inherits from that abstract class" id="OOP-29" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Make base class destructors public and virtual, or protected and nonvirtual" id="OOP-31" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="If a class destructor is called and the class has virtual functions it shall have a virtual destructor" id="OOP-38" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Casts from a base class to a derived class should not be performed on polymorphic types" id="OOP-49" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Do not use multiple inheritance" id="OOP-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Multiple inheritance shall be limited to at most 1 protected implementation" id="OOP-07_a" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Multiple inheritance shall not use any public implementations" id="OOP-07_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid using global data in member functions" id="OOP-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid &quot;public&quot; data members" id="OOP-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="OOP" desc="Avoid 'protected' data members" id="OOP-19" sev="2" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="If a class has virtual functions it shall have a virtual destructor" id="OOP-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid casts down the inheritance hierarchy" id="OOP-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Down casting (casting from base to derived class) shall not be allowed" id="OOP-35" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A stateful virtual base shall be explicitly declared in each derived class that accesses it" id="OOP-39_b" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A base class shall not be both virtual and non-virtual in the same hierarchy" id="OOP-41" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid public copy constructors and assignment operators in base classes" id="OOP-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid slicing. Consider Clone instead of copying in base classes" id="OOP-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Do not derive functions with the same name from more than one base class" id="OOP-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="For multiple inheritance use virtual common base class" id="OOP-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid the use of global objects in destructors" id="OOP-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid using the friend mechanism" id="OOP-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Friend declarations shall not be used except declarations of comparison operators" id="OOP-11_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Protected member function shall not return non-const handles to private class-data" id="OOP-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Do not redefine an inherited virtual function with a different default parameter value" id="OOP-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Avoid explicit cast from derived to a base class" id="OOP-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Use the virtual keyword if a subclass implements a virtual function" id="OOP-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="OOP" desc="Avoid declaring virtual functions inline" id="OOP-25" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Never convert pointers to objects of a derived class to pointers to objects of a virtual base class" id="OOP-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Declare copy assignment operator for class with reference or const members" id="OOP-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Declare the copy constructor and copy assignment operator private not in class itself, but in a specifically designed base class" id="OOP-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Never redefine an inherited nonvirtual function" id="OOP-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Do not redefine an inherited nonvirtual function with template parameter" id="OOP-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Public member functions shall not return non-const handles to private/protected class-data" id="OOP-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="The copy assignment operator shall be declared protected or private in an abstract class" id="OOP-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="There shall be no more than one definition of each virtual function on each path through the inheritance hierarchy" id="OOP-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="All constructors that are callable with a single argument of fundamental type shall be declared explicit" id="OOP-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A copy constructor shall only initialize its base classes and the non-static members of the class of which it is a member" id="OOP-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Classes should not be derived from virtual bases" id="OOP-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="OOP" desc="Member data in non-POD types shall be private" id="OOP-48" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A pointer to a virtual base class shall only be cast to a pointer to a derived class by means of dynamic_cast" id="OOP-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Member functions declared in derived class should not hide functions declared in base classes" id="OOP-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Do not increase the accessibility of overridden or hidden methods" id="OOP-54" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A user-defined assignment operator shall not be virtual" id="OOP-56" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Structs should only contain public data members and should not be a base or inherit" id="OOP-57" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Write a using declaration to redeclare overloaded functions" id="OOP-17" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Check for assignment to self in operator=" id="OOP-34" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A virtual base shall be explicitly declared in each derived class" id="OOP-39" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Hierarchies should be based on abstract classes" id="OOP-40" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A virtual function shall only be overridden by a pure virtual function if it is itself declared as pure virtual" id="OOP-43" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A pointer to a class may not be converted to a pointer of a second class unless the one inherits from the other" id="OOP-52" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="A non-POD type should be defined as class" id="OOP-55" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Consider use composition instead of private inheritance" id="OOP-14" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Prefer composition when don't need inheritance" id="OOP-37" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OOP" desc="Use namespace instead of class or structure containing only static functions" id="OOP-51" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Eliminate unused parameters" id="OPT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Variables will not be introduced until they can be initialized with meaningful values" id="OPT-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="OPT" desc="Declare variables as locally as possible" id="OPT-01" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Prefer canonical form of ++ and --. Prefer calling the prefix forms" id="OPT-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Avoid unused private member variables" id="OPT-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Prefer &quot;a @= b&quot; than &quot;a = a @ b&quot;, where &quot;@&quot; is +, -, *, /, %" id="OPT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Prefer &quot;a @= b&quot; than &quot;a = a @ b&quot;, where &quot;@&quot; is &amp;, |, ^, &lt;&lt;, >>" id="OPT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Do not declare variables in &quot;if&quot;, &quot;for&quot;, &quot;while&quot;, and &quot;do while&quot; statement" id="OPT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="OPT" desc="If a file-level static variable is used/referenced in one function only then include that variable in the function itself" id="OPT-11" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="If a file-level static variable is used/referenced in one class only then include that variable in the class itself" id="OPT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Declare member variables in the descending size order" id="OPT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Pass objects by reference instead of by value" id="OPT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Consider overloading to avoid implicit type conversions" id="OPT-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Global function containing recursion, loops or virtual function call should not be inlined" id="OPT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Avoid inline constructors and destructors" id="OPT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Member function containing recursion or loops should not be inlined" id="OPT-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Consider using op= instead of stand-alone op" id="OPT-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="OPT" desc="Postpone variable definitions as long as possible" id="OPT-20" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Every switch statement shall have at least one non-empty case clause" id="OPT-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Useless case statement shall not be permitted" id="OPT-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="'strlen' function should not be used to check string against NULL/non-NULL" id="OPT-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Every defined function with internal linkage shall be used at least once" id="OPT-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="There shall be no unused parameters (named or unnamed) in non-virtual functions" id="OPT-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="All non-empty functions with void return type shall have external side effect(s)" id="OPT-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Do not assign a variable to itself" id="OPT-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Do not use a variable inside its own initializer" id="OPT-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Every switch statement shall have at least two switch-clauses" id="OPT-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="There shall be no unused named parameters in virtual functions" id="OPT-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Avoid unused local variables" id="OPT-02" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Avoid unnecessary local variables" id="OPT-06" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Trivial accessor and mutator functions should be inlined" id="OPT-23" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Trivial forwarding functions should be inlined" id="OPT-24" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Only functions with 1 or 2 statements should be considered candidates for inline functions" id="OPT-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="The number of accessor and mutator functions should be minimized" id="OPT-27" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Redundant explicit cast to the same type is not allowed" id="OPT-29" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="OPT" desc="Functions with void return type shall not be empty" id="OPT-32_b" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="A function should not contain unused label declarations" id="OPT-37" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="There should be no unused parameters in functions" id="OPT-38" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="The same code (after preprocessing) in two branches of if-else-if chain" id="OPT-40_a" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="The same code (after preprocessing) in different clauses of switch statement" id="OPT-40_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="A file should directly include only the headers that contain declarations and definitions required to compile that file" id="OPT-41" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OPT" desc="Remove unnecessary '== true'" id="OPT-09" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="1;" cat="OPT" desc="Consider returning object by reference instead of by value" id="OPT-33" sev="5" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A1" desc="Protect against command injection" id="OWASP2017-A1-b" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A1" desc="Avoid printing tainted data on the output console" id="OWASP2017-A1-c" origId="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A1" desc="Protect against environment injection" id="OWASP2017-A1-d" origId="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A1" desc="Exclude unsanitized user input from format strings" id="OWASP2017-A1-e" origId="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A1" desc="Protect against SQL injection" id="OWASP2017-A1-f" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A1" desc="Avoid passing unvalidated binary data to log methods" id="OWASP2017-A1-a" origId="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="OWASP2017-A10" desc="All exceptions should be rethrown or logged with standard logger" id="OWASP2017-A10-a" origId="EXCEPT-04" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2017-A2" desc="Do not use weak encryption functions" id="OWASP2017-A2-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A3" desc="Properly seed pseudorandom number generators" id="OWASP2017-A3-a" origId="BD-SECURITY-RAND" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A4" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="OWASP2017-A4-a" origId="BD-SECURITY-XXEXRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A5" desc="Protect against file name injection" id="OWASP2017-A5-a" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2017-A5" desc="Observe correct revocation order while relinquishing privileges" id="OWASP2017-A5-b" origId="SECURITY-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2017-A5" desc="Ensure that privilege relinquishment is successful" id="OWASP2017-A5-c" origId="SECURITY-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2017-A6" desc="Properly use errno value" id="OWASP2017-A6-c" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2017-A6" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="OWASP2017-A6-a" origId="EXCEPT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2017-A6" desc="Do not leave 'catch' blocks empty" id="OWASP2017-A6-b" origId="EXCEPT-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="OWASP2019-API10" desc="All exceptions should be rethrown or logged with standard logger" id="OWASP2019-API10-a" origId="EXCEPT-04" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API10" desc="Do not use 'syslog' function for logging purposes" id="OWASP2019-API10-b" origId="SECURITY-21" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API2" desc="Do not use weak encryption functions" id="OWASP2019-API2-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid buffer overflow due to defining incorrect format limits" id="OWASP2019-API3-d" origId="BD-PB-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid overflow due to reading a not zero terminated string" id="OWASP2019-API3-e" origId="BD-PB-OVERFNZT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid overflow when reading from a buffer" id="OWASP2019-API3-f" origId="BD-PB-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid overflow when writing to a buffer" id="OWASP2019-API3-g" origId="BD-PB-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid buffer overflow from tainted data due to defining incorrect format limits" id="OWASP2019-API3-h" origId="BD-SECURITY-OVERFFMT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid buffer read overflow from tainted data" id="OWASP2019-API3-i" origId="BD-SECURITY-OVERFRD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid buffer write overflow from tainted data" id="OWASP2019-API3-j" origId="BD-SECURITY-OVERFWR" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid race conditions while checking for the existence of a symbolic link" id="OWASP2019-API3-m" origId="BD-TRS-SYMLINK" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Do not pass empty container iterators to std algorithms as destinations" id="OWASP2019-API3-a" origId="BD-CO-EMPCON" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid accessing arrays out of bounds" id="OWASP2019-API3-b" origId="BD-PB-ARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid accessing arrays and pointers out of bounds" id="OWASP2019-API3-c" origId="BD-PB-OVERFARRAY" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Properly seed pseudorandom number generators" id="OWASP2019-API3-k" origId="BD-SECURITY-RAND" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid passing sensitive data to functions that write to log files" id="OWASP2019-API3-l" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="OWASP2019-API3" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="OWASP2019-API3-p" origId="SECURITY-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Avoid functions which use time from MFC library" id="OWASP2019-API3-o" origId="SECURITY-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="OWASP2019-API3-q" origId="SECURITY-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API3" desc="Usage of system properties (environment variables) should be restricted" id="OWASP2019-API3-n" origId="SECURITY-03" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API4" desc="Ensure resources are freed" id="OWASP2019-API4-b" origId="BD-RES-LEAKS" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API4" desc="Validate potentially tainted data before it is used to determine the size of memory allocation" id="OWASP2019-API4-a" origId="BD-SECURITY-TDALLOC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API7" desc="Properly use errno value" id="OWASP2019-API7-a" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API7" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="OWASP2019-API7-b" origId="EXCEPT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API7" desc="Do not leave 'catch' blocks empty" id="OWASP2019-API7-c" origId="EXCEPT-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Protect against command injection" id="OWASP2019-API8-a" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Avoid printing tainted data on the output console" id="OWASP2019-API8-b" origId="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Protect against environment injection" id="OWASP2019-API8-c" origId="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Protect against file name injection" id="OWASP2019-API8-d" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Exclude unsanitized user input from format strings" id="OWASP2019-API8-e" origId="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Protect against SQL injection" id="OWASP2019-API8-f" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="OWASP2019-API8-g" origId="BD-SECURITY-XXEXRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Use care to ensure that LoadLibrary() will load the correct library" id="OWASP2019-API8-h" origId="SECURITY-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Avoid passing dynamically created strings into exec" id="OWASP2019-API8-i" origId="SECURITY-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API8" desc="Avoid passing user input into methods as parameters" id="OWASP2019-API8-j" origId="SECURITY-20" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="All usage of assembler shall be documented" id="OWASP2019-API9-c" origId="COMMENT-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="Use of floating-point arithmetic shall be documented" id="OWASP2019-API9-d" origId="COMMENT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="All uses of the #pragma directive shall be documented and explained" id="OWASP2019-API9-g" origId="MISRA2004-3_4" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="Objects or functions with external linkage shall be declared in a header file" id="OWASP2019-API9-e" origId="MISRA-023" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="Assert liberally to document internal assumptions and invariants" id="OWASP2019-API9-a" origId="CODSTA-11" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="When using enum, the values of each member should be explicitly declared" id="OWASP2019-API9-b" origId="CODSTA-21" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2019-API9" desc="Document integer division" id="OWASP2019-API9-f" origId="MISRA-041" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A1" desc="Protect against file name injection" id="OWASP2021-A1-a" origId="BD-SECURITY-TDFNAMES" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2021-A1" desc="Observe correct revocation order while relinquishing privileges" id="OWASP2021-A1-b" origId="SECURITY-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2021-A1" desc="Ensure that privilege relinquishment is successful" id="OWASP2021-A1-c" origId="SECURITY-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A2" desc="Properly seed pseudorandom number generators" id="OWASP2021-A2-a" origId="BD-SECURITY-RAND" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A3" desc="Protect against command injection" id="OWASP2021-A3-b" origId="BD-SECURITY-TDCMD" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A3" desc="Avoid printing tainted data on the output console" id="OWASP2021-A3-c" origId="BD-SECURITY-TDCONSOLE" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A3" desc="Protect against environment injection" id="OWASP2021-A3-d" origId="BD-SECURITY-TDENV" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A3" desc="Exclude unsanitized user input from format strings" id="OWASP2021-A3-e" origId="BD-SECURITY-TDINPUT" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A3" desc="Protect against SQL injection" id="OWASP2021-A3-f" origId="BD-SECURITY-TDSQL" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A3" desc="Avoid passing unvalidated binary data to log methods" id="OWASP2021-A3-a" origId="BD-SECURITY-LOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A4" desc="Avoid passing sensitive data to functions that write to log files" id="OWASP2021-A4-a" origId="BD-SECURITY-SENSLOG" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A5" desc="Properly use errno value" id="OWASP2021-A5-c" origId="BD-PB-ERRNO" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" authTot="0;" authUrg="0;" cat="OWASP2021-A5" desc="Disable resolving XML external entities (XXE) in libxerces-c" id="OWASP2021-A5-d" origId="BD-SECURITY-XXEXRC" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2021-A5" desc="Where multiple handlers are provided in a single try-catch statement or function-try-block for a derived class and some or all of its bases, the handlers shall be ordered most-derived to base class" id="OWASP2021-A5-a" origId="EXCEPT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2021-A5" desc="Do not leave 'catch' blocks empty" id="OWASP2021-A5-b" origId="EXCEPT-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2021-A7" desc="Do not use weak encryption functions" id="OWASP2021-A7-a" origId="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="OWASP2021-A8" desc="Use care to ensure that LoadLibrary() will load the correct library" id="OWASP2021-A8-a" origId="SECURITY-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="OWASP2021-A9" desc="All exceptions should be rethrown or logged with standard logger" id="OWASP2021-A9-a" origId="EXCEPT-04" sev="2" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PARSER" desc="Parser warning" id="PARSER-WARNING" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="10;" authUrg="1;" cat="PARSER" desc="Parser remark" id="PARSER-REMARK" sev="5" total="10"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not call delete on non-pointers" id="PB-13" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Properly terminate character strings" id="PB-21" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The class object should be passed by reference if the class has non-static pointers and has no declared copy constructor" id="PB-23" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Operators should not return value by reference" id="PB-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The definition of a constructor shall not contain default arguments that produce a signature identical to that of the implicitly-declared copy constructor" id="PB-24" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Unsigned arithmetic shall not be used" id="PB-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Public and protected methods should not be invoked by class constructor" id="PB-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="A string literal shall not be modified" id="PB-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The following character sequences shall not appear in header file names: ', \, /*, //, or &quot;" id="PB-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The left-hand operand of a right-shift operator shall not have a negative value" id="PB-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not cast from or to incomplete class at the point of casting" id="PB-54" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not delete objects with incomplete class at the point of deletion" id="PB-55" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Boolean condition always evaluates to the same value due to enumeration with only zero or only non-zero constants" id="PB-68" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not dereference pointer type expressions" id="PB-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not use assignments inside a(b), a[b], and cast" id="PB-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Using mixed types in ternary operator is not allowed" id="PB-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Return value of a function must match declared return type" id="PB-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Assignment operator should have operands of compatible types" id="PB-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not assign function return value to a variable of incompatible type" id="PB-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not assign signed constants to unsigned integer variables" id="PB-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Don't treat arrays polymorphically" id="PB-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="PB" desc="Declared types of formal and actual parameters to functions must match" id="PB-11" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not cast a signed char to an unsigned int" id="PB-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Incorrect End-Of-String (EOS) definition" id="PB-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Don't assign the dividend of two integers to a floating-point type" id="PB-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid unintentionally discarding the remainder of integer division" id="PB-15_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid assigning out-of-range value to char type" id="PB-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid assigning out-of-range value to unsigned char type" id="PB-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid overloading class methods on a pointer and a numerical type" id="PB-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not create inline non-member functions that contain local static data" id="PB-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not slice derived objects" id="PB-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not use increment and decrement expressions inside a(b), a[b], and cast" id="PB-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="More than one 'enum' type shall not be used as a switch condition or a label in a case statement" id="PB-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not call 'sizeof' on constants" id="PB-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not call 'sizeof' on a pointer type" id="PB-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid implicit type conversions in assignments involving enum types" id="PB-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid implicit type conversions in comparisons involving enum types" id="PB-33_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Third parameter to 'memcpy'/'strncpy'/'memmove' should not depend on second" id="PB-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Assignment operators shall not be used in conditions without brackets" id="PB-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The unbounded functions of library &lt;cstring> shall not be used" id="PB-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Narrow and wide string literals shall not be concatenated" id="PB-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="String literals with different encoding prefixes shall not be concatenated" id="PB-38_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="A function shall not return a reference or a pointer to a parameter that is passed by reference or const reference" id="PB-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="A function shall not return a pointer or a reference to a parameter that is passed by const reference" id="PB-39_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="An identifier with array type passed as a function argument shall not decay to a pointer" id="PB-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PB" desc="Do not pass an expression with array type to a function with a pointer or array type parameter" id="PB-41_b" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="An object shall not be assigned to an overlapping object" id="PB-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="All constructors of a class should explicitly call a constructor for all of its immediate base classes and all virtual base classes" id="PB-43" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The execution of a function registered with 'std::atexit()' or 'std::at_quick_exit()' should not exit via an exception" id="PB-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="There should be no mismatch between the '%s' and '%c' format specifiers in the format string and their corresponding arguments in the invocation of a string formatting function" id="PB-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="There should be no mismatch between the '%f' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="PB-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="There should be no mismatch between the '%i' and '%d' format specifiers in the string and their corresponding arguments in the invocation of a string formatting function" id="PB-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="There should be no mismatch between the '%u' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="PB-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="There should be no mismatch between the '%p' format specifier in the format string and its corresponding argument in the invocation of a string formatting function" id="PB-49" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The number of format specifiers in the format string and the number of corresponding arguments in the invocation of a string formatting function should be equal" id="PB-50" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Pointer arithmetic shall not be applied to pointers that address variables of non-array type" id="PB-51" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid overloading global functions on a pointer and a numerical type" id="PB-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid overloading namespace functions on a pointer and a numerical type" id="PB-53" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="PB" desc="Avoid implicit conversions from signed to unsigned type" id="PB-56" sev="3" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="A pointer to an array of derived class objects should not be converted to a base class pointer" id="PB-57" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Within an enumerator list, the value of an implicitly-specified enumeration constant shall be unique" id="PB-58" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Missing comma in a string array initialization" id="PB-59" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Suspicious argument to malloc" id="PB-60" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Pointer arithmetic performed on freshly allocated memory" id="PB-61" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid function calls with incorrect argument order" id="PB-62" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Function address should not be compared to zero" id="PB-63" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The values returned by string comparison functions should be compared only to zero" id="PB-64" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid possible integer overflow in expressions in which the result is assigned to a variable of a wider integer type" id="PB-65" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid possible integer overflow in expressions in which the result is compared to an expression of a wider integer type" id="PB-65_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Integer overflow or underflow in constant expression in '+', '-', '*' operator" id="PB-66_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The same code (after preprocessing) in both branches of if-else statement" id="PB-67" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="An element of an object shall not be initialized more than once" id="PB-69" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="An expression with enum underlying type shall only have values corresponding to the enumerators of the enumeration" id="PB-70" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not copy instances of structures containing a flexible array member" id="PB-71" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not call va_arg with an argument of the incorrect type" id="PB-72" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The 'abort()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="PB-75" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The 'exit()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="PB-75_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="The 'quick_exit()' and '_Exit()' functions from the 'stdlib.h' or 'cstdlib' library shall not be used" id="PB-75_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="PB" desc="C-style strings shall not be used" id="PB-76" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Expression statements shall not be explicit calls to constructors of temporary objects only" id="PB-77" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Use intmax_t or uintmax_t for formatted IO on programmer-defined integer types" id="PB-78" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Avoid function declarations that are syntactically ambiguous" id="PB-79" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Integer overflow or underflow in constant expression in '&lt;&lt;' operator" id="PB-66_b" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Do not add or subtract a constant with a value greater than one from an iterator" id="PB-74" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PB" desc="Evaluation of constant unsigned integer expressions should not lead to wrap-around" id="PB-73" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="Don't define entities with linkage in a header file" id="PFO-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="Use multiple include guards" id="PFO-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="An include file should not contain more than one class definition" id="PFO-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="File with extension '.c' may not include other files with extension '.c'" id="PFO-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="Never include other files in a file with extension '.icc'" id="PFO-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="Use multiple include guards with pattern based on the header file name" id="PFO-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="Use mechanism that prevents multiple inclusion of the file i.e. include guards or &quot;#pragma once&quot; preprocessor directive" id="PFO-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="&quot;#pragma once&quot; preprocessor directive should not be used in source files" id="PFO-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PFO" desc="Do not define more than on class in a header file" id="PFO-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="8;" authUrg="1;" cat="PFO" desc="Every implementation file should declare a local constant string that describes the file" id="PFO-04" sev="5" total="8"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Don't use hard coded value of offset in structures" id="PORT-03" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Don't use hex constant '0xffffffff' as an error marker" id="PORT-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="A pointer to a long should not be casted to an int pointer" id="PORT-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not cast an int pointer to a long pointer" id="PORT-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Algorithms shall not make assumptions concerning the order of allocation of nonstatic data members separated by an access specifier" id="PORT-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Assigning result of ints operation to long without casting at least one of the ints is not allowed" id="PORT-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not assign a long int to an int" id="PORT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not pass long casted to an int in function call" id="PORT-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Constant assignment to long should not involve int literals" id="PORT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not initialize a long int with int literals" id="PORT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not assign the value from 32 bit multiplication to long type" id="PORT-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="9;" authUrg="0;" cat="PORT" desc="The type int shall always be declared as unsigned int or signed int" id="PORT-13" sev="3" total="9"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Avoid conversions from &quot;shorter&quot; type to &quot;longer&quot; type in assignment" id="PORT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not cast from &quot;shorter&quot; type to &quot;longer&quot; type" id="PORT-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Avoid conversions from a &quot;shorter&quot; type to a &quot;longer&quot; type in function calls" id="PORT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="3;" authUrg="0;" cat="PORT" desc="Don't use 'i64' or 'L' suffixes directly" id="PORT-17" sev="3" total="3"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Instead of casting a long type operand of an expression to int cast the result of the expression" id="PORT-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not declare variables of long type directly" id="PORT-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not assign a long value to a double" id="PORT-21" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="The names of identifiers should not be longer than 64 characters" id="PORT-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Avoid implicit conversions to a type of narrower size" id="PORT-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Avoid conversions of constant values to a narrower type" id="PORT-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="A pointer to a structure should not be passed to a function that writes data to a file" id="PORT-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Type long double shall not be used" id="PORT-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Type wchar_t shall not be used" id="PORT-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="User-specified C++ external identifiers should differ in the first 64 characters" id="PORT-34_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="User-specified C++ internal identifiers should differ from external identifiers in the first 64 characters" id="PORT-34_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="User-specified C++ internal identifiers declared in the same scope should differ in the first 64 characters" id="PORT-34_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="User-specified C external identifiers should differ in the first 31 characters" id="PORT-35_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="User-specified C internal identifiers should differ from external identifiers in the first 31 characters" id="PORT-35_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="User-specified C internal identifiers declared in the same scope should differ in the first 31 characters" id="PORT-35_c" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="The names of identifiers should not be longer than 31 characters" id="PORT-36_a" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="The names of macro identifiers should not be longer than 31 characters" id="PORT-36_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="PORT" desc="Do not throw an exception across execution boundaries" id="PORT-30" sev="4" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Do not pass a nonstandard-layout type object across execution boundaries" id="PORT-31" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Use capital 'L' instead of lowercase 'l' to indicate long" id="PORT-01" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Use arrays of int types instead of large arrays of longs" id="PORT-22" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Use arrays of int types instead of dynamic allocated large arrays of longs" id="PORT-23" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PORT" desc="Don't use large arrays of pointers to bool, char, short, int and float types" id="PORT-24" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Don't use macros in include statement" id="PREPROC-02" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="In a macro function, use parentheses before and after multiplication or division" id="PREPROC-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Do not allow absolute or relative path names in #include statements" id="PREPROC-06" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="20;" authUrg="0;" cat="PREPROC" desc="The #include directive shall use the &lt;filename.h> notation to include header files" id="PREPROC-09" sev="2" total="20"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="Avoid using macro definitions" id="PREPROC-01" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="12;" authUrg="0;" cat="PREPROC" desc="The #include pre-processor directive will only be used to include header (*.h) files" id="PREPROC-08" sev="3" total="12"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="The #ifndef pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="PREPROC-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" id="PREPROC-10_b" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" id="PREPROC-10_c" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="The #ifdef, #else, #elif preprocessor directives should not be used" id="PREPROC-11" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="The #if preprocessor directive should not be used" id="PREPROC-11_b" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers" id="PREPROC-12" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Macro should not contain token pasting, variable argument list nor recursive macro calls" id="PREPROC-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="All macros must expand into complete syntactic units" id="PREPROC-14" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Pointer dereference operations may not be hidden in macro definitions" id="PREPROC-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="A macro parameter immediately following a # operator shall not immediately be followed by a ## operator" id="PREPROC-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="The input/output library stdio.h shall not be included" id="PREPROC-18" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="The controlling expression of a #if or #elif preprocessing directive shall evaluate to 0 or 1" id="PREPROC-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Match the filename in a #include directive to the one on the filesystem" id="PREPROC-20" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="#error directive shall not be used" id="PREPROC-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="The #pragma directive shall not be used" id="PREPROC-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor directives and the defined() operator" id="PREPROC-24" sev="3" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="#undef shall not be used" id="PREPROC-25" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="2;" authUrg="0;" cat="PREPROC" desc="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" id="PREPROC-26" sev="3" total="2"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Don't redefine primitive types" id="PREPROC-03" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="PREPROC" desc="Don't define part of statement" id="PREPROC-04" sev="4" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="A macro parameter used as an operand to the # or ## operators, which is itself subject to further macro replacement, shall only be used as an operand to these operators" id="PREPROC-17" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Incorrect 'NULL' definition" id="PREPROC-07" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="PREPROC" desc="Avoid token concatenation that may produce universal character names" id="PREPROC-21" sev="5" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="The methods inside the SIGNAL and SLOT macros have to exist" id="QT-04" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Do not force thread termination by calling QThread::terminate()" id="QT-07" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Do not call new on QMutexLocker" id="QT-09" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Do not directly set specific Widget attributes that are set by Qt kernel" id="QT-12" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Every QObject subclass should contain a Q_OBJECT macro" id="QT-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="QObject must not be inherited more than one time" id="QT-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="It's only possible to connect a signal to a slot or a signal to another signal" id="QT-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Mark signal emissions with the keyword &quot;emit&quot; to distinguish a signal emission from a normal method call" id="QT-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Do not set Idle or Critical priority to QThreads. Use High/Low/Med only" id="QT-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="If using lock on a mutex in a function, release the lock in the same function" id="QT-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Declare a copy constructor and operator= for any Qt - inherited objects that have pointers" id="QT-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Never mix const and non-const iterators in assignment" id="QT-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="If you use Q_DECLARE_FLAGS, you must also use Q_DECLARE_OPERATORS_FOR_FLAGS" id="QT-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Q_DECLARE_OPERATORS_FOR_FLAGS must be in the global namespace, Q_DECLARE_FLAGS inside the enum's namespace" id="QT-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="The getters and setters of a Q_PROPERTY must exist and the types must match" id="QT-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Properties of enum types must use Q_ENUMS" id="QT-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Non-const function should not be called on the Qt object" id="QT-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="QT" desc="Do not use setWindowFlags function on a Widget" id="QT-11" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Never use gets()" id="SECURITY-16" sev="1" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Use care to ensure that LoadLibrary() will load the correct library" id="SECURITY-04" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid calling functions printf/wprintf with only one argument other than string constant" id="SECURITY-05" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using functions fprintf/fwprintf with only two parameters, when second parameter is a variable" id="SECURITY-08" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using the 'data()' function from the 'string' class of the standard library" id="SECURITY-09" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using the 'vfork()' function" id="SECURITY-10" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using unsecured shell functions that may be affected by shell metacharacters" id="SECURITY-11" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using unsafe string functions which may cause buffer overflows" id="SECURITY-12" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using unsafe string functions that do not check bounds" id="SECURITY-13" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use scanf and fscanf functions without specifying variable size in format string" id="SECURITY-14" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="1;" authUrg="0;" cat="SECURITY" desc="Do not print potentially sensitive information, resulting from an application error into exception messages" id="SECURITY-15" sev="2" total="1"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid passing non-const parameters or variables into exec" id="SECURITY-17" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid passing dynamically created strings into exec" id="SECURITY-18" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Usage of functions prone to race is not allowed" id="SECURITY-19" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid passing user input into methods as parameters" id="SECURITY-20" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use 'syslog' function for logging purposes" id="SECURITY-21" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use mbstowcs() function" id="SECURITY-22" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Beware of functions which may return the current directory or the windows directory" id="SECURITY-23" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using InitializeCriticalSection" id="SECURITY-24" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using thread-unsafe functions" id="SECURITY-25" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use 'setuid' in source code" id="SECURITY-26" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Don't use chmod(), chown(), chgrp()" id="SECURITY-27" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Standard random number generators should not be used to generate randomness for security reasons" id="SECURITY-28" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use obsolete C routine ulimit()" id="SECURITY-29" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using 'getpw' function in program code" id="SECURITY-30" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use 'cuserid' function" id="SECURITY-31" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using obsolete C routine 'usleep'" id="SECURITY-32" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Usage of functions which do not properly handle non-NULL terminated strings is not allowed" id="SECURITY-33" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid using environment variables" id="SECURITY-34" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="13;" authUrg="0;" cat="SECURITY" desc="Don't trust any value of command line if attacker can set them" id="SECURITY-35" sev="2" total="13"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Never use unfiltered data from an untrusted user as the format parameter" id="SECURITY-36" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use weak encryption functions" id="SECURITY-37" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Untrusted data is used as a loop boundary" id="SECURITY-38" sev="2" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="The 'asctime()' and 'asctime_r()' functions should not be used" id="SECURITY-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="The random number generator functions 'rand()' and 'srand()' should not be used" id="SECURITY-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use the rand() function for generating pseudorandom numbers" id="SECURITY-02_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Avoid functions which use time from MFC library" id="SECURITY-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Don't use unsafe C functions that do write to range-unchecked buffers" id="SECURITY-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Use secure temporary file name functions" id="SECURITY-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Specify the access permission bits if a file is created using the 'open' or 'openat' system call" id="SECURITY-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="The function 'pthread_setcanceltype()' should not be called with 'PTHREAD_CANCEL_ASYNCHRONOUS' argument" id="SECURITY-43" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Observe correct revocation order while relinquishing privileges" id="SECURITY-44" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Ensure that privilege relinquishment is successful" id="SECURITY-45" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="A pointer to a structure should not be passed to a function that can copy data to the user space" id="SECURITY-46" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Use correct integer precisions when checking the right hand operand of the shift operator" id="SECURITY-47" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not call the 'system()' function from the 'stdlib.h' or 'cstdlib' library with an argument other than '0' (null pointer)" id="SECURITY-48" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="The 'system()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="SECURITY-48_b" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use the 'char' buffer to store input from 'std::cin'" id="SECURITY-51" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="The 'getenv()' function from the 'stdlib.h' or 'cstdlib' library shall not be used" id="SECURITY-52" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Usage of system properties (environment variables) should be restricted" id="SECURITY-03" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Call 'umask' before calling 'mkstemp'" id="SECURITY-40" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Call 'chdir' if you call 'chroot'" id="SECURITY-41" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Use the 'cnd_signal()' function with a unique condition variable" id="SECURITY-49" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="SECURITY" desc="Do not use the 'notify_one()' function when multiple threads are waiting on the same condition variable" id="SECURITY-50" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="To make copying efficient, correct, and immune to the slicing problem create containers of pointers instead of containers of objects" id="STL-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Call empty instead of checking size() against zero" id="STL-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Avoid using iterative calls to insert in an explicit loop" id="STL-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Almost all uses of copy where the destination range is specified using an insert iterator should be replaced with calls to range member functions" id="STL-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Instead of anonymous istream_iterator objects use istream_iterator names when used as function parameters" id="STL-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="When using containers of newed pointers, remember to delete the pointers before the container is destroyed" id="STL-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Never create containers of auto_ptrs" id="STL-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Avoid using remove algorithm with list and standard associative containers" id="STL-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Prefer vector and string to dynamically allocated arrays" id="STL-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Use reserve to avoid unnecessary reallocations" id="STL-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Each vector and string should be checked if it is not empty before it is passed to C function" id="STL-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Avoid using vector&lt;bool>" id="STL-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Specify comparison types for associative containers of pointers" id="STL-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="For associative containers never use comparison function returning true for equal values" id="STL-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="For associative containers never use comparison function returning true for equal values" id="STL-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Prefer iterator to const iterator, reverse_iterator, and const_reverse_iterator" id="STL-18" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Use distance and advance to convert a container's const_iterators to iterators" id="STL-19" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Make sure destination ranges are big enough" id="STL-22" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Follow remove-like algorithms by erase to remove elements from a container" id="STL-23" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Avoid using remove and similar algorithms (i.e., remove_if and unique) on containers of dynamically allocated pointers" id="STL-24" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Proper implementation of copy_if should not be based on returning the remove_copy_if with a not1 in front of the predicate" id="STL-26" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="If accumulate() is used on a container of floating point values, use floating point value as initial one" id="STL-27" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Design functor classes for pass-by-value" id="STL-28" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Make predicates const pure functions" id="STL-29" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Each functor class should has only one operator() function, and it's parameter and return types should be passed to unary_function or binary_function" id="STL-30" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="You must employ ptr_fun, mem_fun, or mem_fun_ref whenever you pass a function to an STL component" id="STL-31" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Make sure less&lt;T> means operator&lt;" id="STL-32" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Prefer algorithm calls to hand-written loops" id="STL-33" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Prefer member functions to algorithms with the same names" id="STL-34" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Do not rely on the conversion of count()'s nonzero values to true and zero to false" id="STL-35" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Do not use an iterator range that isn't really a range" id="STL-36" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="C-style arrays shall not be used" id="STL-37" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Use != instead of &lt; to compare iterators" id="STL-38" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Use traits classes in conjunction with overloading" id="STL-39" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="When calling swap, employ a using declaration for std::swap, then call swap without namespace qualification" id="STL-40" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Do not declare the non-member to be an overloading of std::swap" id="STL-41" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Member version of swap should never throw exceptions" id="STL-42" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Consider using vector&lt;char> instead of string" id="STL-11" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="It is necessary to be careful when using reverse_iterator's base iterator for erasure purposes" id="STL-20" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="Consider istreambuf_iterators for character-by-character input" id="STL-21" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="STL" desc="If you pass a sorted range to an algorithm that also takes a comparison function, be sure that the comparison function you pass behaves the same as the one you used to sort the range" id="STL-25" sev="4" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="4;" authUrg="0;" cat="STL" desc="Instead of trying to write the container-independent code use class encapsulation" id="STL-01" sev="5" total="4"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Factor parameter-independent code out of templates" id="TEMPL-01" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Define non-member functions inside templates when type conversions are desired" id="TEMPL-02" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Do not overload functions within a template class" id="TEMPL-03" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="In template global functions use 'typename' to identify nested dependent type names" id="TEMPL-04" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="In template classes use 'typename' to identify nested dependent type names" id="TEMPL-05" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Don't change default arguments of virtual functions in template classes" id="TEMPL-06" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="A copy constructor shall be declared when there is a template constructor with a single parameter that is a generic parameter" id="TEMPL-07" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="The viable function set for a function call should either contain no function specializations, or only contain function specializations" id="TEMPL-08" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Overloaded function templates shall not be explicitly specialized" id="TEMPL-09" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="All partial and explicit specializations for a template shall be declared in the same file as the declaration of their primary template" id="TEMPL-10" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="A copy assignment operator shall be declared when there is a template assignment operator with a parameter that is a generic parameter" id="TEMPL-11" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="In a class template with a dependent base, any name that may be found in that dependent base shall be referred to using a qualified-id or this->" id="TEMPL-12" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Do not declare non-member generic functions in associated namespaces" id="TEMPL-13" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="The function shall resolve to a function declared previously in the translation unit" id="TEMPL-14" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Declare 'extern' an explicitly instantiated template" id="TEMPL-15" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Template specialization shall be declared in the same file as the primary template or a user-defined type, for which the specialization is declared" id="TEMPL-16" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="Use a trailing return type syntax if the return type is preceded by the 'typename' keyword" id="TEMPL-17" sev="3" total="0"/>
            <Rule analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" authTot="0;" authUrg="0;" cat="TEMPL" desc="A non-member generic operator shall only be declared in a namespace that does not contain class (struct) type, enum type or union type declarations" id="TEMPL-18" sev="3" total="0"/>
         </RulesList>
         <SeverityList>
            <Severity authTot="7;" authUrg="0;" id="1" total="7"/>
            <Severity authTot="347;" authUrg="15;" id="2" total="347"/>
            <Severity authTot="706;" authUrg="29;" id="3" total="706"/>
            <Severity authTot="93;" authUrg="1;" id="4" total="93"/>
            <Severity authTot="51;" authUrg="5;" id="5" total="51"/>
         </SeverityList>
      </Rules>
      
  <Supps/>

      
  <StdViols>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="1" rule="METRICS-31" lnHash="-591606506" rule.header="The assertion density of the code should average to a minimum of two assertions per function" tool="c++test" lineHash="-591606506" unbViolId="2c307f71-60e5-3170-8fe1-7690089c8d1c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="703985b8-9157-3e93-a9b6-6246b33cdca3" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'main.cpp' should have the file name extension &quot;.cc&quot;" ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="1" rule="NAMING-38" lnHash="-591606506" rule.header="Implementation files in C++ always have the file name extension &quot;.cc&quot;" tool="c++test" lineHash="-591606506" unbViolId="f2826a11-bf03-3354-bff5-88b381f8c455" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="beb5f934-db17-3b36-a139-789459068388" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'main.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="5" auth="lyao" locRef="1" rule="PFO-04" lnHash="-591606506" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="-591606506" unbViolId="c20d2748-9e82-3b8e-a26c-3279e9c3841c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c589f0d0-a4f8-3f8d-a124-12c1c4375ec7" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'main.cpp'" ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="1" rule="COMMENT-02" lnHash="-591606506" rule.header="Provide copyright information" tool="c++test" lineHash="-591606506" unbViolId="86f3aa2e-c2ee-345b-997a-50c89eab6fc2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="47a52aa3-6185-3905-a595-dee670a731cc" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'main.cpp'" ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="1" rule="JSF-133_b" lnHash="-591606506" rule.header="Every source file will contain copyright information" tool="c++test" lineHash="-591606506" unbViolId="1abcd7df-fa7c-3882-98c9-0c11f92115a2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5a2fadfc-ef5f-389a-8bbd-a54c2753d039" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'main.cpp'" ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="1" rule="COMMENT-03" lnHash="-591606506" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="-591606506" unbViolId="b055ac0d-561b-390a-b6a9-cae0acd3c90a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4565ee61-746d-3094-a7ba-621e61bf8ffa" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'main.cpp'" ln="1" locFile="/src/../../../../../../../../src/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="1" rule="JSF-133_a" lnHash="-591606506" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="-591606506" unbViolId="8a0467b2-a20e-388d-99e4-1812b77016db" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5f6af1f9-0e18-308e-9757-98d31f6be4f3" locEndPos="1" locType="sr" hash="1535005727" locEndLn="1" goals="0,"/>
    <DupViol msg="Duplicated code: 'using namespace std;'" ln="4" locFile="/src/../../../../../../../../src/main.cpp" locStartln="4" sev="3" auth="lyao" locRef="1" rule="CDD-DUPC" lnHash="316495161" rule.header="Avoid code duplication" tool="c++test" lineHash="316495161" unbViolId="41fee40c-70d7-36b7-8bcb-72e413e60c2e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="24680098-47ce-384e-bbd3-2b903e28b977" locType="sr" locEndPos="20" urgent="true" hash="1535005727" locEndLn="4" goals="1,">
      <ElDescList>
        <ElDesc lineHash="316495161" ln="4" srcRngStartPos="0" srcRngEndPos="20" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="4" srcRngEndLn="4" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 4] Duplicated code in file 'main.cpp'" rngLn="4"/>
        <ElDesc lineHash="316495161" ln="7" srcRngStartPos="0" srcRngEndPos="20" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="7" srcRngEndLn="7" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 7] Duplicated code in file 'divider_tests.cpp'" rngLn="7"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="4" locFile="/src/../../../../../../../../src/main.cpp" locStartln="4" sev="3" auth="lyao" locRef="1" rule="HICPP-7_3_1-a" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="6892d50c-8ad0-3c05-b0fc-83ba20c0fe8c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="052b41d0-cdaa-315a-8cc6-b26b6cd9dfab" locEndPos="1" locType="sr" hash="1535005727" locEndLn="4" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="4" locFile="/src/../../../../../../../../src/main.cpp" locStartln="4" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-M7_3_4-a" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="4fc41430-a0d9-370f-a7db-ec554ae79162" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="582eb55a-59c3-3df9-a3d0-7689dfec079f" locEndPos="1" locType="sr" hash="1535005727" locEndLn="4" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="4" locFile="/src/../../../../../../../../src/main.cpp" locStartln="4" sev="3" auth="lyao" locRef="1" rule="CODSTA-CPP-75" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="0608dc61-4fd0-3888-b5c8-f8309a9824a2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fe5c3c7b-5706-3f45-8e28-807738df698a" locEndPos="1" locType="sr" hash="1535005727" locEndLn="4" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="4" locFile="/src/../../../../../../../../src/main.cpp" locStartln="4" sev="2" auth="lyao" locRef="1" rule="MISRA2008-7_3_4" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="e4fcc72d-328f-34a4-87bc-3a7e26f63c20" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9eb82657-1a4f-3231-9c04-05dafdff351b" locEndPos="1" locType="sr" hash="1535005727" locEndLn="4" goals="0,"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="FORMAT-47_a" lnHash="-1508144532" rule.header="Place CV-qualifiers on the right hand side of the type they apply to" tool="c++test" lineHash="-1508144532" unbViolId="e4bbdfad-424c-3c64-9335-f2ccb79b9398" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0955849f-a2b0-3638-889b-53d327ea070a" locEndPos="8" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="HICPP-7_1_4-a" lnHash="-1508144532" rule.header="Place CV-qualifiers on the right hand side of the type they apply to" tool="c++test" lineHash="-1508144532" unbViolId="ff6644fb-c684-3410-9912-39835e660bb1" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d967eca3-34aa-37ba-bc2f-426a847d7038" locEndPos="8" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="4" auth="lyao" locRef="1" rule="MISRA2008-3_9_2" lnHash="-1508144532" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="-1508144532" unbViolId="3bfb52c2-25c7-3688-91ed-de54f1ff4139" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a4482630-0732-3ded-80d4-de13e6ec2379" locEndPos="14" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="MISRA-013" lnHash="-1508144532" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="-1508144532" unbViolId="2021d10a-94c7-304c-9949-251212259ca2" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c356306f-7b98-34e8-9682-a29eca0d7d70" locEndPos="14" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Consider using 'constexpr' instead of 'const' for the 'HEADER' variable" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="4" auth="lyao" locRef="1" rule="CODSTA-MCPP-11_a_cpp11" lnHash="-1508144532" rule.header="Use constexpr to declare const variables whenever possible" tool="c++test" lineHash="-1508144532" unbViolId="b8f32870-48fa-3c9e-9a77-75299c4193b8" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b01744f5-9ad9-362d-af46-a2aca5e2caa0" locEndPos="26" locType="sr" urgent="true" hash="1535005727" locEndLn="6" goals="1,"/>
    <StdViol msg="Consider using 'constexpr' instead of 'const' for the 'HEADER' variable" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A7_1_2-a" lnHash="-1508144532" rule.header="Use constexpr to declare const variables whenever possible" tool="c++test" lineHash="-1508144532" unbViolId="5c092cdf-8841-375b-975d-7d111b7f667f" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="27fc44f2-5cc6-3c9a-88b8-ec9cd4bf763a" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The definition of the 'HEADER' variable should contain a braced initializer" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A8_5_2-a" lnHash="-1508144532" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-1508144532" unbViolId="93c4c81d-7128-3eba-af2a-67587d593ff0" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e2e6bb3b-a2a7-34c9-94be-901e26d4a577" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The definition of the 'HEADER' variable should contain a braced initializer" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="CODSTA-MCPP-38" lnHash="-1508144532" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-1508144532" unbViolId="43ec177b-cbda-3861-9936-d808f5128293" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9fed33be-820d-33aa-ad3f-37790d636e16" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is being used only in a single function 'main'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="4" auth="lyao" locRef="1" rule="JSF-136_a" lnHash="-1508144532" rule.header="Objects should be defined at block scope if they are only accessed from within a single function" tool="c++test" lineHash="-1508144532" unbViolId="84bb1a91-ebab-3327-ad69-1e35a16c8abb" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6257ab36-c0f2-3ab1-acf8-35c1919c1329" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is being used only in a single function 'main'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="MISRA2004-8_7" lnHash="-1508144532" rule.header="Objects shall be defined at block scope if they are only accessed from within a single function" tool="c++test" lineHash="-1508144532" unbViolId="80aa88b0-1e5e-3062-91e7-75336ecc3ce4" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f4b609e6-41b7-33b6-b24a-b8ec49facfd4" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is being used only in a single function 'main'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="4" auth="lyao" locRef="1" rule="MISRAC2012-RULE_8_9-a" lnHash="-1508144532" rule.header="Objects shall be defined at block scope if they are only accessed from within a single function" tool="c++test" lineHash="-1508144532" unbViolId="861e0470-a5d4-3a60-a07a-9a66d1931e1c" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f75d08d3-611a-34be-a961-8319810795c4" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is being used only in a single function 'main'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="4" auth="lyao" locRef="1" rule="MISRA2012-RULE-8_9" lnHash="-1508144532" rule.header="An object should be defined at block scope if its identifier only appears in a single function" tool="c++test" lineHash="-1508144532" unbViolId="04538310-42ca-3c04-9171-8f63d565b0e7" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3954389e-b053-34ae-90cd-c2f5c1488d8a" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Variable's name 'HEADER' should be lowercase" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="NAMING-42" lnHash="-1508144532" rule.header="Identifiers for constant and enumerator values shall be lowercase" tool="c++test" lineHash="-1508144532" unbViolId="2a4bac54-ccaf-3644-9454-6982b0c21622" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b39831cb-0619-3a7d-90ca-7610e89189b8" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Variable's name 'HEADER' should be lowercase" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="JSF-052" lnHash="-1508144532" rule.header="Identifiers for constant and enumerator values shall be lowercase" tool="c++test" lineHash="-1508144532" unbViolId="39ee0b87-59a5-3c38-968a-2ed9ebeeb0a3" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="19764544-6651-3469-80cb-fd381e2620b5" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The string literal should not initialize the 'const char *' type" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A27_0_4-d" lnHash="-1508144532" rule.header="C-style strings shall not be used" tool="c++test" lineHash="-1508144532" unbViolId="efbf4129-570f-3ad9-ac74-a618c92b6c72" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ac5821a0-7e75-30eb-80f4-8a10f6bf76da" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The string literal should not initialize the 'const char *' type" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="PB-76" lnHash="-1508144532" rule.header="C-style strings shall not be used" tool="c++test" lineHash="-1508144532" unbViolId="b0ded2ee-33d7-38b8-b563-2ae061991788" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="84a8664d-2234-3e3d-9ce7-d80c8c734f89" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is declared in global namespace" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="4" auth="lyao" locRef="1" rule="JSF-098" lnHash="-1508144532" rule.header="Every nonlocal name, except main(), should be placed in some namespace" tool="c++test" lineHash="-1508144532" unbViolId="1a84ffd9-8790-356b-90c8-b038fc96ef47" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ee54bcc5-be7a-30f8-a1f2-b5e5d4a68356" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is declared in global namespace" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-M7_3_1-a" lnHash="-1508144532" rule.header="The global namespace shall only contain main() and namespace declarations" tool="c++test" lineHash="-1508144532" unbViolId="08661781-27c4-3ddc-a385-1ade6807f1b9" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="06557fe3-acf9-3b87-bd89-d188165d37ce" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is declared in global namespace" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="CODSTA-CPP-36" lnHash="-1508144532" rule.header="The global namespace shall only contain main() and namespace declarations" tool="c++test" lineHash="-1508144532" unbViolId="70449507-d9d2-308c-ac0a-c2aae10aee8f" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="201bcbc3-4853-3779-9d77-145e19f285d5" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is declared in global namespace" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="MISRA2008-7_3_1" lnHash="-1508144532" rule.header="The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" tool="c++test" lineHash="-1508144532" unbViolId="c03f5523-05de-317c-84ef-4f8a63ec3352" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0c52d8ee-0e03-3e3e-996a-77ca3ec439d6" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The variable of pointer or array type is declared: HEADER" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="CODSTA-94" lnHash="-1508144532" rule.header="Do not declare pointer or array type" tool="c++test" lineHash="-1508144532" unbViolId="2bcfd80d-a79f-3730-aeb6-aa3ee601421e" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fec6ee50-761a-368f-9b05-3f0405cd63cc" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The variable of pointer type is declared: HEADER" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="CODSTA-95" lnHash="-1508144532" rule.header="Do not declare pointer type" tool="c++test" lineHash="-1508144532" unbViolId="10d74452-2b85-3bca-b16f-f8199f78d3f7" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8328028c-6392-38ad-aca7-6571489163f4" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="'HEADER' should be encapsulated in a class" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="5" auth="lyao" locRef="1" rule="CODSTA-CPP-18" lnHash="-1508144532" rule.header="Encapsulate global variables and constants, enumerated types, and typedefs in a class" tool="c++test" lineHash="-1508144532" unbViolId="87d8815e-c5bb-3387-a1e7-cf47415c486d" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="891e9612-13cf-3747-a198-cf1d1be5c4ea" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'HEADER' variable should be commented" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="JSF-132_a" lnHash="-1508144532" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="-1508144532" unbViolId="f5bb10d1-bebc-33af-a29e-a24e0c535bcb" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c97e35e5-a94f-3e3d-937b-c9f991f96125" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'HEADER' variable should be commented" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="COMMENT-05" lnHash="-1508144532" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="-1508144532" unbViolId="cffd791f-8a73-3ab6-a532-17966f53995a" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e6f246a-94d8-3d77-9af1-7ad0b46e86c0" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' is declared" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="5" auth="lyao" locRef="1" rule="MISRA-022" lnHash="-1508144532" rule.header="Declare objects at function scope" tool="c++test" lineHash="-1508144532" unbViolId="3dc4e122-280b-3374-9b81-701072d2b6da" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4c7f6c16-54f8-3a11-89f1-bb7153401aeb" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Global variable 'HEADER' shall begin with a lowercase letter" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-06" lnHash="-1508144532" rule.header="Begin global variable names with a lowercase letters" tool="c++test" lineHash="-1508144532" unbViolId="1f80ec94-450b-3574-b2c1-9770549f3a1f" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92aa7aba-3706-3c86-a8bf-7e6aa691451c" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Naming convention not followed: HEADER" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-13" lnHash="-1508144532" rule.header="Begin constant variables with 'c'" tool="c++test" lineHash="-1508144532" unbViolId="ab4c6cf9-94fa-3a38-8e11-665abff80061" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c63af9cf-5d4b-3736-a299-719526d30a65" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Naming convention not followed: HEADER" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-18" lnHash="-1508144532" rule.header="Begin global variable names with 'the'" tool="c++test" lineHash="-1508144532" unbViolId="d0043f09-5292-39e5-8653-b137dae7716d" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ddcfb8b8-de3a-3513-af49-532531c7b610" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Naming convention not followed: HEADER" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-22" lnHash="-1508144532" rule.header="Prefix a variable type 'pointer' with a 'p' character" tool="c++test" lineHash="-1508144532" unbViolId="03387f24-3c75-3937-bfb1-1aecc7a59a16" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="72f69a91-4468-34f3-a9c0-4620fee731d5" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Naming convention not followed: HEADER" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-25" lnHash="-1508144532" rule.header="Begin all terminated characters string variables with 'sz'" tool="c++test" lineHash="-1508144532" unbViolId="3f361d05-14c1-36a0-881e-456e0b1dd233" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3320a817-649f-3409-a5c8-f1a6e7806980" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'HEADER' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-05" lnHash="-1508144532" rule.header="Hungarian notation for byte pointer, array, or reference types" tool="c++test" lineHash="-1508144532" unbViolId="bcc3997b-09e6-3918-8ec0-779ae9cbe252" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="69663b3e-8e11-33b6-8c66-193bc3f695a1" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'HEADER' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-09" lnHash="-1508144532" rule.header="Hungarian notation for char pointer, array, or reference types" tool="c++test" lineHash="-1508144532" unbViolId="ea31bf76-3351-3d70-a099-99d0c10d817c" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e635a63a-7938-3dc2-982a-4a4f9a92e557" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'HEADER' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-10" lnHash="-1508144532" rule.header="Hungarian notation for char pointer or reference types" tool="c++test" lineHash="-1508144532" unbViolId="f6afd136-ae91-36f0-8be7-44880dad551a" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa42d70a-127b-304d-b08f-8df4e5bbcba6" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The 'HEADER' identifier should have the 'p' prefix" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-34" lnHash="-1508144532" rule.header="Hungarian notation for pointer" tool="c++test" lineHash="-1508144532" unbViolId="ed2fbaac-ea48-3205-b9e7-be731a2b47c4" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5978ebe2-5b85-3cb1-a775-2bc80d2c37cf" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Static variable HEADER is used/referenced in one function only: &quot;main&quot;" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="OPT-11" lnHash="-1508144532" rule.header="If a file-level static variable is used/referenced in one function only then include that variable in the function itself" tool="c++test" lineHash="-1508144532" unbViolId="cbd610c9-d78b-3ebe-b2c9-25e26361eb06" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b31d7b6e-d944-388b-aea0-1ef660e7514b" locEndPos="26" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Divider  2018 Monkey Claps Inc." ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="5" auth="lyao" locRef="1" rule="CWE-798-a" lnHash="-1508144532" rule.header="Do not hard code string literals" tool="c++test" lineHash="-1508144532" unbViolId="990d671e-363f-3831-ab93-743947448f31" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dc2cf1ee-a6af-3d5e-a408-679838b57822" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Divider  2018 Monkey Claps Inc." ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="5" auth="lyao" locRef="1" rule="CODSTA-203" lnHash="-1508144532" rule.header="Do not hard code string literals" tool="c++test" lineHash="-1508144532" unbViolId="300dc744-233a-3cc1-9274-9dfc19a2ab95" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c5328a63-407b-3aa1-9905-dc8ef16a8386" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Divider  2018 Monkey Claps Inc." ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="1" auth="lyao" locRef="1" rule="APSC_DV-003110-a" lnHash="-1508144532" rule.header="Do not hard code string literals" tool="c++test" lineHash="-1508144532" unbViolId="4d33cc17-b0aa-3ca6-bd5b-9f3b4290c5b9" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92175ab5-4ea0-39aa-98e4-bdf3f389cbcc" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Divider  2018 Monkey Claps Inc." ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="1" auth="lyao" locRef="1" rule="CERT_C-MSC41-a" lnHash="-1508144532" rule.header="Do not hard code string literals" tool="c++test" lineHash="-1508144532" unbViolId="010076d9-e6f2-358a-b512-1c0c6b416da3" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="01602c93-7211-3a45-8098-411645119f08" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Undefined character was found: '\xc2', '\xa9'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="CERT_C-MSC09-a" lnHash="-1508144532" rule.header="Only use characters defined in the ISO C standard" tool="c++test" lineHash="-1508144532" unbViolId="adc534d6-c69a-3955-af46-c1776536fceb" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ffc3aa8a-ee1e-3b55-af6c-1b7eacc8cb0e" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Undefined character was found: '\xc2', '\xa9'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="JSF-009" lnHash="-1508144532" rule.header="Only those characters specified in the C++ basic source character set will be used" tool="c++test" lineHash="-1508144532" unbViolId="15b91eef-b1db-37bc-a261-9f1c3fa2d942" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b95cb4be-9ff2-3f78-bde2-ab9a67d885e2" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Undefined character was found: '\xc2', '\xa9'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A2_3_1-a" lnHash="-1508144532" rule.header="Only use characters defined in the ISO C standard" tool="c++test" lineHash="-1508144532" unbViolId="a85064fa-5f93-354f-96cd-edc40eb1ab7e" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5645f271-823f-36c0-a5e5-7457c3406c64" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Undefined character was found: '\xc2', '\xa9'" ln="6" locFile="/src/../../../../../../../../src/main.cpp" locStartln="6" sev="3" auth="lyao" locRef="1" rule="MISRA-005" lnHash="-1508144532" rule.header="Only use characters defined in the ISO C standard" tool="c++test" lineHash="-1508144532" unbViolId="e043ebb5-30fc-3054-8015-0a9b0ee7f54f" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="920ce8d6-33d6-33c0-9080-fda46a188d3f" locEndPos="35" locType="sr" hash="1535005727" locEndLn="6" goals="0,"/>
    <StdViol msg="Line has over 79 characters" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="FORMAT-04" lnHash="217133830" rule.header="Physical lines should be less than eighty characters" tool="c++test" lineHash="217133830" unbViolId="64d04070-d43d-3974-83e8-9062ae2bdfd9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a3dfb8bd-7384-3dd9-b869-3667446f7234" locEndPos="1" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Line contains more than 120 characters: 196" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="JSF-041" lnHash="217133830" rule.header="Source lines will be kept to a length of 120 characters or less" tool="c++test" lineHash="217133830" unbViolId="fccaffbe-1cb3-3119-afd0-fb1994e763dd" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="de814c45-6ed5-3a41-a5ba-c5c7a4c69573" locEndPos="1" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Line contains more than 120 characters: 196" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="METRICS-26" lnHash="217133830" rule.header="Source lines will be kept to a length of 120 characters or less" tool="c++test" lineHash="217133830" unbViolId="315121d2-8274-39fc-90e6-e7bce3906d0a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="994eda30-36ad-31d2-876c-ff0dfbe26a13" locEndPos="1" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="FORMAT-47_a" lnHash="217133830" rule.header="Place CV-qualifiers on the right hand side of the type they apply to" tool="c++test" lineHash="217133830" unbViolId="09b6295e-941e-34e3-b670-a00bb506120c" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8b09d350-fdf6-3cc1-8b67-98d6cda2d63d" locEndPos="8" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="HICPP-7_1_4-a" lnHash="217133830" rule.header="Place CV-qualifiers on the right hand side of the type they apply to" tool="c++test" lineHash="217133830" unbViolId="9890d067-d901-3ae7-bda4-e632dbdf7eb4" locStartPos="7" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="24cd8ef6-3bb5-32a6-8c80-bc6509b03c35" locEndPos="8" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="4" auth="lyao" locRef="1" rule="MISRA2008-3_9_2" lnHash="217133830" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="217133830" unbViolId="6f0e6c91-fcd3-3e20-b018-879d6538959a" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="71593fbe-1b5d-3c4d-9f16-5407e05bdfd0" locEndPos="14" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="MISRA-013" lnHash="217133830" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="217133830" unbViolId="d4506240-1532-3631-9e3f-9b5f54021d8b" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a818b6fc-85ae-34ed-8c61-6c46cc3aecc5" locEndPos="14" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Consider using 'constexpr' instead of 'const' for the 'USAGE' variable" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="4" auth="lyao" locRef="1" rule="CODSTA-MCPP-11_a_cpp11" lnHash="217133830" rule.header="Use constexpr to declare const variables whenever possible" tool="c++test" lineHash="217133830" unbViolId="2f6fa80f-2c4b-3b8c-9628-989bc484440d" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="baaee0fe-a935-3dbf-b121-b5023b2044c0" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Consider using 'constexpr' instead of 'const' for the 'USAGE' variable" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A7_1_2-a" lnHash="217133830" rule.header="Use constexpr to declare const variables whenever possible" tool="c++test" lineHash="217133830" unbViolId="83751cfd-35d5-3232-aef4-09c160a4da50" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4c839e2f-f559-35f5-9b77-a2919785551d" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The definition of the 'USAGE' variable should contain a braced initializer" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A8_5_2-a" lnHash="217133830" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="217133830" unbViolId="316bb8b2-31ff-3efa-88f7-5ed4bff9430d" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="448984e2-0429-354d-a0b8-832960cdeb3e" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The definition of the 'USAGE' variable should contain a braced initializer" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="CODSTA-MCPP-38" lnHash="217133830" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="217133830" unbViolId="60bbb4e6-47ec-3111-b7fe-995d05e48ae4" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed9203fd-33b1-357a-956a-b131a364e577" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is being used only in a single function 'main'" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="4" auth="lyao" locRef="1" rule="JSF-136_a" lnHash="217133830" rule.header="Objects should be defined at block scope if they are only accessed from within a single function" tool="c++test" lineHash="217133830" unbViolId="383e8fd8-419e-3688-b23d-995b0325089d" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b1c3c416-cbf1-36a1-848f-a65e57173a0d" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is being used only in a single function 'main'" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="MISRA2004-8_7" lnHash="217133830" rule.header="Objects shall be defined at block scope if they are only accessed from within a single function" tool="c++test" lineHash="217133830" unbViolId="b4939788-6b67-39dc-9bd0-0c444365f142" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="da9fe895-36f2-365f-b474-9755d25c9fac" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is being used only in a single function 'main'" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="4" auth="lyao" locRef="1" rule="MISRAC2012-RULE_8_9-a" lnHash="217133830" rule.header="Objects shall be defined at block scope if they are only accessed from within a single function" tool="c++test" lineHash="217133830" unbViolId="e34fd105-8911-37fa-ac20-21dc4e243318" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="95419cd4-2ca2-3798-ab24-e2e98a5b7236" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is being used only in a single function 'main'" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="4" auth="lyao" locRef="1" rule="MISRA2012-RULE-8_9" lnHash="217133830" rule.header="An object should be defined at block scope if its identifier only appears in a single function" tool="c++test" lineHash="217133830" unbViolId="ddaff3b3-eac6-3334-835e-c0c8cf0b8d8b" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="18ed0560-1f8f-3cfc-98fd-628999095131" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Variable's name 'USAGE' should be lowercase" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="NAMING-42" lnHash="217133830" rule.header="Identifiers for constant and enumerator values shall be lowercase" tool="c++test" lineHash="217133830" unbViolId="c3372761-9d76-34e8-9c91-82c4b8ed3ffb" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="acdb7b62-3d53-3cc0-ac9a-c6832ab5c5dd" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Variable's name 'USAGE' should be lowercase" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="JSF-052" lnHash="217133830" rule.header="Identifiers for constant and enumerator values shall be lowercase" tool="c++test" lineHash="217133830" unbViolId="dd8cee57-4b9a-34a7-8f16-407e2cb24b0c" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3547a752-05c7-37c7-af97-4dbc830f7ecb" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The string literal should not initialize the 'const char *' type" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A27_0_4-d" lnHash="217133830" rule.header="C-style strings shall not be used" tool="c++test" lineHash="217133830" unbViolId="ac56a6a9-5dd5-3c30-bf43-7dc2290d0cd0" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0da174d0-b4da-38ab-9b4c-8932e852859b" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The string literal should not initialize the 'const char *' type" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="PB-76" lnHash="217133830" rule.header="C-style strings shall not be used" tool="c++test" lineHash="217133830" unbViolId="57dd77c1-818f-303f-bcb7-58be78c073be" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed021720-1057-3616-8de1-591f08cb9ec4" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is declared in global namespace" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="4" auth="lyao" locRef="1" rule="JSF-098" lnHash="217133830" rule.header="Every nonlocal name, except main(), should be placed in some namespace" tool="c++test" lineHash="217133830" unbViolId="265c0c79-08b3-3dfa-91c3-f1b171cef0fd" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="71e4fa69-2f22-35f3-a6db-0a311c5f08f5" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is declared in global namespace" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-M7_3_1-a" lnHash="217133830" rule.header="The global namespace shall only contain main() and namespace declarations" tool="c++test" lineHash="217133830" unbViolId="d779870c-604b-3d11-b977-a77a2f313e3a" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9d6a375-c1e7-37cf-a920-32e1a618cf08" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is declared in global namespace" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="CODSTA-CPP-36" lnHash="217133830" rule.header="The global namespace shall only contain main() and namespace declarations" tool="c++test" lineHash="217133830" unbViolId="3e453e53-323c-35e6-a588-f0273547b736" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="de409509-1e79-3e17-b778-f78e86731694" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is declared in global namespace" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="2" auth="lyao" locRef="1" rule="MISRA2008-7_3_1" lnHash="217133830" rule.header="The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" tool="c++test" lineHash="217133830" unbViolId="cada2599-9f23-321e-afae-0a1ec7769b85" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c5ee2845-fd8b-395f-9cd0-16ec2fee9e93" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The variable of pointer or array type is declared: USAGE" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="CODSTA-94" lnHash="217133830" rule.header="Do not declare pointer or array type" tool="c++test" lineHash="217133830" unbViolId="a01eab6e-bd2b-30bc-a186-d46c5ac58061" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c242d456-e3d7-377e-b29c-8d46a65ab102" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The variable of pointer type is declared: USAGE" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="CODSTA-95" lnHash="217133830" rule.header="Do not declare pointer type" tool="c++test" lineHash="217133830" unbViolId="b42f9018-7238-35a2-afb6-0218f570175b" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c1d43005-30b4-340f-af46-b2baa797685c" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="'USAGE' should be encapsulated in a class" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="5" auth="lyao" locRef="1" rule="CODSTA-CPP-18" lnHash="217133830" rule.header="Encapsulate global variables and constants, enumerated types, and typedefs in a class" tool="c++test" lineHash="217133830" unbViolId="05e53a69-86ed-35f1-9b8d-85aea233ac82" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="87b93220-3119-3633-8184-46eecd96d299" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'USAGE' variable should be commented" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="JSF-132_a" lnHash="217133830" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="217133830" unbViolId="05489d52-7f08-303e-ba01-e6ab5143c1ae" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="43cc9dd6-be24-3716-982e-2030e0c264e0" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'USAGE' variable should be commented" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="COMMENT-05" lnHash="217133830" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="217133830" unbViolId="91d7b5c8-37db-323b-ae04-4720b8a48eb4" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3b679013-d38c-30e1-b6fe-0e3c1b9fec1f" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' is declared" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="5" auth="lyao" locRef="1" rule="MISRA-022" lnHash="217133830" rule.header="Declare objects at function scope" tool="c++test" lineHash="217133830" unbViolId="6d5b5531-f596-3500-b415-27bf50330d57" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d15c71f4-7440-3053-a39a-072177f96d7f" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Global variable 'USAGE' shall begin with a lowercase letter" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-06" lnHash="217133830" rule.header="Begin global variable names with a lowercase letters" tool="c++test" lineHash="217133830" unbViolId="d2b83c83-77c5-38e7-81f2-e003278a5de5" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8b84ee50-aa60-3aeb-93b0-e94ed9692c16" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Naming convention not followed: USAGE" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-13" lnHash="217133830" rule.header="Begin constant variables with 'c'" tool="c++test" lineHash="217133830" unbViolId="dbcbcb56-3def-3d7d-b738-3d676a4d4d7f" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="59b8c95e-8ba3-33ac-9491-a93c504a9c5e" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Naming convention not followed: USAGE" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-18" lnHash="217133830" rule.header="Begin global variable names with 'the'" tool="c++test" lineHash="217133830" unbViolId="c3cd5c5e-7f3b-3ee8-b8d1-91bafbb90e07" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa03415b-f6f1-3f81-be38-38c53d2a0125" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Naming convention not followed: USAGE" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-22" lnHash="217133830" rule.header="Prefix a variable type 'pointer' with a 'p' character" tool="c++test" lineHash="217133830" unbViolId="93312d98-35f2-3f4c-8613-d0658ce6d4ae" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="94d03332-b3ad-3938-8df1-f5e519a05192" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Naming convention not followed: USAGE" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-25" lnHash="217133830" rule.header="Begin all terminated characters string variables with 'sz'" tool="c++test" lineHash="217133830" unbViolId="a45c52ff-cb71-3f23-9ca4-15000243f7a0" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4fb7c1f5-8a76-3439-9b7f-ca5b398fa2c6" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'USAGE' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-05" lnHash="217133830" rule.header="Hungarian notation for byte pointer, array, or reference types" tool="c++test" lineHash="217133830" unbViolId="5c91a745-50a4-3842-9772-92c0fe57d3ea" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="348639c3-e9c2-376d-b159-7aa2243c72ef" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'USAGE' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-09" lnHash="217133830" rule.header="Hungarian notation for char pointer, array, or reference types" tool="c++test" lineHash="217133830" unbViolId="28a053e8-4713-37d4-b061-b453f67e63aa" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="89d80d05-a98d-3114-9e5c-b22b469bc0f2" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'USAGE' identifier should have the 'c' prefix followed by a capital letter or an underscore" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-10" lnHash="217133830" rule.header="Hungarian notation for char pointer or reference types" tool="c++test" lineHash="217133830" unbViolId="317b8a45-78c5-33ed-a5c8-1310434f12e6" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="189e4e74-0f06-38b3-9b0c-fb7f75546933" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'USAGE' identifier should have the 'p' prefix" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-34" lnHash="217133830" rule.header="Hungarian notation for pointer" tool="c++test" lineHash="217133830" unbViolId="99054d08-ad6a-3b90-ae3e-7283d08b141c" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e8df018e-8e2e-36ae-96ce-5f3880df2515" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Static variable USAGE is used/referenced in one function only: &quot;main&quot;" ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="3" auth="lyao" locRef="1" rule="OPT-11" lnHash="217133830" rule.header="If a file-level static variable is used/referenced in one function only then include that variable in the function itself" tool="c++test" lineHash="217133830" unbViolId="19e83f1a-f7cd-3a0d-8813-11f5b84e2f82" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c88a8df3-58ff-33d2-81b1-1546808613a2" locEndPos="26" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Usage:&#x9;divider &lt;numerator> &lt;denominator>Description:&#x9;Computes the result of a fractional division,&#x9;and reports both the result and the remainder." ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="5" auth="lyao" locRef="1" rule="CWE-798-a" lnHash="217133830" rule.header="Do not hard code string literals" tool="c++test" lineHash="217133830" unbViolId="54280bff-d52a-33ec-8986-26c2b669c8c8" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f29b55d-3dcd-31fd-8bd3-7bf48bde88a3" locEndPos="34" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Usage:&#x9;divider &lt;numerator> &lt;denominator>Description:&#x9;Computes the result of a fractional division,&#x9;and reports both the result and the remainder." ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="5" auth="lyao" locRef="1" rule="CODSTA-203" lnHash="217133830" rule.header="Do not hard code string literals" tool="c++test" lineHash="217133830" unbViolId="b7a82039-a24b-3efb-af12-dfb04df5a832" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0bfbe9b6-d045-389f-a1d8-bb35978d0809" locEndPos="34" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Usage:&#x9;divider &lt;numerator> &lt;denominator>Description:&#x9;Computes the result of a fractional division,&#x9;and reports both the result and the remainder." ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="1" auth="lyao" locRef="1" rule="APSC_DV-003110-a" lnHash="217133830" rule.header="Do not hard code string literals" tool="c++test" lineHash="217133830" unbViolId="dd794dc4-f3f2-3a4b-99c8-9380cf2de5b9" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e0a3a08-afbd-3496-8b68-0abafbfa3cb9" locEndPos="34" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="The string literal is embedded directly in the code: Usage:&#x9;divider &lt;numerator> &lt;denominator>Description:&#x9;Computes the result of a fractional division,&#x9;and reports both the result and the remainder." ln="7" locFile="/src/../../../../../../../../src/main.cpp" locStartln="7" sev="1" auth="lyao" locRef="1" rule="CERT_C-MSC41-a" lnHash="217133830" rule.header="Do not hard code string literals" tool="c++test" lineHash="217133830" unbViolId="662860ef-dbfa-3efe-b8f0-e33bb0fe3d69" locStartPos="33" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ef7739d1-fb07-3172-aa59-67b22e6c17a9" locEndPos="34" locType="sr" hash="1535005727" locEndLn="7" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 4" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="METRICS-19" lnHash="1009627957" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="1009627957" unbViolId="c44a65ff-88c7-3ce5-98d9-22ec360b060a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4225cfc0-3c0a-39a6-94ef-79380806bacb" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The function 'main' has more than 20 lines and less than 2 assertions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="METRICS-32" lnHash="1009627957" rule.header="All functions with more than 20 lines should contain at least 2 assertions" tool="c++test" lineHash="1009627957" unbViolId="12c337ed-54b9-3190-ae73-b2ad12872f9b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5eb5ec85-b7f5-358b-bc4c-896dc9225278" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="JSF-061" lnHash="1009627957" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1009627957" unbViolId="391cc766-7eac-39a7-9e69-cf212d475565" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bee4522d-08ee-3a3f-bcd8-afa76143f58d" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="FORMAT-42" lnHash="1009627957" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1009627957" unbViolId="b91abf64-f0d3-3bb6-b9e3-08a778f57e46" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="582943cf-6201-3a4f-88b4-408f6b9ba830" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="JSF-060_a" lnHash="1009627957" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1009627957" unbViolId="9967a7a9-aea5-3e0e-b696-fce96c9e7f6c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="59a41132-ab0c-3487-82bc-a520244b12df" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="FORMAT-43" lnHash="1009627957" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1009627957" unbViolId="a3a17073-c6fb-3aa8-a009-cfc227ab1540" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="504c8d5f-db99-3ded-b77c-3f63d9447e0b" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="JSF-060_b" lnHash="1009627957" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1009627957" unbViolId="be74c91b-7616-3b59-b7da-1a24a50df8d8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8b844a8d-223c-348e-97cc-7f433dd4bc74" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="FORMAT-02" lnHash="1009627957" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="1009627957" unbViolId="f928cb5e-8664-3ed3-9508-0e8b0d32e159" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="27dfb5d1-2130-3c92-adef-01ab23a072f3" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="FORMAT-34" lnHash="1009627957" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="1009627957" unbViolId="85253807-077b-33cb-9960-e2b9dfbf2ce9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5f4f9d0f-dcaf-3a35-8922-64d9cfe87089" locEndPos="1" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="COMMENT-04" lnHash="1009627957" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="1009627957" unbViolId="0d10b399-5860-3a11-abfc-4f473737f472" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="302f4647-4e79-30ca-abbe-b635762d5af9" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="JSF-134" lnHash="1009627957" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="1009627957" unbViolId="4bf1566a-d6fb-30d0-be3e-3674e39c582e" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d69972be-88dd-3eb5-ae79-73342344207b" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="COMMENT-14" lnHash="1009627957" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="1009627957" unbViolId="4c35c65a-8bef-3837-b2f8-050a48a7cefd" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7d194ea0-19ab-3208-83ff-16c6e4ab3b42" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A2_7_3-a" lnHash="1009627957" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="1009627957" unbViolId="f484b1e4-9366-3dd6-90fb-0f352903b659" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c9ebdf3f-0500-348c-9d46-083b266daf6c" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A2_7_3-b" lnHash="1009627957" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1009627957" unbViolId="bbacf298-c998-3b15-b56c-612f4b2e0b63" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c9b2887e-fa7a-3e8a-84db-87cbed01744b" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="COMMENT-14_b" lnHash="1009627957" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1009627957" unbViolId="cd566cdc-e6a2-3603-a84f-c8f8be58e620" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e091da7-fe77-3b27-bcda-1ee14cc4e7ed" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A2_7_3-b" lnHash="1009627957" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1009627957" unbViolId="312bc055-3e70-36c4-bf21-431654305207" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bb0afcf1-7a8d-389b-b452-d6589d25360f" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="COMMENT-14_b" lnHash="1009627957" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1009627957" unbViolId="df5f4b1e-56a4-3705-b28b-6da373d57c01" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b56d0252-6ad1-3a91-b6e7-aaab07f60cd8" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A2_7_3-b" lnHash="1009627957" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1009627957" unbViolId="3fa8c3dc-5da2-365b-aab6-8d0b3b43e082" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a9fd7710-a82e-32f3-8160-d049850b54c9" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="COMMENT-14_b" lnHash="1009627957" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1009627957" unbViolId="13b0fdd3-1d34-3d81-b0ed-50318f656570" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e7886326-1679-33b6-9cfb-d36ad8e242ee" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="'main' shall be declared as unsigned int or signed int" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="PORT-13" lnHash="1009627957" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="1009627957" unbViolId="cd067ad9-a767-3cef-b3a5-55901e8d8527" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d3534209-1c85-3631-9846-93eee58f2722" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="CERT_CPP-ERR50-d" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="ad0c31a3-1e35-3918-80fe-a670d290fd61" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="78928783-2ef5-3fe9-b50d-2f8838312b9f" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A15_3_3-a" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="7edfcc32-24e3-3335-b579-4c879c034ada" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6e8e31d2-bd5d-3fa6-aeb9-afa63cb0cac5" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="HICPP-15_3_2-b" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="e8d77c85-bda3-3cda-a041-4761e021b4a0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a0963230-d328-39a4-8f28-614210abc3ce" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="MISRA2008-15_3_2" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="fa426fbd-a6b0-3f99-9308-fadccf9930c1" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56b99973-9fdc-32bd-8f02-ba008d301d99" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A15_5_3-d" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="8088ab2d-b6ff-3199-96ad-efc8b31a22cb" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2465d0ae-8c51-3279-9477-52d64d997d56" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="EXCEPT-06" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="787c1a6d-d807-3cdc-b7b1-493505bdd9b7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5d6ed2c8-588c-3240-a031-27ee4a999a24" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="MISRA2008-15_5_3_d" lnHash="1009627957" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1009627957" unbViolId="f16fa395-50d1-3037-ba5f-570c67f85497" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4dec4676-3290-38ae-a4b6-e4f265b48938" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Return type is not placed in line before function 'main'" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="FORMAT-28" lnHash="1009627957" rule.header="In a function definition, the return type of the function should be written on a separate line directly above the function name" tool="c++test" lineHash="1009627957" unbViolId="dea10552-de13-3473-9820-5af522b71916" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7fc5181d-485b-3da5-a209-4f31c1a2626d" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Function 'main' has 20 function calls" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="METRICS-04" lnHash="1009627957" rule.header="Number of function calls within function" tool="c++test" lineHash="1009627957" unbViolId="53d1c252-e0e4-3c4c-b2aa-8c3e2fa80401" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15791c60-e0dc-3339-8dc3-105367637ac0" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Function 'main' has Cyclomatic Complexity value: 3" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="5" auth="lyao" locRef="1" rule="METRICS-29" lnHash="1009627957" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="1009627957" unbViolId="acb5507f-d83e-3be5-a9ef-cf2503f42ff8" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e99df16-c517-3c41-8079-3d6d3a717c7f" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Function 'main' has Essential Complexity value: 1" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="5" auth="lyao" locRef="1" rule="METRICS-33" lnHash="1009627957" rule.header="Report Essential Complexity" tool="c++test" lineHash="1009627957" unbViolId="981892b6-3286-37f2-8bce-9b90e1f2f2c0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f02f63d9-1ab1-3844-ad5d-cb7bdc7f2edd" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="MISRA2012-RULE-8_6" lnHash="1009627957" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="1009627957" unbViolId="d82fb9f9-f0ad-35c1-bfa2-85d3d1a85e6d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="36788486-a40e-331b-90ee-64318e62ab77" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-M3_2_4-a" lnHash="1009627957" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1009627957" unbViolId="0d4e7c28-a2d0-309d-94e8-bde18efd713b" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="0ef6fbcb-28f1-3a79-937b-3171a4d140d7" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="GLOBAL-ONEEXTERNDEF" lnHash="1009627957" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1009627957" unbViolId="c7575168-9621-3c89-bdba-77a7a6c4303a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="c89cbfea-e410-3bc6-869b-fe59f2e65526" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="MISRA2008-3_2_4" lnHash="1009627957" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="1009627957" unbViolId="d93008b9-dbad-371c-845a-84348a72daa9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="7d1310d9-2436-3f8d-bb7f-80e81481bf51" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="MISRAC2012-RULE_8_6-a" lnHash="1009627957" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1009627957" unbViolId="6e61164c-4be9-3ae9-871b-be0b7323d2d6" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="baca4dae-e7b7-3f94-b767-b6f105584127" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="GLOBAL-ONEFILEDECL" lnHash="1009627957" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1009627957" unbViolId="655f40f3-4ba5-336b-a0ac-0ab501289cc0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="f0a25778-0678-3a03-9b4f-2dd3d3d78852" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-M3_2_3-a" lnHash="1009627957" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1009627957" unbViolId="56d766b0-57d1-3bb7-9fba-94b4db1320b8" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e97b8162-97bf-3324-8466-e025e0e9c906" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="HICPP-7_4_3-a" lnHash="1009627957" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1009627957" unbViolId="2c0afbfc-b534-3b2d-9867-38fb16f57121" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="7879cb8e-621e-33da-bf8e-f74a784f3e51" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="MISRA2008-3_2_3" lnHash="1009627957" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1009627957" unbViolId="30d0892b-a88d-331b-bf4b-fa87004e3d16" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="37d83970-9c3f-3c1c-b370-64d5cb99ace1" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="AUTOSAR-A2_10_5-b" lnHash="1009627957" rule.header="Identifiers that define functions with external linkage shall be unique" tool="c++test" lineHash="1009627957" unbViolId="175b9fef-acc6-3567-8e6c-0ef08fda7466" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="9dfa8ba7-6271-3782-aa9c-1005cfe53c1b" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="MISRA2008-2_10_5_b" lnHash="1009627957" rule.header="The identifier name of a non-member object or function with static storage duration should not be reused" tool="c++test" lineHash="1009627957" unbViolId="5c8fb12a-2e24-35db-a62f-39ed121557cd" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="a56a4c6d-db29-364e-b2c0-620f0db7ecda" locEndPos="5" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="MISRA2008-3_9_2" lnHash="1009627957" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1009627957" unbViolId="f90a15fe-3c07-364d-b732-286f16a94c55" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="44244530-058a-3711-b6b3-37c4dff12be7" locEndPos="10" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="MISRA-013" lnHash="1009627957" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1009627957" unbViolId="94273be0-6e95-3d54-909f-81da77da717c" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e87267e-9090-31c8-b0e3-56ce7fccfc05" locEndPos="10" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="'argc' shall be declared as unsigned int or signed int" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="PORT-13" lnHash="1009627957" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="1009627957" unbViolId="b12a6624-dca0-3073-97d9-848c81c24b81" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a1991fd0-9579-38da-991d-ae1ec8403d16" locEndPos="14" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-22" lnHash="1009627957" rule.header="Hungarian notation for int types" tool="c++test" lineHash="1009627957" unbViolId="ad70eacd-e769-31bc-b67e-5ec55f1c2b83" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="acfd5156-e09f-347c-8d73-0d6c4ee2f3cb" locEndPos="14" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-30" lnHash="1009627957" rule.header="Hungarian notation for int types" tool="c++test" lineHash="1009627957" unbViolId="c243d6d9-f441-3a3c-a048-46b7b37902d4" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="63ba7ba9-620e-3ffc-b92b-1cccfec66dc0" locEndPos="14" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="NAMING-HN-43" lnHash="1009627957" rule.header="Hungarian notation for word types" tool="c++test" lineHash="1009627957" unbViolId="0c910890-67e9-3f04-9c3c-5a5f466c1f13" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b572be3a-799a-32bf-82d5-cd45e8ae3d95" locEndPos="14" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="FORMAT-47_a" lnHash="1009627957" rule.header="Place CV-qualifiers on the right hand side of the type they apply to" tool="c++test" lineHash="1009627957" unbViolId="24b198fb-1402-34d3-826d-53b1c8b53316" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1ef965ce-e169-3120-8357-868096ab835c" locEndPos="20" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The 'const' qualifier should be placed on the right hand side of the type" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="HICPP-7_1_4-a" lnHash="1009627957" rule.header="Place CV-qualifiers on the right hand side of the type they apply to" tool="c++test" lineHash="1009627957" unbViolId="d12601c1-d5f3-3a9a-98bf-6c5ab17a3e74" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="085f6b6e-e7fc-3e64-8eb0-c0c8e2d4ce1a" locEndPos="20" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="MISRA2008-3_9_2" lnHash="1009627957" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1009627957" unbViolId="7929cb6a-2749-3e81-a72d-6575b4ea3942" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d82088e2-45c7-3683-bdfb-26cf9d9c0bd5" locEndPos="26" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="MISRA-013" lnHash="1009627957" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1009627957" unbViolId="6445416a-de4b-30ed-9ee6-5352d9deecea" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f645f474-b3f0-3637-81a4-4404d5993321" locEndPos="26" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="JSF-062" lnHash="1009627957" rule.header="The dereference operator '*' and the address-of operator '&amp;' will be directly connected with the type-specifier" tool="c++test" lineHash="1009627957" unbViolId="1714f94f-0092-3212-9def-1192a405815e" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa60e365-d941-3c32-ae01-de3fb1d1e094" locEndPos="31" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="4" auth="lyao" locRef="1" rule="FORMAT-32" lnHash="1009627957" rule.header="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" tool="c++test" lineHash="1009627957" unbViolId="7455007e-cd25-39d3-a2a9-2cb78ff3db3b" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="12f962b2-482b-3abf-8254-0a26afbafe7f" locEndPos="31" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The parameter of pointer or array type is declared: argv" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="CODSTA-94" lnHash="1009627957" rule.header="Do not declare pointer or array type" tool="c++test" lineHash="1009627957" unbViolId="baaac97e-e00b-3a15-92cb-ab31a46d0fb8" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7a89d8c0-e9ef-3d18-be83-ac76a1913829" locEndPos="32" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="The parameter of pointer type is declared: argv" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="CODSTA-95" lnHash="1009627957" rule.header="Do not declare pointer type" tool="c++test" lineHash="1009627957" unbViolId="d6e2760f-8289-34e9-a6cf-23ba2f42561f" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="da5ad9df-37dd-3c2c-b6d0-b62d9c40def6" locEndPos="32" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Parameter 'argv' with array type was found in 'main' function declaration" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="JSF-097_c" lnHash="1009627957" rule.header="Arrays shall not be used in global functions" tool="c++test" lineHash="1009627957" unbViolId="cefad2f2-6a1e-35bd-9df2-2b4371c5894a" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="beb2414c-9d5f-392f-8a0d-301d0ca68527" locEndPos="32" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Parameter 'argv' with array type was found in 'main' function declaration" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="2" auth="lyao" locRef="1" rule="CODSTA-142" lnHash="1009627957" rule.header="Global functions shall not declare parameters with array type" tool="c++test" lineHash="1009627957" unbViolId="0aef25cf-11e8-39c7-99b6-4be4ee49092a" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="99917786-f94f-3482-ac49-381ecaee9d92" locEndPos="32" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="CERT_C-API00-a" lnHash="1009627957" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1009627957" unbViolId="e61bbf5b-b390-3948-af7d-bf1e8f00ef3b" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f261ad31-e8f7-3c1e-aa15-c3df20b9c52e" locEndPos="32" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="9" locFile="/src/../../../../../../../../src/main.cpp" locStartln="9" sev="3" auth="lyao" locRef="1" rule="CODSTA-86" lnHash="1009627957" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1009627957" unbViolId="4bf52201-ae30-3adb-841b-de176b8af204" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7a6c93c6-a98a-3f86-8397-7ec4af4a5e8a" locEndPos="32" locType="sr" hash="1535005727" locEndLn="9" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="10" locFile="/src/../../../../../../../../src/main.cpp" locStartln="10" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="1369673555" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1369673555" unbViolId="3a80b97e-fbdf-35dc-872a-eba4a2087669" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="425f63ae-205a-3845-ad19-b1031bf2ce16" locEndPos="1" locType="sr" hash="1535005727" locEndLn="10" goals="0,"/>
    <StdViol msg="Postpone definition of 'f'" ln="10" locFile="/src/../../../../../../../../src/main.cpp" locStartln="10" sev="3" auth="lyao" locRef="1" rule="OPT-20" lnHash="1369673555" rule.header="Postpone variable definitions as long as possible" tool="c++test" lineHash="1369673555" unbViolId="25c2f77e-306d-3d2b-8ef3-a921f7402d85" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c29f558b-871e-34e6-a6af-fca1597f2d7a" locEndPos="12" locType="sr" hash="1535005727" locEndLn="10" goals="0,"/>
    <StdViol msg="Postpone definition of 'f'" ln="10" locFile="/src/../../../../../../../../src/main.cpp" locStartln="10" sev="3" auth="lyao" locRef="1" rule="HICPP-6_4_1-b" lnHash="1369673555" rule.header="Postpone variable definitions as long as possible" tool="c++test" lineHash="1369673555" unbViolId="e93f38b0-b6aa-3db2-a60f-0b3e7f3990c4" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="84a18756-540d-394c-ac9e-d9708364306e" locEndPos="12" locType="sr" hash="1535005727" locEndLn="10" goals="0,"/>
    <StdViol msg="The 'f' variable should be commented" ln="10" locFile="/src/../../../../../../../../src/main.cpp" locStartln="10" sev="3" auth="lyao" locRef="1" rule="JSF-132_a" lnHash="1369673555" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="1369673555" unbViolId="84559e6e-48af-31be-9eb9-f2283a60fe89" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f94aff04-25fa-38ca-b873-afdd7e312685" locEndPos="12" locType="sr" hash="1535005727" locEndLn="10" goals="0,"/>
    <StdViol msg="The 'f' variable should be commented" ln="10" locFile="/src/../../../../../../../../src/main.cpp" locStartln="10" sev="3" auth="lyao" locRef="1" rule="COMMENT-05" lnHash="1369673555" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="1369673555" unbViolId="f5931795-3832-3faf-870e-90b14212708f" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="21d52eec-313e-3388-a3ed-036b6a5e2f54" locEndPos="12" locType="sr" hash="1535005727" locEndLn="10" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="12" locFile="/src/../../../../../../../../src/main.cpp" locStartln="12" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="1762418147" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1762418147" unbViolId="68df7a38-8915-3d97-b048-55384c00887c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2ea43097-2e1a-35e0-9863-d077a17a5ea7" locEndPos="1" locType="sr" hash="1535005727" locEndLn="12" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="14" locFile="/src/../../../../../../../../src/main.cpp" locStartln="14" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="609575752" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="609575752" unbViolId="b073388a-96a0-3a44-b215-4b92f0fe7df3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d86abd58-61f4-3aa3-afe3-4fe91134ff26" locEndPos="1" locType="sr" hash="1535005727" locEndLn="14" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="JSF-061" lnHash="821368387" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="821368387" unbViolId="c59e6f65-5bde-35b5-aee8-19d0c2996f6d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e3ebc891-ba88-32ac-b548-55a7830ead61" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="FORMAT-42" lnHash="821368387" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="821368387" unbViolId="ea1cd144-6fee-3666-88fe-37e7b2a85875" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a1708558-17e2-388c-b51c-037edddaf7e8" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="JSF-060_a" lnHash="821368387" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="821368387" unbViolId="927cb0aa-c4fb-347b-83ce-51ed6c1e6887" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0c2c20cf-bb15-3805-a067-03c70d370770" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="FORMAT-43" lnHash="821368387" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="821368387" unbViolId="742d017a-3bc2-3931-8df0-b13c0a6fdfcf" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92dafcc6-9bf8-3939-85e1-d933c0d15b9b" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="JSF-060_b" lnHash="821368387" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="821368387" unbViolId="8835d356-bcd8-3c77-a72f-98473889289b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="49a65415-e9cd-3ab0-94f9-c6a0355bae49" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="821368387" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="821368387" unbViolId="bfa12af2-8e89-3f45-b913-097291d84d10" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e1c29b6b-2217-36b8-be19-7c1f14fa289e" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="FORMAT-02" lnHash="821368387" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="821368387" unbViolId="4f11e032-5f2d-3400-83fc-8701ce3c57d9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ff1b7547-c59f-3dd8-a159-4b2f0838d52b" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="FORMAT-34" lnHash="821368387" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="821368387" unbViolId="43661132-3222-3e08-ab77-6399ecdbfeae" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3b8763e3-ee3f-3743-acba-3eca98e55487" locEndPos="1" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="The 'if' statement doesn't have an 'else' clause" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="CODSTA-23" lnHash="821368387" rule.header="All 'if' statements should have an 'else' clause" tool="c++test" lineHash="821368387" unbViolId="2c64201b-ca5f-3329-8fbf-eb811c3284b1" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="94f74887-44d5-3a33-9aa1-d5fa348208e6" locEndPos="3" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="821368387" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="821368387" unbViolId="aaa05947-b367-3102-879e-039e9054a14a" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="11386b34-7752-3381-a8c8-01bdd5872f32" locEndPos="7" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="JSF-151" lnHash="821368387" rule.header="Numeric values in code will not be used; symbolic values will be used instead" tool="c++test" lineHash="821368387" unbViolId="ff38b98e-55f1-35b3-84a1-7945672a9816" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7617783-aaf0-34ae-9180-0d4e0c4d811f" locEndPos="14" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="CODSTA-26" lnHash="821368387" rule.header="Avoid magic numbers" tool="c++test" lineHash="821368387" unbViolId="49588d97-1ea4-3db3-86ad-97066c20b1ed" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ba0a2846-cf94-3a69-862b-540bd37d3e9f" locEndPos="14" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A5_1_1-a" lnHash="821368387" rule.header="Avoid magic numbers" tool="c++test" lineHash="821368387" unbViolId="0cdd02db-5fce-344d-9b96-7809a653d921" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2f3b69dd-8b16-31b9-a2cc-31f42a034b0c" locEndPos="14" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="15" locFile="/src/../../../../../../../../src/main.cpp" locStartln="15" sev="3" auth="lyao" locRef="1" rule="HICPP-5_1_1-a" lnHash="821368387" rule.header="Avoid magic numbers" tool="c++test" lineHash="821368387" unbViolId="00050c78-c667-31c4-ad73-ac63f9cd82e8" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d63d88ab-6012-39f6-b449-2af8fe18dd25" locEndPos="14" locType="sr" hash="1535005727" locEndLn="15" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="16" locFile="/src/../../../../../../../../src/main.cpp" locStartln="16" sev="3" auth="lyao" locRef="1" rule="FORMAT-37" lnHash="-1458985563" rule.header="First line in control statement body should be indented more than control statement keyword" tool="c++test" lineHash="-1458985563" unbViolId="102d68e9-0c34-32a5-b753-995ff7ebc801" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a5db649d-d3ca-33d5-b422-09b602b8b04b" locEndPos="5" locType="sr" hash="1535005727" locEndLn="16" goals="0,"/>
    <DupViol msg="Duplicated code: 'return 1;'" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="3" auth="lyao" locRef="1" rule="CDD-DUPC" lnHash="-1256396006" rule.header="Avoid code duplication" tool="c++test" lineHash="-1256396006" unbViolId="30370b20-d70b-3d05-be4d-f7a1a7a30b2f" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="65513551-d9b1-3044-a2f8-6d8f0611b1d4" locType="sr" locEndPos="13" urgent="true" hash="1535005727" locEndLn="17" goals="1,">
      <ElDescList>
        <ElDesc lineHash="-1256396006" ln="17" srcRngStartPos="4" srcRngEndPos="13" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="17" srcRngEndLn="17" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 17] Duplicated code in file 'main.cpp'" rngLn="17"/>
        <ElDesc lineHash="-293114117" ln="32" srcRngStartPos="2" srcRngEndPos="11" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="32" srcRngEndLn="32" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 32] Duplicated code in file 'main.cpp'" rngLn="32"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="Provide only one exit point in 'main' function" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="2" auth="lyao" locRef="1" rule="MISRA2008-6_6_5" lnHash="-1256396006" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396006" unbViolId="707fe745-06ea-36c9-8af9-7c6f6cbc7f46" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="03fc8e18-b3d2-3583-bd31-9f7baa8853f4" locEndPos="5" locType="sr" hash="1535005727" locEndLn="17" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="3" auth="lyao" locRef="1" rule="MISRA2004-14_7" lnHash="-1256396006" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396006" unbViolId="0ab8f38b-eac9-3545-a197-8741e4860731" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e5f39bb0-ec03-3691-8241-46524b56476c" locEndPos="5" locType="sr" hash="1535005727" locEndLn="17" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="4" auth="lyao" locRef="1" rule="MISRAC2012-RULE_15_5-a" lnHash="-1256396006" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-1256396006" unbViolId="21b34244-cc6a-3b58-ad6b-149999d9a8ac" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="594a2489-21ad-39e4-8f89-ae0c138d8833" locEndPos="5" locType="sr" hash="1535005727" locEndLn="17" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="4" auth="lyao" locRef="1" rule="MISRA2012-RULE-15_5" lnHash="-1256396006" rule.header="A function should have a single point of exit at the end" tool="c++test" lineHash="-1256396006" unbViolId="181e6cb1-3bf4-3276-87a5-376355c837a4" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="01a2df0b-3c25-37c7-a8df-c384fdcb26f2" locEndPos="5" locType="sr" hash="1535005727" locEndLn="17" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="3" auth="lyao" locRef="1" rule="JSF-113" lnHash="-1256396006" rule.header="Functions will have a single exit point" tool="c++test" lineHash="-1256396006" unbViolId="03764f89-8e65-355b-954d-28c9aa2fa3b8" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7fadedd9-f780-3ba8-a211-946efc5d34b1" locEndPos="5" locType="sr" hash="1535005727" locEndLn="17" goals="0,"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="17" locFile="/src/../../../../../../../../src/main.cpp" locStartln="17" sev="3" auth="lyao" locRef="1" rule="FORMAT-25_b" lnHash="-1256396006" rule.header="Parenthesis shall be used with the &quot;return&quot; statement" tool="c++test" lineHash="-1256396006" unbViolId="f600e7e5-f740-36eb-92f4-066db9ad8330" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="57236b2d-58a9-3e5d-a213-142fd3edd583" locEndPos="5" locType="sr" hash="1535005727" locEndLn="17" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="18" locFile="/src/../../../../../../../../src/main.cpp" locStartln="18" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="31869" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="31869" unbViolId="fe441c9a-0fe2-3b32-b6b8-3908c3d8b28f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a784a71b-36bd-3b9b-b9b5-5c624a30396b" locEndPos="1" locType="sr" hash="1535005727" locEndLn="18" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="-400764885" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-400764885" unbViolId="6ecda081-6d09-3f5f-887b-00d40fa26389" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="468ba135-e374-3e1a-953d-a986c43f9e9f" locEndPos="1" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argv" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="-400764885" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-400764885" unbViolId="64f3be6a-3b73-370e-bd6f-5bf54f2f81e8" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7fc4e283-eb30-3f4a-90d3-31f29d94b0e5" locEndPos="3" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Values &quot;argv&quot; passed to library function &quot;atoll&quot; without being checked" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="CERT_C-MEM07-a" lnHash="-400764885" rule.header="The validity of values passed to library functions shall be checked" tool="c++test" lineHash="-400764885" unbViolId="9a33d898-f109-3ecc-837d-79b435270b64" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9e661e41-40a4-3bbe-ae02-2581f5ff0bf0" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Values &quot;argv&quot; passed to library function &quot;atoll&quot; without being checked" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="CERT_C-MEM04-a" lnHash="-400764885" rule.header="The validity of values passed to library functions shall be checked" tool="c++test" lineHash="-400764885" unbViolId="843c8e5d-c6d2-36df-9b18-0473b02df9df" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b0fc73ae-c1a4-3b0f-9d51-54fd6f7a2ce4" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Values &quot;argv&quot; passed to library function &quot;atoll&quot; without being checked" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="3" auth="lyao" locRef="1" rule="MISRA2004-20_3" lnHash="-400764885" rule.header="The validity of values passed to library functions shall be checked" tool="c++test" lineHash="-400764885" unbViolId="d4877848-2985-3384-9533-261e8eda06bb" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fbf111af-3867-3270-be84-80a4f0711edb" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argv" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="-400764885" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-400764885" unbViolId="5bc230df-28a5-3f95-a346-b002665998b7" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="05f913e1-0557-3f6e-bbc5-e595095b9f4b" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="MISRAC2012-RULE_21_7-a" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="cb5aec84-4cd0-3215-8aba-34376786d7b9" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="367be74c-e2f3-3729-8fc2-395e95960e84" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="3" auth="lyao" locRef="1" rule="CERT_CPP-ERR62-a" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="2677e0c8-1bfb-3e3e-902a-f6ec9724a512" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a289148-c929-3c43-b5c1-d6d805893553" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="MISRA2008-18_0_2" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library &lt;cstdlib> shall not be used" tool="c++test" lineHash="-400764885" unbViolId="21264a38-697a-35ed-bbb9-4600d228384a" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8ca9590c-9c9a-3168-982c-14b409455b49" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="3" auth="lyao" locRef="1" rule="CERT_C-ERR34-a" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="fc480751-3075-349c-a8dc-813cf8147521" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0900c900-aa69-3384-b520-d18e2855adfa" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="3" auth="lyao" locRef="1" rule="MISRA2004-20_10" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="84615534-c525-3b0d-8fd4-ea76bfb966d5" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8a30ddd9-a197-3a9f-958d-77032618a452" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="3" auth="lyao" locRef="1" rule="CERT_C-MSC24-a" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="cb32c373-8e76-341b-b628-566ee37ef2e7" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d2628950-be2a-31ff-8b72-cd1003d5558b" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="CERT_C-ERR07-a" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="b5a42cd4-4874-392e-88fc-e906752da53b" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="053dc962-c402-3f49-888c-68ac020a6ebd" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A18_0_2-b" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="da6e3363-fbc6-38db-8d48-cc7adc6eea1b" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8defd3e3-a824-3186-985d-9cd768defc4c" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A18_0_2-a" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-400764885" unbViolId="1157e3dd-913a-315e-b88c-479f4b0d91f7" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f0e9f4a2-96d5-3125-9571-0fea2a51da4a" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="MISRA2012-RULE-21_7" lnHash="-400764885" rule.header="The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" tool="c++test" lineHash="-400764885" unbViolId="06b2ced1-266a-365f-b356-2e3d4ee69024" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b86bf1c6-8fb1-335d-98bd-131b0560143a" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="JSF-023" lnHash="-400764885" rule.header="The library functions atof, atoi and atol from library &lt;stdlib.h> shall not be used" tool="c++test" lineHash="-400764885" unbViolId="792d61fa-3aa3-36a0-b0a9-f062ec865487" locStartPos="16" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ddca3af9-8e35-3b2a-9ab8-c3c30be38002" locEndPos="17" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argv" ln="20" locFile="/src/../../../../../../../../src/main.cpp" locStartln="20" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="-400764885" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-400764885" unbViolId="4625febe-9396-3002-8a78-d9373e26bdbf" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2a80e6ec-9175-3348-ae40-91cbeedd7095" locEndPos="23" locType="sr" hash="1535005727" locEndLn="20" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="-1868196569" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-1868196569" unbViolId="2ed1c547-90e4-3006-abc5-db8cbcf7cfc0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fc502547-2b82-3f23-aa2e-6a201a9a2a74" locEndPos="1" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argv" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="-1868196569" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-1868196569" unbViolId="158d0594-5f7a-3bc4-b254-81e80b56dcb5" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aa75665a-d2c3-3af2-a42b-3741d917c5f8" locEndPos="3" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Values &quot;argv&quot; passed to library function &quot;atoll&quot; without being checked" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="CERT_C-MEM07-a" lnHash="-1868196569" rule.header="The validity of values passed to library functions shall be checked" tool="c++test" lineHash="-1868196569" unbViolId="3982921f-c730-375f-b8a8-e0ff07753269" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8fb258fb-ebf4-34c3-a3e8-ef0f44049eb3" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Values &quot;argv&quot; passed to library function &quot;atoll&quot; without being checked" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="CERT_C-MEM04-a" lnHash="-1868196569" rule.header="The validity of values passed to library functions shall be checked" tool="c++test" lineHash="-1868196569" unbViolId="71315ac1-0fa9-31d6-9224-be78ca6334e3" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b281e886-74a7-3d9c-9e5d-0d35f8f43390" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Values &quot;argv&quot; passed to library function &quot;atoll&quot; without being checked" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="MISRA2004-20_3" lnHash="-1868196569" rule.header="The validity of values passed to library functions shall be checked" tool="c++test" lineHash="-1868196569" unbViolId="5049b64f-e8a5-3e6e-b614-026b83307c47" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d7cb1a4c-0aba-3005-b549-90859ebf8e39" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argv" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="-1868196569" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-1868196569" unbViolId="88d45908-6aad-3b1e-81b3-8f01d566778f" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d7f0aa4e-3757-3d85-a5d9-fab4e65e1fbc" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="MISRAC2012-RULE_21_7-a" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="d832e139-ba69-35b1-bf81-95757dbf6e79" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bf118d00-eea2-3d03-94c6-20ae9c56bfeb" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="CERT_CPP-ERR62-a" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="984b41c1-8184-3f6f-ab2c-6753bca05c46" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c1d9bf25-797c-39ed-9017-b98ec1ba9df3" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="MISRA2008-18_0_2" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library &lt;cstdlib> shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="7a6334ce-f891-3b3b-836e-bc1c71ed77a6" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a628d425-c13b-3693-9c1e-6c3041b00dce" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="CERT_C-ERR34-a" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="65eb897f-e2dd-3ef3-b37b-7c2b0051ee7d" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5f8ef48c-1cf4-3f13-b808-c54a0c9dbba2" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="MISRA2004-20_10" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="0c4b2643-bd2d-3f5a-9217-3e8e70b6dcb1" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="65727d8f-715c-3ddd-99cb-146e95d7f2d1" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="CERT_C-MSC24-a" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="151378de-1e35-344b-9e9d-968ddcb27069" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a3094af-6dac-34d1-a44a-d2fb36e29a61" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="CERT_C-ERR07-a" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="4767e2ba-e870-3c77-b4a2-ea695bc5a717" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0825bfbe-3595-34d6-8eb6-24fc25138c16" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A18_0_2-b" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="71de432f-1a42-38e8-ad43-a4b57121fac5" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d39c3e91-8d7b-3e1d-a114-80fd86edfa52" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A18_0_2-a" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library stdlib.h shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="19d4a26f-7ff6-37a5-b0a1-bc9f01238a8e" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1c94c5b6-3bf4-372f-9f8e-3a05de7d6ba5" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="MISRA2012-RULE-21_7" lnHash="-1868196569" rule.header="The atof, atoi, atol and atoll functions of &lt;stdlib.h> shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="6f7c2e77-4bd3-3fd4-af64-e9e818d040f4" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bfdc2d64-30b4-3ad5-b5a4-2f2108006208" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Usage of 'atoll' function is not allowed" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="JSF-023" lnHash="-1868196569" rule.header="The library functions atof, atoi and atol from library &lt;stdlib.h> shall not be used" tool="c++test" lineHash="-1868196569" unbViolId="0bac48d9-57ea-3498-9d64-5254a4da7b15" locStartPos="18" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f364bed2-66ab-3129-bff9-13a3826a4d5b" locEndPos="19" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argv" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="SECURITY-35" lnHash="-1868196569" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-1868196569" unbViolId="3bc9117e-8482-3021-8b4f-95291b7b3b4d" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2f883327-cfe8-36bc-bc4b-f9df6d2a084e" locEndPos="25" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="JSF-151" lnHash="-1868196569" rule.header="Numeric values in code will not be used; symbolic values will be used instead" tool="c++test" lineHash="-1868196569" unbViolId="33b20705-f76f-3b57-b77b-a583fed449cd" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0340f3e1-cb38-3b2c-a1a1-4b2ec12e5dc8" locEndPos="30" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="CODSTA-26" lnHash="-1868196569" rule.header="Avoid magic numbers" tool="c++test" lineHash="-1868196569" unbViolId="e53455ac-e9c7-320d-8f07-680ad36003ca" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d706daff-2654-30b0-9d41-0d8b77037330" locEndPos="30" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A5_1_1-a" lnHash="-1868196569" rule.header="Avoid magic numbers" tool="c++test" lineHash="-1868196569" unbViolId="9fd88f6f-dedb-3bce-a0bf-007f672ea069" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c81938a1-8ba8-385b-b7b8-c6720d9e06e8" locEndPos="30" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="21" locFile="/src/../../../../../../../../src/main.cpp" locStartln="21" sev="3" auth="lyao" locRef="1" rule="HICPP-5_1_1-a" lnHash="-1868196569" rule.header="Avoid magic numbers" tool="c++test" lineHash="-1868196569" unbViolId="8f654895-c461-396c-9502-205999a4e023" locStartPos="29" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f7b2ff3-a566-3725-b747-bf66a7223a84" locEndPos="30" locType="sr" hash="1535005727" locEndLn="21" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="23" locFile="/src/../../../../../../../../src/main.cpp" locStartln="23" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="1124672111" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1124672111" unbViolId="36ed8610-a9dd-3128-a5ba-14cc1027d2e3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8a6f1ccc-99cb-372e-97d2-8e25a021201a" locEndPos="1" locType="sr" hash="1535005727" locEndLn="23" goals="0,"/>
    <StdViol msg="The definition of the 'd' variable should contain a braced initializer" ln="23" locFile="/src/../../../../../../../../src/main.cpp" locStartln="23" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A8_5_2-a" lnHash="1124672111" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="1124672111" unbViolId="00273607-532d-37b8-b9c7-d555db89f914" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4183d125-061f-3372-b1fa-4b7d5116d0b9" locEndPos="12" locType="sr" hash="1535005727" locEndLn="23" goals="0,"/>
    <StdViol msg="The definition of the 'd' variable should contain a braced initializer" ln="23" locFile="/src/../../../../../../../../src/main.cpp" locStartln="23" sev="3" auth="lyao" locRef="1" rule="CODSTA-MCPP-38" lnHash="1124672111" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="1124672111" unbViolId="da015e88-3439-37eb-92a1-7b64f6241648" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2fd7ec05-9de9-3b8e-9a62-907558ff8d94" locEndPos="12" locType="sr" hash="1535005727" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'd' variable should be commented" ln="23" locFile="/src/../../../../../../../../src/main.cpp" locStartln="23" sev="3" auth="lyao" locRef="1" rule="JSF-132_a" lnHash="1124672111" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="1124672111" unbViolId="05e6027e-7243-34f8-a1ba-6504f8bd6e0f" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7dbf5748-3678-3e36-8624-966ca330b2f1" locEndPos="12" locType="sr" hash="1535005727" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'd' variable should be commented" ln="23" locFile="/src/../../../../../../../../src/main.cpp" locStartln="23" sev="3" auth="lyao" locRef="1" rule="COMMENT-05" lnHash="1124672111" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="1124672111" unbViolId="ad89d2ef-2b88-3eea-b271-bd0ae399b22e" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="34010f81-52e1-3427-bb2f-4722ccf84269" locEndPos="12" locType="sr" hash="1535005727" locEndLn="23" goals="0,"/>
    <StdViol msg="Variable 'd' should be declared using 'auto' specifier" ln="23" locFile="/src/../../../../../../../../src/main.cpp" locStartln="23" sev="3" auth="lyao" locRef="1" rule="HICPP-7_1_8-a" lnHash="1124672111" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="1124672111" unbViolId="6e17825d-d580-3cd6-af4b-16a3d2e5836a" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ca2e9da8-353c-35a5-8d12-f8c96cb6332a" locEndPos="12" locType="sr" hash="1535005727" locEndLn="23" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="JSF-061" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-637878442" unbViolId="657a9b9a-354b-33d5-bc64-8f05de76af77" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="43a457c1-cfaf-3055-9d7b-d39ecb428645" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="FORMAT-42" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-637878442" unbViolId="dc174d2a-bd53-3027-ac38-56a531f24221" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7cd7ccc-905b-3444-a23e-da39ac8f0e74" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="JSF-060_a" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-637878442" unbViolId="a4165c7d-dcf7-3199-90f2-80c852132218" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4abe20dc-6f9f-3d2c-812f-6eacde6c04c8" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="FORMAT-43" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-637878442" unbViolId="8fe37920-7e58-3757-8305-d99b44605c62" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4e38d5df-7b75-38aa-bedd-fe659087600e" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="JSF-060_b" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-637878442" unbViolId="4ac63d68-96a3-30b3-8d68-59138aacff44" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f6083280-14ab-3a47-ab4d-799b727c98c1" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="-637878442" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-637878442" unbViolId="9bd5aaa9-7df7-3bad-8611-f4eaeb9c3613" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eacc2a8b-bb8e-369e-88e2-d547f2f37823" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="FORMAT-02" lnHash="-637878442" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-637878442" unbViolId="85bede8b-1886-3bf2-933f-688e05477f3a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="866398e9-7969-30f9-8621-b235df099859" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="3" auth="lyao" locRef="1" rule="FORMAT-34" lnHash="-637878442" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-637878442" unbViolId="546a2ab2-8e03-3780-ae36-02de51529e2b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c97901ae-30d9-3259-be14-a51f421dfc31" locEndPos="1" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'main'" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="2" auth="lyao" locRef="1" rule="JSF-208" lnHash="-637878442" rule.header="C++ exceptions shall not be used" tool="c++test" lineHash="-637878442" unbViolId="7eac40eb-52e8-3bc1-afbe-6389d5936eb8" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aeb96270-701f-347e-8cd1-e2d7c81d7b8f" locEndPos="3" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'main'" ln="24" locFile="/src/../../../../../../../../src/main.cpp" locStartln="24" sev="2" auth="lyao" locRef="1" rule="EXCEPT-05" lnHash="-637878442" rule.header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" tool="c++test" lineHash="-637878442" unbViolId="0a61090a-540b-3783-bf1f-f1763044f682" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="14087e2c-4056-3396-b80c-4b9be7c4d04f" locEndPos="3" locType="sr" hash="1535005727" locEndLn="24" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="FORMAT-37" lnHash="1504718800" rule.header="First line in control statement body should be indented more than control statement keyword" tool="c++test" lineHash="1504718800" unbViolId="f79e7c63-9d28-3772-8c17-7fb8ab35f7f4" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9d1cf918-fa66-3418-860a-05a9fdf074a9" locEndPos="5" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The definition of the 'r' variable should contain a braced initializer" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A8_5_2-a" lnHash="1504718800" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="1504718800" unbViolId="23f5a793-2bf1-320d-863a-a3cab0493809" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1a25bbdc-ad69-3de1-a5bf-23965ed50fad" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The definition of the 'r' variable should contain a braced initializer" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="CODSTA-MCPP-38" lnHash="1504718800" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="1504718800" unbViolId="4a87a50d-fafb-3ae7-86b4-9868ab0a87a1" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f9061f79-1084-3be4-99b3-92a7d519fd16" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The 'r' variable should be declared with the 'auto' type specifier" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="2" auth="lyao" locRef="1" rule="CODSTA-MCPP-08_a" lnHash="1504718800" rule.header="Prefer 'auto' to explicit type names in variable declarations" tool="c++test" lineHash="1504718800" unbViolId="54e5f389-9376-3c0d-ae38-796459e98ef6" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dabc2ed5-ab15-368f-a09d-23310ae06f11" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Declare local variable 'r' as const" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="CERT_C-DCL00-a" lnHash="1504718800" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1504718800" unbViolId="05bc23bc-0732-3943-ac82-9158aaae578e" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="60d83fa1-c41f-3428-a4bb-4afd4f79400a" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Declare local variable 'r' as const" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A7_1_1-a" lnHash="1504718800" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1504718800" unbViolId="f6247b01-2972-3c38-ac3b-0a285d6a33fc" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5f696e0d-0ad4-387d-9fb8-c3b2454bcb95" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Declare local variable 'r' as const" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="2" auth="lyao" locRef="1" rule="MISRA2008-7_1_1" lnHash="1504718800" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1504718800" unbViolId="4644d30d-fa26-3700-90e6-ad9e822476e6" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="55cea3cc-1f98-3e7f-b2d9-8834677a6390" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Declare local variable 'r' as const" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="CODSTA-CPP-53" lnHash="1504718800" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1504718800" unbViolId="213d4bd0-9fec-3266-bd03-fb5dedc68aa9" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f9638cd9-ee0c-3450-b0a6-0cbf355ce352" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Declare local variable 'r' as const" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="HICPP-7_1_2-a" lnHash="1504718800" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1504718800" unbViolId="ae44bee3-7460-31eb-88fd-9ab77a38464a" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cadcea47-65ff-30ca-bc40-5d988bb06634" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The 'r' variable should be commented" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="JSF-132_a" lnHash="1504718800" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="1504718800" unbViolId="4f67abed-8b38-353c-85d4-03b61bc54dc8" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c6022a73-9d2d-3bf8-8b3e-9da3af20bfc1" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The 'r' variable should be commented" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="COMMENT-05" lnHash="1504718800" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="1504718800" unbViolId="8faace6f-80cb-3078-84e0-83f5fe00814c" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="51944f77-d342-357e-bf2a-c876f96fa573" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Variable 'r' should be declared using 'auto' specifier" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="3" auth="lyao" locRef="1" rule="HICPP-7_1_8-a" lnHash="1504718800" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="1504718800" unbViolId="647222bc-41ad-304a-a330-e0641a7deb3b" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="50aece2a-4215-38c0-8fb2-14589354b3e7" locEndPos="20" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The error from the 'divide' library function should be indicated by a return value instead of an exception" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="4" auth="lyao" locRef="1" rule="PORT-30" lnHash="1504718800" rule.header="Do not throw an exception across execution boundaries" tool="c++test" lineHash="1504718800" unbViolId="0a1ff52a-9a1e-3398-a14d-d319489bea05" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0cbbf2ea-3eae-3e65-b2bf-e18f7ab50f1d" locEndPos="24" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The error from the 'divide' library function should be indicated by a return value instead of an exception" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A15_1_5-a" lnHash="1504718800" rule.header="Do not throw an exception across execution boundaries" tool="c++test" lineHash="1504718800" unbViolId="0e3b3ab8-1415-3a11-b5f6-1de66e496a20" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1dc015f4-b4e8-39b7-9e0a-0491ece6f51c" locEndPos="24" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="The error from the 'divide' library function should be indicated by a return value instead of an exception" ln="25" locFile="/src/../../../../../../../../src/main.cpp" locStartln="25" sev="1" auth="lyao" locRef="1" rule="CERT_CPP-ERR59-a" lnHash="1504718800" rule.header="Do not throw an exception across execution boundaries" tool="c++test" lineHash="1504718800" unbViolId="4c1e74db-fb37-3ad2-934a-d2abcac166d6" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2c9c58d9-2e37-353e-8721-aeb4597b35a1" locEndPos="24" locType="sr" hash="1535005727" locEndLn="25" goals="0,"/>
    <StdViol msg="Line has over 79 characters" ln="27" locFile="/src/../../../../../../../../src/main.cpp" locStartln="27" sev="3" auth="lyao" locRef="1" rule="FORMAT-04" lnHash="395922831" rule.header="Physical lines should be less than eighty characters" tool="c++test" lineHash="395922831" unbViolId="7e8cb540-97e1-3196-97c3-c2c2317634d6" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="80152367-ea67-3848-b723-2fa61a933c40" locEndPos="1" locType="sr" hash="1535005727" locEndLn="27" goals="0,"/>
    <DupViol msg="Duplicated string: '&quot; = &quot;'" ln="27" locFile="/src/../../../../../../../../src/main.cpp" locStartln="27" sev="3" auth="lyao" locRef="1" rule="CDD-DUPS" lnHash="395922831" rule.header="Avoid string literal duplication" tool="c++test" lineHash="395922831" unbViolId="a92e2c37-8e04-3a59-a65d-7b88c7a0edeb" locStartPos="70" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="cdc66878-ae95-3af6-9e25-7bd1dd61b953" locType="sr" locEndPos="75" urgent="true" hash="1535005727" locEndLn="27" goals="1,">
      <ElDescList>
        <ElDesc lineHash="395922831" ln="27" srcRngStartPos="70" srcRngEndPos="75" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="27" srcRngEndLn="27" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 27] Duplicated string in file 'main.cpp'" rngLn="27"/>
        <ElDesc lineHash="447331069" ln="28" srcRngStartPos="70" srcRngEndPos="75" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="28" srcRngEndLn="28" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 28] Duplicated string in file 'main.cpp'" rngLn="28"/>
      </ElDescList>
    </DupViol>
    <DupViol msg="Duplicated string: '&quot;\n&quot;'" ln="27" locFile="/src/../../../../../../../../src/main.cpp" locStartln="27" sev="3" auth="lyao" locRef="1" rule="CDD-DUPS" lnHash="395922831" rule.header="Avoid string literal duplication" tool="c++test" lineHash="395922831" unbViolId="036135fd-aa85-3441-b2fb-a02cab26cdd9" locStartPos="93" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="d32c2d7a-ae1a-363f-bef9-3e76255cdc4c" locType="sr" locEndPos="97" urgent="true" hash="1535005727" locEndLn="27" goals="1,">
      <ElDescList>
        <ElDesc lineHash="395922831" ln="27" srcRngStartPos="93" srcRngEndPos="97" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="27" srcRngEndLn="27" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 27] Duplicated string in file 'main.cpp'" rngLn="27"/>
        <ElDesc lineHash="447331069" ln="28" srcRngStartPos="94" srcRngEndPos="98" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="28" srcRngEndLn="28" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="[Line 28] Duplicated string in file 'main.cpp'" rngLn="28"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="Line has over 79 characters" ln="28" locFile="/src/../../../../../../../../src/main.cpp" locStartln="28" sev="3" auth="lyao" locRef="1" rule="FORMAT-04" lnHash="447331069" rule.header="Physical lines should be less than eighty characters" tool="c++test" lineHash="447331069" unbViolId="46160e49-08c4-39fc-b990-786796a8fd20" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0fe0a432-207d-3d2f-a406-2afe7c46fc91" locEndPos="1" locType="sr" hash="1535005727" locEndLn="28" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="JSF-061" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="263904408" unbViolId="6b0d0633-19c3-3d2d-9a58-003ddb0049e5" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eb69b442-85eb-39e0-9011-12791106e4bd" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-42" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="263904408" unbViolId="c77a570a-309d-37ec-8f2f-67d1bf59552a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bd1810d5-72b6-3694-9fe6-817b7a483e79" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="JSF-060_a" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="263904408" unbViolId="b4b79ff5-5f0b-3c4f-9231-1e9cdf3cccd3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c84457aa-4b40-32dd-87bb-2ae5ea3b5a59" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-43" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="263904408" unbViolId="860fff41-2c1e-39b6-b69f-1986117744a1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b89c60b0-1ff4-36e8-87f8-82bd1b3efc88" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="JSF-060_b" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="263904408" unbViolId="1b018389-726e-3d3a-b4ae-32fa9ca20068" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="85976165-b734-33b1-b42f-48cd5cae3d19" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="263904408" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="263904408" unbViolId="ebcc7577-baad-34c8-a8df-5c9dd8d09c1c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f1f121f-57b1-3603-9803-ff1be3942c5c" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-02" lnHash="263904408" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="263904408" unbViolId="3d410e6f-9ba8-3995-ab8c-f6bed36ace61" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="30a6ec16-e9f7-35a6-9ec4-89e6e8a27fe2" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-34" lnHash="263904408" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="263904408" unbViolId="fc6c3dec-2b1f-3265-906d-b720d41f79a0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed9fbdbd-3dd8-3531-a3ee-666f7fc57615" locEndPos="1" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="JSF-061" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="263904408" unbViolId="14b64b1b-142d-379f-87fe-69375ec80bc6" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="12e987ff-fa96-35fa-a27c-be8f09318131" locEndPos="3" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-42" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="263904408" unbViolId="ba80b988-0508-3109-b0b1-b107ce09909e" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aef3ade5-9524-3f12-990d-bb5fff704ff8" locEndPos="3" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="JSF-060_a" lnHash="263904408" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="263904408" unbViolId="40eefc30-b1ee-34b0-9881-974d292184c1" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f19b9452-366b-36e5-bf30-f43aa9c87c7e" locEndPos="3" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="FORMAT-03" lnHash="263904408" rule.header="Place a closing brace '}' on its own line" tool="c++test" lineHash="263904408" unbViolId="154389c4-b6fe-3fa1-abb8-16f6812a9bc9" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7ab140a0-c70c-36a3-81ce-dd06d00938ce" locEndPos="3" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Exception of type DivisionByZero  is not caught by reference" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="1" auth="lyao" locRef="1" rule="EXCEPT-02" lnHash="263904408" rule.header="Throw by value, catch by reference" tool="c++test" lineHash="263904408" unbViolId="c9ba069e-74f9-3468-8472-89707ece5bad" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="35b7936e-4970-39bd-bfc0-a58ca0d4a2b7" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Exception of type DivisionByZero  is not caught by reference" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="CERT_CPP-ERR61-b" lnHash="263904408" rule.header="Throw by value, catch by reference" tool="c++test" lineHash="263904408" unbViolId="1b150f1a-5317-390c-9941-fae4ad585c02" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fe93a257-e4d1-33fe-8c58-637c5f96334e" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'main'" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="2" auth="lyao" locRef="1" rule="JSF-208" lnHash="263904408" rule.header="C++ exceptions shall not be used" tool="c++test" lineHash="263904408" unbViolId="cd7a7a87-17f4-39f7-8850-4235f4fa7e09" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4f7e16ba-dd4a-3dbb-af4d-c570391eff24" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'main'" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="2" auth="lyao" locRef="1" rule="EXCEPT-05" lnHash="263904408" rule.header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" tool="c++test" lineHash="263904408" unbViolId="a90c982c-50ee-3973-9625-f0d6bf11cc41" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="283fa5e1-51bf-3af6-95b6-bb1120e60f51" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Exception of type 'DivisionByZero' is not caught by reference" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="2" auth="lyao" locRef="1" rule="AUTOSAR-A15_3_5-a" lnHash="263904408" rule.header="A class type exception shall always be caught by reference" tool="c++test" lineHash="263904408" unbViolId="b171a5c2-6967-3cba-9a3c-88adcdcab9e7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b91f18fe-b2d4-30f2-b613-c28de45341bb" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Exception of type 'DivisionByZero' is not caught by reference" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="2" auth="lyao" locRef="1" rule="MISRA2008-15_3_5" lnHash="263904408" rule.header="A class type exception shall always be caught by reference" tool="c++test" lineHash="263904408" unbViolId="6682c286-77c2-3715-847c-b94c669572a5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c9590a23-7b97-365c-9b87-1d71a9d68d4d" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Exception of type 'DivisionByZero' is not caught by reference" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="CERT_CPP-ERR61-a" lnHash="263904408" rule.header="A class type exception shall always be caught by reference" tool="c++test" lineHash="263904408" unbViolId="05f9f71e-22a1-3575-b6e4-1f4977f5cd26" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="79f81ddd-b505-3e94-8122-21e061d51cbd" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Exception of type 'DivisionByZero' is not caught by reference" ln="29" locFile="/src/../../../../../../../../src/main.cpp" locStartln="29" sev="3" auth="lyao" locRef="1" rule="EXCEPT-15" lnHash="263904408" rule.header="A class type exception shall always be caught by reference" tool="c++test" lineHash="263904408" unbViolId="b4cdb180-5357-3b7b-9cb0-4fe54afd8509" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5e5da6b2-c00f-3f15-b46e-87a3e1bd0195" locEndPos="5" locType="sr" hash="1535005727" locEndLn="29" goals="0,"/>
    <StdViol msg="Avoid printing information in catch block" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="2" auth="lyao" locRef="1" rule="APSC_DV-002480-a" lnHash="685855313" rule.header="Do not print potentially sensitive information, resulting from an application error into exception messages" tool="c++test" lineHash="685855313" unbViolId="2a094170-9ee5-3970-abad-ec5088924fa7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b2f52550-b684-3402-a66b-99ab23315e7e" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Avoid printing information in catch block" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="2" auth="lyao" locRef="1" rule="OWASP2019-API3-p" lnHash="685855313" rule.header="Do not print potentially sensitive information, resulting from an application error into exception messages" tool="c++test" lineHash="685855313" unbViolId="956fae7f-1b3b-3de4-8faf-3f726f305a02" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="691790c6-102c-3c6e-88e4-27b971b3142e" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Avoid printing information in catch block" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="2" auth="lyao" locRef="1" rule="CWE-200-a" lnHash="685855313" rule.header="Do not print potentially sensitive information, resulting from an application error into exception messages" tool="c++test" lineHash="685855313" unbViolId="ead894c1-473b-33ed-aa33-43bbe30a0d41" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d6222041-d3bc-3d4a-8729-5a8845b9a330" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Avoid printing information in catch block" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="2" auth="lyao" locRef="1" rule="SECURITY-15" lnHash="685855313" rule.header="Do not print potentially sensitive information, resulting from an application error into exception messages" tool="c++test" lineHash="685855313" unbViolId="5221fd76-8558-37ca-be41-9bb7cd51e8f5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ba475a3c-35f5-3b1d-b0f1-17a67a84f41a" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Avoid printing information in catch block" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="2" auth="lyao" locRef="1" rule="APSC_DV-000650-a" lnHash="685855313" rule.header="Do not print potentially sensitive information, resulting from an application error into exception messages" tool="c++test" lineHash="685855313" unbViolId="018629fe-91d5-304a-a8bc-9083c83ce4a8" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="13c2acb7-b151-3e52-a61f-8d8da34214a0" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Avoid printing information in catch block" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="2" auth="lyao" locRef="1" rule="APSC_DV-002570-b" lnHash="685855313" rule.header="Do not print potentially sensitive information, resulting from an application error into exception messages" tool="c++test" lineHash="685855313" unbViolId="750cadea-7c24-399c-a883-1a89d2c695df" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="17b989f9-3331-34d8-a1cc-04474887262b" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="30" locFile="/src/../../../../../../../../src/main.cpp" locStartln="30" sev="3" auth="lyao" locRef="1" rule="FORMAT-37" lnHash="685855313" rule.header="First line in control statement body should be indented more than control statement keyword" tool="c++test" lineHash="685855313" unbViolId="62615337-ff2a-3a92-8960-a72438337513" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="29ce1487-2941-34d4-961a-a3d82f2155c7" locEndPos="5" locType="sr" hash="1535005727" locEndLn="30" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="31" locFile="/src/../../../../../../../../src/main.cpp" locStartln="31" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="31869" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="31869" unbViolId="d3591df8-2bb2-3119-a2fd-a351143366f3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="796273b2-6f1f-3050-9c58-ffb328b44717" locEndPos="1" locType="sr" hash="1535005727" locEndLn="31" goals="0,"/>
    <FlowViol msg="Exception &quot;&quot; was not thrown" ln="31" locFile="/src/../../../../../../../../src/main.cpp" ruleSAFMsg="Point where the exception was created" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="32" rule="BD-PB-STDEXC" FirstElSrcRngStartPos="0" lnHash="31869" ruleSCSCMsg="Point where the created exception gets out of scope" FirstElSrcRngFile="/src/../../../../../../../../src/main.cpp" rule.header="Always throw the created std::exception object" FirstElSrcRngStartln="31" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-28877117" lang="cpp" violId="47c295ef-a020-3f22-a9ff-034f58cf826a" locEndPos="0" locEndLn="32" goals="0," locStartln="31" sev="3" locRef="1" tool="c++test" lineHash="31869" unbViolId="0c8418f6-10f0-3a7c-a81f-4bf3aeb19de4" locType="sr" hash="1535005727" causeLocRef="1">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="1369673555" ln="10" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="10" srcRngEndLn="11" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="Fraction f;" ElType="." rngLn="10"/>
        <ElDesc lineHash="1762418147" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="cout &lt;&lt; HEADER;" ElType="." rngLn="12"/>
        <ElDesc lineHash="821368387" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="if (argc &lt; 3) {" ElType="." rngLn="15">
          <Anns>
            <Ann msg="Condition evaluation: (argc &lt; 3) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-400764885" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="f.numerator = atoll(argv[1]);" ElType="." rngLn="20"/>
        <ElDesc lineHash="-1868196569" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="f.denominator = atoll(argv[2]);" ElType="." rngLn="21"/>
        <ElDesc lineHash="1124672111" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="Division d = Division(f);" ElType="." rngLn="23"/>
        <ElDesc lineHash="1504718800" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="DivisionResult r = d.divide();" ElType="!E" rngLn="25" thrownTypes="DivisionByZero" throwingMethod="Division.divide">
          <ElDescList>
            <ElDesc lineHash="-309185886" ln="8" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="2105514256" srcRngStartln="8" srcRngEndLn="9" srcRngFile="/division/../../../../../../../../src/division/division.cpp" desc="if (fraction.denominator == 0L) throw DivisionByZero();" ElType="!E" rngLn="8" thrownTypes="throwStatement" throwingMethod="DivisionByZero.~DivisionByZero">
              <Anns>
                <Ann msg="Throws an exception" kind="except"/>
                <Ann msg="Condition evaluation: (this->fraction.denominator == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Division.divide() throws DivisionByZero" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc lineHash="685855313" ln="30" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="30" srcRngEndLn="31" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="cout &lt;&lt; &quot;Can not divide by zero, Homer. Sober up!\n&quot;;" ElType="." rngLn="30"/>
        <ElDesc lineHash="31869" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="}" ElType="CP" rngLn="31">
          <Anns>
            <Ann msg="Point where the created exception gets out of scope" kind="cause"/>
            <Ann msg="Point where the exception was created" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Exception &quot;&quot; was not thrown" ln="31" locFile="/src/../../../../../../../../src/main.cpp" ruleSAFMsg="Point where the exception was created" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="32" rule="HICPP-15_1_1-b" FirstElSrcRngStartPos="0" lnHash="31869" ruleSCSCMsg="Point where the created exception gets out of scope" FirstElSrcRngFile="/src/../../../../../../../../src/main.cpp" rule.header="Always throw the created std::exception object" FirstElSrcRngStartln="31" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="2106978518" lang="cpp" violId="a841f716-10b1-30c9-ade2-b90f0611ebab" locEndPos="0" locEndLn="32" goals="0," locStartln="31" sev="3" locRef="1" tool="c++test" lineHash="31869" unbViolId="a37f428e-72ca-3fa8-bff8-2c9ca9b8e213" locType="sr" hash="1535005727" causeLocRef="1">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="1369673555" ln="10" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="10" srcRngEndLn="11" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="Fraction f;" ElType="." rngLn="10"/>
        <ElDesc lineHash="1762418147" ln="12" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="12" srcRngEndLn="13" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="cout &lt;&lt; HEADER;" ElType="." rngLn="12"/>
        <ElDesc lineHash="821368387" ln="15" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="15" srcRngEndLn="16" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="if (argc &lt; 3) {" ElType="." rngLn="15">
          <Anns>
            <Ann msg="Condition evaluation: (argc &lt; 3) (assuming false)" kind="condEval"/>
          </Anns>
        </ElDesc>
        <ElDesc lineHash="-400764885" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="f.numerator = atoll(argv[1]);" ElType="." rngLn="20"/>
        <ElDesc lineHash="-1868196569" ln="21" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="21" srcRngEndLn="22" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="f.denominator = atoll(argv[2]);" ElType="." rngLn="21"/>
        <ElDesc lineHash="1124672111" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="Division d = Division(f);" ElType="." rngLn="23"/>
        <ElDesc lineHash="1504718800" ln="25" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="25" srcRngEndLn="26" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="DivisionResult r = d.divide();" ElType="!E" rngLn="25" thrownTypes="DivisionByZero" throwingMethod="Division.divide">
          <ElDescList>
            <ElDesc lineHash="-309185886" ln="8" srcRngStartPos="0" srcRngEndPos="0" locRef="2" locType="sr" srcRnghash="2105514256" srcRngStartln="8" srcRngEndLn="9" srcRngFile="/division/../../../../../../../../src/division/division.cpp" desc="if (fraction.denominator == 0L) throw DivisionByZero();" ElType="!E" rngLn="8" thrownTypes="throwStatement" throwingMethod="DivisionByZero.~DivisionByZero">
              <Anns>
                <Ann msg="Throws an exception" kind="except"/>
                <Ann msg="Condition evaluation: (this->fraction.denominator == 0) (assuming true)" kind="condEval"/>
              </Anns>
            </ElDesc>
          </ElDescList>
          <Anns>
            <Ann msg="Division.divide() throws DivisionByZero" kind="except"/>
          </Anns>
        </ElDesc>
        <ElDesc lineHash="685855313" ln="30" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="30" srcRngEndLn="31" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="cout &lt;&lt; &quot;Can not divide by zero, Homer. Sober up!\n&quot;;" ElType="." rngLn="30"/>
        <ElDesc lineHash="31869" ln="31" srcRngStartPos="0" srcRngEndPos="0" locRef="1" locType="sr" srcRnghash="1535005727" srcRngStartln="31" srcRngEndLn="32" srcRngFile="/src/../../../../../../../../src/main.cpp" desc="}" ElType="CP" rngLn="31">
          <Anns>
            <Ann msg="Point where the created exception gets out of scope" kind="cause"/>
            <Ann msg="Point where the exception was created" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="Line is incorrectly indented" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="3" auth="lyao" locRef="1" rule="FORMAT-27" lnHash="-293114117" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-293114117" unbViolId="d8bfd1da-4426-3c88-bb84-060bec4522fb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c62e9bbf-b91e-356a-a016-5cd9e6f8682f" locEndPos="1" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="2" auth="lyao" locRef="1" rule="MISRA2008-6_6_5" lnHash="-293114117" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-293114117" unbViolId="380d664f-7439-3235-a6ba-ea8288c5091a" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ecc687ad-fd17-3716-b7d3-8ea0b1966817" locEndPos="3" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="3" auth="lyao" locRef="1" rule="MISRA2004-14_7" lnHash="-293114117" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-293114117" unbViolId="9375d286-ded5-39a0-b7c5-67d928ef1536" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c67d7eb9-adc2-3d2a-bd2d-c36c298616e9" locEndPos="3" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="4" auth="lyao" locRef="1" rule="MISRAC2012-RULE_15_5-a" lnHash="-293114117" rule.header="A function shall have a single point of exit at the end of the function" tool="c++test" lineHash="-293114117" unbViolId="a6d127a7-3313-3fc1-a597-e42ffe88b2cb" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0f8a5b41-b096-3b8b-a572-a44f01d8c25b" locEndPos="3" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="4" auth="lyao" locRef="1" rule="MISRA2012-RULE-15_5" lnHash="-293114117" rule.header="A function should have a single point of exit at the end" tool="c++test" lineHash="-293114117" unbViolId="c4825e3d-23c2-39b5-8f2e-073e028d7795" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="da8a8b19-0ae1-3a2c-98c4-a8863bf66f2e" locEndPos="3" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="Provide only one exit point in 'main' function" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="3" auth="lyao" locRef="1" rule="JSF-113" lnHash="-293114117" rule.header="Functions will have a single exit point" tool="c++test" lineHash="-293114117" unbViolId="37842a4d-490d-3799-83ae-0399469e6ea5" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="60b0ee5b-62c8-30f9-890f-b80e0c1481c9" locEndPos="3" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="32" locFile="/src/../../../../../../../../src/main.cpp" locStartln="32" sev="3" auth="lyao" locRef="1" rule="FORMAT-25_b" lnHash="-293114117" rule.header="Parenthesis shall be used with the &quot;return&quot; statement" tool="c++test" lineHash="-293114117" unbViolId="ee1a7802-5aef-365f-b374-c648ce480b17" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2e160b96-656f-334e-a513-afda5698bb0c" locEndPos="3" locType="sr" hash="1535005727" locEndLn="32" goals="0,"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="3" auth="lyao" locRef="2" rule="METRICS-31" lnHash="1504" rule.header="The assertion density of the code should average to a minimum of two assertions per function" tool="c++test" lineHash="1504" unbViolId="ebd277d7-89a6-308a-8285-f3e5bfd5cd6a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1df88067-a56b-3942-8a46-4c5271626276" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="1" goals="1,"/>
    <StdViol msg="Implementation file 'division.cpp' should have the file name extension &quot;.cc&quot;" ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="3" auth="lyao" locRef="2" rule="NAMING-38" lnHash="1504" rule.header="Implementation files in C++ always have the file name extension &quot;.cc&quot;" tool="c++test" lineHash="1504" unbViolId="929aa93a-518f-3917-875a-c6548a64c83e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="54e39012-da56-3640-b179-d049e77a4998" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="1" goals="1,"/>
    <StdViol msg="Implementation file 'division.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="5" auth="lyao" locRef="2" rule="PFO-04" lnHash="1504" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="1504" unbViolId="4d00586a-08e0-3983-8328-eca3ba58c82c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="571139e2-1551-32b6-abd3-bbea13f68346" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="1" goals="1,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'division.cpp'" ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="3" auth="lyao" locRef="2" rule="COMMENT-02" lnHash="1504" rule.header="Provide copyright information" tool="c++test" lineHash="1504" unbViolId="1e4f5be5-ebb5-3269-856c-fbf5cd881468" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="53e963cb-0d69-3d2f-af76-694119fa02b1" locEndPos="1" locType="sr" hash="2105514256" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'division.cpp'" ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="3" auth="lyao" locRef="2" rule="JSF-133_b" lnHash="1504" rule.header="Every source file will contain copyright information" tool="c++test" lineHash="1504" unbViolId="81322d11-ae69-3718-9527-6d5a8172c7e8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fb7f9131-625d-3679-a0da-975ccb12a298" locEndPos="1" locType="sr" hash="2105514256" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'division.cpp'" ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="3" auth="lyao" locRef="2" rule="COMMENT-03" lnHash="1504" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1504" unbViolId="439bac45-2952-3ed9-bf0a-a259a3e79e75" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92b5d62a-5784-32db-a962-5058436262a6" locEndPos="1" locType="sr" hash="2105514256" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'division.cpp'" ln="1" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="1" sev="3" auth="lyao" locRef="2" rule="JSF-133_a" lnHash="1504" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1504" unbViolId="9152811b-2c66-3f12-b7eb-772a4735ae00" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c3ac14dd-7495-35bb-82b7-a44fa5247c58" locEndPos="1" locType="sr" hash="2105514256" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;division.h&quot;" ln="5" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="5" sev="2" auth="lyao" locRef="2" rule="PREPROC-09" lnHash="347210068" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="347210068" unbViolId="61abe297-bb77-3a81-8f01-ceee78218999" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="64be588f-22d8-311f-b7ad-8199db7a3a3b" locEndPos="1" locType="sr" hash="2105514256" locEndLn="5" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;division.h&quot;" ln="5" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="5" sev="2" auth="lyao" locRef="2" rule="JSF-033" lnHash="347210068" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="347210068" unbViolId="0242a464-7168-3ad4-988f-07428b813f35" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="46cfc904-895d-3f6a-bce3-d601ae59ebff" locEndPos="1" locType="sr" hash="2105514256" locEndLn="5" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="METRICS-19" lnHash="-225973064" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="-225973064" unbViolId="f8441962-0828-3d6b-b186-a994be2f8bb7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="903b1102-9a8f-3532-957e-fc69f8e18607" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="JSF-061" lnHash="-225973064" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-225973064" unbViolId="cb44718a-3cdb-3005-8b83-c44c7676b76f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a338b0eb-bb5b-373a-a2cf-03f3cef595a7" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="FORMAT-42" lnHash="-225973064" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-225973064" unbViolId="c54f4f58-79cc-3ad9-a04d-bcf73348901c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f48fb690-6863-3a03-a98a-dc4d86c9b901" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="JSF-060_a" lnHash="-225973064" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-225973064" unbViolId="6e95470f-5d6c-3fc8-8d2d-efb69498c96f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="523ade78-1213-39d1-b276-06d8026bc895" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="FORMAT-43" lnHash="-225973064" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-225973064" unbViolId="38e85511-8542-3a16-b80c-579729e8dd1b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dbeebf26-d339-3f94-aea1-6eac21e88a02" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="JSF-060_b" lnHash="-225973064" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-225973064" unbViolId="490fb90a-b057-3277-b52a-c93325211532" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="792e7b57-aabb-36e2-9887-857ca9296299" locEndPos="1" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="FORMAT-02" lnHash="-225973064" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-225973064" unbViolId="a7205589-b13a-336a-9732-77391d68d1a5" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="744b0874-56a8-3f79-b4f5-96c88d004296" locEndPos="1" locType="sr" hash="2105514256" locEndLn="7" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="FORMAT-34" lnHash="-225973064" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-225973064" unbViolId="03dee125-be9c-398a-b2c0-b76029638687" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="478fb8b6-827a-3221-8fbf-49f9dfbef6b5" locEndPos="1" locType="sr" hash="2105514256" locEndLn="7" goals="0,"/>
    <StdViol msg="The 'divide' function should be preceded by a comment that contains the '@brief' tag" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="COMMENT-14" lnHash="-225973064" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-225973064" unbViolId="c69b5077-195e-38a0-9fbc-9ed53d95174a" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2155ab5f-273e-3b64-912e-70e472cfd6f2" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="The 'divide' function should be preceded by a comment that contains the '@brief' tag" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="2" auth="lyao" locRef="2" rule="AUTOSAR-A2_7_3-a" lnHash="-225973064" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-225973064" unbViolId="0a432126-8ea7-3bf7-ac9a-d93a9ff13652" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="832a184a-c235-3d08-af53-03d0ded99af5" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="The 'divide' function should be preceded by a comment that contains the '@return' tag" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="2" auth="lyao" locRef="2" rule="AUTOSAR-A2_7_3-b" lnHash="-225973064" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-225973064" unbViolId="7bfbadde-92b7-3337-ac7a-4069250a74f4" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4acdba21-d0ec-376b-91d1-f15d368cfc2a" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="The 'divide' function should be preceded by a comment that contains the '@return' tag" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="COMMENT-14_b" lnHash="-225973064" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-225973064" unbViolId="724254bb-88df-3afb-9480-b9a99687b24f" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="57415557-4633-303b-a092-d4520e2b2d86" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Return type is not placed in line before function 'divide'" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="FORMAT-28" lnHash="-225973064" rule.header="In a function definition, the return type of the function should be written on a separate line directly above the function name" tool="c++test" lineHash="-225973064" unbViolId="e3a569e2-7dfb-32c7-8624-7cca2afc5329" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0b012fe3-807e-392f-807a-f1c4fb74f3cf" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Function 'divide' has Cyclomatic Complexity value: 2" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="5" auth="lyao" locRef="2" rule="METRICS-29" lnHash="-225973064" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="-225973064" unbViolId="b902e465-bb56-3088-bb78-199860068fe3" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3916cd36-4131-34b7-99dd-b95e46e84336" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Function 'divide' has Essential Complexity value: 1" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="5" auth="lyao" locRef="2" rule="METRICS-33" lnHash="-225973064" rule.header="Report Essential Complexity" tool="c++test" lineHash="-225973064" unbViolId="a02c21fc-8128-3676-a3d7-384630f9b8ec" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1ba1cc38-bcf0-3434-8719-37555a0b3bb4" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Naming convention not followed: divide" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="3" auth="lyao" locRef="2" rule="NAMING-17" lnHash="-225973064" rule.header="Begin all function names with uppercase letter" tool="c++test" lineHash="-225973064" unbViolId="393b3d7b-54b2-3c57-8888-d6f465e0c3e1" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="028f9b9f-ee87-3ea6-90a5-9125761f530d" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Returned value from function 'divide' is passed by value" ln="7" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="7" sev="5" auth="lyao" locRef="2" rule="OPT-33" lnHash="-225973064" rule.header="Consider returning object by reference instead of by value" tool="c++test" lineHash="-225973064" unbViolId="dc4d43b8-ddeb-32a3-b241-669dffa58966" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c973aa5d-0435-3fbb-9318-55c4ecdfaa0d" locEndPos="26" locType="sr" urgent="true" hash="2105514256" locEndLn="7" goals="1,"/>
    <StdViol msg="Line is incorrectly indented" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="3" auth="lyao" locRef="2" rule="FORMAT-27" lnHash="-309185886" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-309185886" unbViolId="dba928ef-6816-397f-bfac-f77077ad0e6d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b4dfa4c2-c28b-361b-9843-9a869bb0e937" locEndPos="1" locType="sr" hash="2105514256" locEndLn="8" goals="0,"/>
    <StdViol msg="The 'if' statement doesn't have an 'else' clause" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="3" auth="lyao" locRef="2" rule="CODSTA-23" lnHash="-309185886" rule.header="All 'if' statements should have an 'else' clause" tool="c++test" lineHash="-309185886" unbViolId="a8182e9e-eeee-31c1-beda-3241ebbb7793" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="40df3bb3-a680-3c73-a783-8eac4dea898e" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="MISRAC2012-RULE_15_6-b" lnHash="-309185886" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-309185886" unbViolId="0a43ed46-e6b9-35fa-8e20-fb9129500e4e" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ae77207a-d65d-3a87-b6ac-0204ae20d618" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="3" auth="lyao" locRef="2" rule="MISRA2004-14_9" lnHash="-309185886" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-309185886" unbViolId="41549161-2eee-35c4-aa7c-f7e5cded0b7c" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1df13030-4c33-3e2a-b19e-e9b753028d7a" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="JSF-059_b" lnHash="-309185886" rule.header="The statements forming the body of an 'if', 'else if' or 'else' statement shall always be enclosed in braces" tool="c++test" lineHash="-309185886" unbViolId="90d05cd7-d3d9-3614-8051-6e5b5104607c" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="adbc566e-59c8-30be-98af-1f0c7d0fbde1" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="3" auth="lyao" locRef="2" rule="HICPP-6_1_1-b" lnHash="-309185886" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-309185886" unbViolId="e8dac5ca-65cb-3bc6-9001-544f77a25dfd" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e7bb3454-456b-3d40-80ba-e841a73bd627" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="AUTOSAR-M6_4_1-a" lnHash="-309185886" rule.header="'if' and 'else' should be followed by a compound statement" tool="c++test" lineHash="-309185886" unbViolId="5274fadf-1f02-32ec-869f-390744a9f986" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="163b9a3f-ae87-3697-b4f5-a385da395068" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="MISRA2012-RULE-15_6_b" lnHash="-309185886" rule.header="The body of an iteration-statement or a selection-statement shall be a compound-statement" tool="c++test" lineHash="-309185886" unbViolId="0772828d-5815-31ae-9680-8dbf6cd6548d" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7758e4ec-1d34-3362-800b-bb3fdb210425" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Conditional statement 'if' in a function 'divide' should be followed by a block" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="MISRA2008-6_4_1" lnHash="-309185886" rule.header="An if ( condition ) construct shall be followed by a compound statement. The else keyword shall be followed by either a compound statement, or another if statement" tool="c++test" lineHash="-309185886" unbViolId="863dd0a7-2dd2-31dc-9c33-425c2d27212e" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5123c2e7-7d15-3468-a69a-b66ea5c66ca2" locEndPos="3" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="The suffix 'L' should not be used directly with constant '0L'" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="3" auth="lyao" locRef="2" rule="PORT-17" lnHash="-309185886" rule.header="Don't use 'i64' or 'L' suffixes directly" tool="c++test" lineHash="-309185886" unbViolId="643b0b15-cc29-3c91-b198-0cfed2d535e1" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2eb0ca27-520e-31d6-897f-e6472959ec3d" locEndPos="31" locType="sr" hash="2105514256" locEndLn="8" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'divide'" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="JSF-208" lnHash="-309185886" rule.header="C++ exceptions shall not be used" tool="c++test" lineHash="-309185886" unbViolId="8834a800-b521-3ae5-b4c7-8b570e5e9cb1" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a22a1817-2247-3851-ba59-5dd64411d74a" locEndPos="35" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="c++ exception handling structure is used in function 'divide'" ln="8" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="8" sev="2" auth="lyao" locRef="2" rule="EXCEPT-05" lnHash="-309185886" rule.header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" tool="c++test" lineHash="-309185886" unbViolId="dde1d483-05bf-3dbe-9b41-26af729756f6" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cc7137e8-2f5d-369f-9dcf-ea97bd28f9b6" locEndPos="35" locType="sr" urgent="true" hash="2105514256" locEndLn="8" goals="1,"/>
    <StdViol msg="Line is incorrectly indented" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="FORMAT-27" lnHash="-741853343" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-741853343" unbViolId="e1522174-9a3a-304e-94be-d06ea30e1ba9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7f31cee9-b0af-32cd-9a53-be769ef3d039" locEndPos="1" locType="sr" hash="2105514256" locEndLn="10" goals="0,"/>
    <StdViol msg="R-2351: declaration hides member &quot;Division::result&quot; (declared at line 49 of &quot;D:\reports\projects\cppprojecttemplate\src\division\division.h&quot;)" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="5" auth="lyao" locRef="2" rule="PARSER-REMARK" lnHash="-741853343" rule.header="Parser remark" tool="c++test" lineHash="-741853343" unbViolId="155884be-4447-3073-ae12-dd69ca08db4f" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c7c309f8-0dd9-3eb6-9b36-1dd020a821e5" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="The definition of the 'result' variable should contain a braced initializer" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="2" auth="lyao" locRef="2" rule="AUTOSAR-A8_5_2-a" lnHash="-741853343" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-741853343" unbViolId="276f1afc-adc1-30de-8989-f3cd78d07a46" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9bf2e009-0b1a-3936-a669-fa57fa961b48" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="The definition of the 'result' variable should contain a braced initializer" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="CODSTA-MCPP-38" lnHash="-741853343" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-741853343" unbViolId="d38608a9-86aa-3b86-bad0-200f0d13cf33" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1c9bf6c2-a6db-3cd3-9ed6-da22927d5cf2" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="The 'result' variable should be declared with the 'auto' type specifier" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="2" auth="lyao" locRef="2" rule="CODSTA-MCPP-08_a" lnHash="-741853343" rule.header="Prefer 'auto' to explicit type names in variable declarations" tool="c++test" lineHash="-741853343" unbViolId="97e53086-4b9d-3369-ad28-2a4921d9efdf" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2efab03d-d430-3192-a588-c1a7e26a04fb" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="Declare local variable 'result' as const" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="CERT_C-DCL00-a" lnHash="-741853343" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="-741853343" unbViolId="bcf812f0-32e6-3c05-8a4b-89fa0d219a98" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6f6d0309-9537-3cdd-93f8-ab6d0c174352" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="Declare local variable 'result' as const" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="2" auth="lyao" locRef="2" rule="AUTOSAR-A7_1_1-a" lnHash="-741853343" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="-741853343" unbViolId="ebc35bac-4f52-391f-9989-11b971d79aed" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1cb18ea0-115d-35d7-a46c-84f9a9c36723" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="Declare local variable 'result' as const" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="2" auth="lyao" locRef="2" rule="MISRA2008-7_1_1" lnHash="-741853343" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="-741853343" unbViolId="f8735539-eb57-323b-8ac1-68cd3464cfda" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3db6cbe3-760c-3b77-9526-143f8f1b42f7" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="Declare local variable 'result' as const" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="CODSTA-CPP-53" lnHash="-741853343" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="-741853343" unbViolId="41c1b106-862a-387a-ae5e-b956e73d307c" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f0d100ee-4f9d-3ab1-8deb-c99512b47663" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="Declare local variable 'result' as const" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="HICPP-7_1_2-a" lnHash="-741853343" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="-741853343" unbViolId="3c766fec-7d37-368e-856e-646176baa1cb" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f22de660-7bed-327a-892b-8b06518793db" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="The 'result' variable should be commented" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="JSF-132_a" lnHash="-741853343" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="-741853343" unbViolId="efbd0bae-54e7-39df-8309-7deee8539918" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a8812022-d8c3-3303-a529-dd9939cc1aaf" locEndPos="18" locType="sr" urgent="true" hash="2105514256" locEndLn="10" goals="1,"/>
    <StdViol msg="The 'result' variable should be commented" ln="10" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="10" sev="3" auth="lyao" locRef="2" rule="COMMENT-05" lnHash="-741853343" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="-741853343" unbViolId="dba13f98-ae65-3aae-bd76-d4ba10e88320" locStartPos="17" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="075689a8-d404-3ef6-abc3-fa7eff5c1a7a" locEndPos="18" locType="sr" hash="2105514256" locEndLn="10" goals="0,"/>
    <StdViol msg="The left-hand-side operand of the '%' operator should be of the unsigned integer type instead of the 'long long' type" ln="12" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="12" sev="3" auth="lyao" locRef="2" rule="CERT_C-INT10-a" lnHash="849231736" rule.header="The operands of the remainder operator '%' should be of unsigned integer types" tool="c++test" lineHash="849231736" unbViolId="fa9c2884-b2ec-39d1-abc4-c9751023a576" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="13a0db36-79a7-3745-9605-a968919d14a0" locEndPos="5" locType="sr" urgent="true" hash="2105514256" locEndLn="12" goals="1,"/>
    <StdViol msg="The right-hand-side operand of the '%' operator should be of the unsigned integer type instead of the 'long long' type" ln="12" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="12" sev="3" auth="lyao" locRef="2" rule="CERT_C-INT10-a" lnHash="849231736" rule.header="The operands of the remainder operator '%' should be of unsigned integer types" tool="c++test" lineHash="849231736" unbViolId="b0c4815d-f816-36d9-a8b3-593952b243e7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b9b75670-be27-3d37-a01e-dd509d02ec1a" locEndPos="5" locType="sr" urgent="true" hash="2105514256" locEndLn="12" goals="1,"/>
    <StdViol msg="Line is incorrectly indented" ln="13" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="13" sev="3" auth="lyao" locRef="2" rule="FORMAT-27" lnHash="987998" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="987998" unbViolId="57be7a54-f217-3750-87dd-13f5e3b15ba4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c8e1f075-6cad-35a5-8f04-d0efc9e69c7e" locEndPos="1" locType="sr" hash="2105514256" locEndLn="13" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="15" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="15" sev="3" auth="lyao" locRef="2" rule="FORMAT-27" lnHash="1624238286" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1624238286" unbViolId="c557e50c-b7c2-38e7-8f87-e2d653440ff2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75b819de-bff9-3b1d-9510-644013bfa1ac" locEndPos="1" locType="sr" hash="2105514256" locEndLn="15" goals="0,"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="15" locFile="/division/../../../../../../../../src/division/division.cpp" locStartln="15" sev="3" auth="lyao" locRef="2" rule="FORMAT-25_b" lnHash="1624238286" rule.header="Parenthesis shall be used with the &quot;return&quot; statement" tool="c++test" lineHash="1624238286" unbViolId="a2338e14-2191-326a-b024-f6fa848ecd01" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dfcf8f3b-d39b-3446-aacf-e61618f25312" locEndPos="3" locType="sr" hash="2105514256" locEndLn="15" goals="0,"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="3" rule="METRICS-31" lnHash="1137051340" rule.header="The assertion density of the code should average to a minimum of two assertions per function" tool="c++test" lineHash="1137051340" unbViolId="4dd5ef08-7a92-3e40-b33b-058cfb0fda24" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ff1794c4-f4f9-37cb-b6a4-71393bff78e4" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'main.cpp' should have the file name extension &quot;.cc&quot;" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="3" rule="NAMING-38" lnHash="1137051340" rule.header="Implementation files in C++ always have the file name extension &quot;.cc&quot;" tool="c++test" lineHash="1137051340" unbViolId="0fb92701-1f8a-3892-8c36-adad226bcfc6" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="66a06e41-7917-30cb-a4df-8d0a8106258e" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'main.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="5" auth="lyao" locRef="3" rule="PFO-04" lnHash="1137051340" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="1137051340" unbViolId="653af734-893c-339c-9887-d62adec00fc7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9a5b2ed0-37f0-3ddf-bb40-b30132a49b3c" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'main.cpp'" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="3" rule="COMMENT-02" lnHash="1137051340" rule.header="Provide copyright information" tool="c++test" lineHash="1137051340" unbViolId="40bb96da-1297-3eb9-b794-8dfe7ec60523" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="65cdc316-d9af-3c5b-9bbd-b7c5a7cef8f0" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'main.cpp'" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="3" rule="JSF-133_b" lnHash="1137051340" rule.header="Every source file will contain copyright information" tool="c++test" lineHash="1137051340" unbViolId="7d92b27c-50f1-3ae7-ad8c-7dfab569a010" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f66c17bd-49f3-3912-ab0f-03af3a5681b5" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'main.cpp'" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="3" rule="COMMENT-03" lnHash="1137051340" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1137051340" unbViolId="fea0a617-3338-336c-9f2a-ceb05d2f06d4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="535a5e76-8b1b-3b88-8801-46170f149eea" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'main.cpp'" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="3" auth="lyao" locRef="3" rule="JSF-133_a" lnHash="1137051340" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1137051340" unbViolId="125a7473-1dbf-368d-94e1-b44c429ce1f8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="528e314a-c4a4-3d39-b9ac-49f3e0ee35db" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="2" auth="lyao" locRef="3" rule="PREPROC-09" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="eb003575-acd2-31a9-9c18-e3bb8f6d3182" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5ff21a68-ac69-3620-93aa-ca8b27da535d" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="1" locFile="/test/../../../../../../../../test/main.cpp" locStartln="1" sev="2" auth="lyao" locRef="3" rule="JSF-033" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="d4bf8ecf-0f38-3596-9454-d5a70ff33e7f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cb2a10d2-14a7-3742-84a4-cca6d8b6912b" locEndPos="1" locType="sr" hash="1598712918" locEndLn="1" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="METRICS-19" lnHash="1322250738" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="1322250738" unbViolId="76c34b63-6ae9-3101-91dc-19502f421009" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8abf97f6-34d1-3bb6-9736-2cd3d37e8497" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="JSF-061" lnHash="1322250738" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1322250738" unbViolId="38550e12-37d4-3682-b689-1b3dacfde990" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ae2cecc5-30b6-3b7f-a1a6-00bc77ea50d1" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="FORMAT-42" lnHash="1322250738" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1322250738" unbViolId="ec970161-ba88-3739-9e82-6db764b524d9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f57bb3bd-bdb4-3668-abe6-ed55edaf1691" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="JSF-060_a" lnHash="1322250738" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1322250738" unbViolId="42231997-066e-3da3-a9fe-81376e50a9dc" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="df5bd5b4-7d4d-3d2b-81ef-b18c5217c76b" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="FORMAT-43" lnHash="1322250738" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1322250738" unbViolId="7bc15c6b-3934-3e4b-ad61-36dd11a1b30f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9123d088-d6d6-3ff3-a1f1-cc8744f96b40" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="JSF-060_b" lnHash="1322250738" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1322250738" unbViolId="f015004a-f63b-3eb8-bf9b-8b57fd98d66a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="330bc211-1593-3390-86ec-47eacc111f62" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="FORMAT-02" lnHash="1322250738" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="1322250738" unbViolId="fa3a7b45-667b-33b3-9f26-2a45e21c7db4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f8d0c539-b428-300b-970b-564809b9ef4d" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="FORMAT-34" lnHash="1322250738" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="1322250738" unbViolId="76efb765-eb28-392d-a020-7ab80f749d1d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="10c512d4-2059-3a07-beff-d83271ea1194" locEndPos="1" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="COMMENT-04" lnHash="1322250738" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="1322250738" unbViolId="2f2cc437-b0a7-34b9-9649-87bb74a12146" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="182b08b3-8bc9-38da-8b2b-8939b27f217a" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="JSF-134" lnHash="1322250738" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="1322250738" unbViolId="aa0caac0-4ecb-3415-8449-319f4481ff6e" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fab5c21c-2337-30f7-9f87-91dd59235666" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="COMMENT-14" lnHash="1322250738" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="1322250738" unbViolId="db8c966b-8192-3953-94c5-ed5a62b2e07d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="201a5dfd-c186-3141-b0df-b66f0c7e0a0e" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-A2_7_3-a" lnHash="1322250738" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="1322250738" unbViolId="074c458e-f8b0-3f6f-a4dc-682dda8bbf2c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="de22c9b9-028f-3a45-9046-31d9d637e833" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-A2_7_3-b" lnHash="1322250738" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1322250738" unbViolId="e86b464e-4f37-3509-8814-046bfc8c3114" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fb6353c8-6dbe-3430-bb47-15bac4e4ea0d" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="COMMENT-14_b" lnHash="1322250738" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1322250738" unbViolId="e5111683-6fc4-3708-bf29-b40f2e5c25b6" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="98d5e8bb-279b-3a1c-8155-667db3a636ba" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-A2_7_3-b" lnHash="1322250738" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1322250738" unbViolId="842641fb-3748-3594-8619-1ec19550eee0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aa86187f-46b6-3425-b996-eab8794a8be6" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="COMMENT-14_b" lnHash="1322250738" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1322250738" unbViolId="2280c4c0-51e3-3e15-8495-76d08a554552" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="818be6a2-c81f-302a-bdbb-dee848a3cf0f" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-A2_7_3-b" lnHash="1322250738" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1322250738" unbViolId="f252fee0-5518-38e8-aec8-2b32fb6e4482" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="38669936-40d6-3353-b21a-63de5c6dbb5f" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="COMMENT-14_b" lnHash="1322250738" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1322250738" unbViolId="5b9ebc03-6ee2-37ba-81a0-28f4127159e3" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2655fb35-3d55-32bf-b903-af0ee5533a90" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="'main' shall be declared as unsigned int or signed int" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="PORT-13" lnHash="1322250738" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="1322250738" unbViolId="59f655aa-311a-3c87-aafb-6ea46ae3083b" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c3f0d870-dba4-3280-bdf0-ea8777d6398c" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CERT_CPP-ERR50-d" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="feeadee7-37d6-35bb-a305-378e54a15929" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7d02ea07-4320-3605-a64e-8e944d1a070c" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-A15_3_3-a" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="5f16f5b0-0bac-389a-b995-8bc87c6a7d1d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="990f12b4-4f54-3b8a-a0f4-0358caa927ad" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="HICPP-15_3_2-b" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="ed510fcb-c1ff-3ddf-8126-bce5c5dfb7da" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="850af582-fa67-397d-a1dd-47f09ed69c97" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="MISRA2008-15_3_2" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="0462b622-52b1-3cfe-a01c-6e03350f88c2" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="32b6a817-28a0-31c2-8943-607e9909fad6" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-A15_5_3-d" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="10690f67-58e6-3eaf-adb8-bcc6e3c8c891" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="21c40e88-a1a7-3797-ba84-2561f7ab88d8" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="EXCEPT-06" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="a86335f7-b313-36ee-bdc2-602ea91c519e" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="297bd076-62a7-3f2c-a98d-4df08535db25" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="MISRA2008-15_5_3_d" lnHash="1322250738" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1322250738" unbViolId="7c6bf514-0671-39fb-a6a8-809f328eb012" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a9f7de10-5636-3912-9689-112ebcea56cc" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Return type is not placed in line before function 'main'" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="FORMAT-28" lnHash="1322250738" rule.header="In a function definition, the return type of the function should be written on a separate line directly above the function name" tool="c++test" lineHash="1322250738" unbViolId="faf9ac9d-ff89-3d58-8c49-fb51637a6259" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c83c6699-c771-3a16-a099-a81ab89ec311" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Function 'main' has Cyclomatic Complexity value: 1" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="5" auth="lyao" locRef="3" rule="METRICS-29" lnHash="1322250738" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="1322250738" unbViolId="86cdd556-b37d-3324-bed8-67e6b4448acf" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d0cf60ae-49b7-366e-bc71-906097a8afd9" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Function 'main' has Essential Complexity value: 1" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="5" auth="lyao" locRef="3" rule="METRICS-33" lnHash="1322250738" rule.header="Report Essential Complexity" tool="c++test" lineHash="1322250738" unbViolId="d40a91e0-c18d-3f22-8216-0d5d1748ac37" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="09ff1820-307a-35e8-ad5c-4db1f4699b82" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="MISRA2012-RULE-8_6" lnHash="1322250738" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="1322250738" unbViolId="15f697fc-09f5-329a-b5de-30c808fd5986" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="be7104f6-481a-32c5-9db1-6ae02332ec7e" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-M3_2_4-a" lnHash="1322250738" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1322250738" unbViolId="feb93200-449c-3d8c-8be6-564beea5189f" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="4cb55c61-64b5-39ef-a99a-3f8d73d5f93e" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="GLOBAL-ONEEXTERNDEF" lnHash="1322250738" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1322250738" unbViolId="9a6eefe8-7db8-31af-8479-5927645bd9e9" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="2cd31031-18da-38c5-9de5-c6021faaba80" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="MISRA2008-3_2_4" lnHash="1322250738" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="1322250738" unbViolId="669d9920-9a93-33b4-b06d-c376a2fdbd7a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="2ab5e479-86a1-3b93-a99e-14724606f49a" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="MISRAC2012-RULE_8_6-a" lnHash="1322250738" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1322250738" unbViolId="48fd590a-195e-3c8e-a6f6-562f5e941f3d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="464090d6-2664-3010-b04f-5e7f97e29b65" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="GLOBAL-ONEFILEDECL" lnHash="1322250738" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1322250738" unbViolId="6e3d7b56-b398-3b71-bc5c-b9c42ac3de27" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="22d17a30-5fc8-3f1c-b7d3-78c13ad37950" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="AUTOSAR-M3_2_3-a" lnHash="1322250738" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1322250738" unbViolId="19ba9372-c3d9-33be-bef8-b7ed724ab0c2" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="843ea5be-07fe-324a-8c47-2f9b0a4cb149" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="HICPP-7_4_3-a" lnHash="1322250738" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1322250738" unbViolId="96dad4ab-b61d-3c0f-ac4a-0ab9b1aa8c4d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ed909124-10f4-3196-9a3c-68d6804870ff" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="MISRA2008-3_2_3" lnHash="1322250738" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1322250738" unbViolId="baef2dd1-b07e-38c1-aec6-244d612058b2" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="9fcc22a4-7b45-34e0-b66d-f2029c7c0051" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="AUTOSAR-A2_10_5-b" lnHash="1322250738" rule.header="Identifiers that define functions with external linkage shall be unique" tool="c++test" lineHash="1322250738" unbViolId="3516b897-f6fc-3bbe-83fd-8cbb45049160" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="193bb926-156c-3328-9a60-0939e06cc546" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="MISRA2008-2_10_5_b" lnHash="1322250738" rule.header="The identifier name of a non-member object or function with static storage duration should not be reused" tool="c++test" lineHash="1322250738" unbViolId="cddff6af-1240-3718-9017-9c5124136a14" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="3c271ecc-51ff-3de9-a9a0-dd7c863e95ea" locEndPos="5" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="MISRA2008-3_9_2" lnHash="1322250738" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1322250738" unbViolId="5a8f5ac1-a30d-3f53-9697-ef3ec9b714e4" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="64642ee0-e7a4-3f4e-8f50-e872c2a883c3" locEndPos="10" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="MISRA-013" lnHash="1322250738" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1322250738" unbViolId="50edd273-2419-3c55-b258-75c0f964cd56" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0693cf03-4f18-39a8-ad3d-6fe8148bbfce" locEndPos="10" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="'argc' shall be declared as unsigned int or signed int" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="PORT-13" lnHash="1322250738" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="1322250738" unbViolId="b60fdebf-93c6-302b-b2e1-158e2c9c68b4" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eaf8defd-3e92-3058-9384-013e3f10d70e" locEndPos="14" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Parameter 'argc' is not validated before use" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CERT_C-API00-a" lnHash="1322250738" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1322250738" unbViolId="bdf5a190-be73-384f-9a00-82472cabf8c0" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="358bf695-5aa7-3407-8cd7-8b9ac999c10b" locEndPos="14" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Parameter 'argc' is not validated before use" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CODSTA-86" lnHash="1322250738" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1322250738" unbViolId="35590049-4ce2-3e64-8e01-bee520b2b39e" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9491e7c-7718-317a-8f89-415c080e1214" locEndPos="14" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="NAMING-HN-22" lnHash="1322250738" rule.header="Hungarian notation for int types" tool="c++test" lineHash="1322250738" unbViolId="ef109353-64a6-3d86-820c-c893ab4cfc0b" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2c285cb5-db56-32ad-9d46-97b138340b86" locEndPos="14" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="NAMING-HN-30" lnHash="1322250738" rule.header="Hungarian notation for int types" tool="c++test" lineHash="1322250738" unbViolId="aa7896ac-14a5-3012-847c-69569b379d0f" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6fe68324-cc57-3e3d-878a-57224156a04e" locEndPos="14" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="NAMING-HN-43" lnHash="1322250738" rule.header="Hungarian notation for word types" tool="c++test" lineHash="1322250738" unbViolId="e7c68125-6faa-359a-9917-720e2aeda619" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="387e082f-0532-3f51-bee9-f11ba2eed6dd" locEndPos="14" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="MISRA2008-3_9_2" lnHash="1322250738" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1322250738" unbViolId="7851e022-4882-3c9e-8c75-e43364f4a453" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e1564e3d-d1db-3f51-9a48-5f9570fa5c5b" locEndPos="20" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="MISRA-013" lnHash="1322250738" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1322250738" unbViolId="6cca9345-8df7-33a0-bea7-b4aa1b8586f9" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ccc0310d-e852-3555-84b2-cbb314780823" locEndPos="20" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="JSF-062" lnHash="1322250738" rule.header="The dereference operator '*' and the address-of operator '&amp;' will be directly connected with the type-specifier" tool="c++test" lineHash="1322250738" unbViolId="30ed16b6-a30f-3df3-8837-c41751a54072" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e67a2725-128e-3849-9ed3-784c38e1ac39" locEndPos="25" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="4" auth="lyao" locRef="3" rule="FORMAT-32" lnHash="1322250738" rule.header="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" tool="c++test" lineHash="1322250738" unbViolId="b2b401ae-a929-3dca-9c8b-57a1d4898034" locStartPos="24" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="01f1dae6-aa33-34f5-8646-c07cdc047251" locEndPos="25" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The parameter of pointer or array type is declared: argv" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CODSTA-94" lnHash="1322250738" rule.header="Do not declare pointer or array type" tool="c++test" lineHash="1322250738" unbViolId="3033b167-999a-3f20-8feb-633bb057e6d0" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eea90df1-28a3-312f-a25c-a45724900850" locEndPos="26" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="The parameter of pointer type is declared: argv" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CODSTA-95" lnHash="1322250738" rule.header="Do not declare pointer type" tool="c++test" lineHash="1322250738" unbViolId="a83f48ae-09ef-39bc-832e-4ba879030946" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="294d5549-1b24-3971-8f2c-d4481a14353a" locEndPos="26" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Parameter 'argv' with array type was found in 'main' function declaration" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="JSF-097_c" lnHash="1322250738" rule.header="Arrays shall not be used in global functions" tool="c++test" lineHash="1322250738" unbViolId="6be358e9-7ebf-3d7c-9de7-8c8480ce2fd4" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="32c8f1c8-b754-3e60-8bf7-2ba39865ac72" locEndPos="26" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Parameter 'argv' with array type was found in 'main' function declaration" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="2" auth="lyao" locRef="3" rule="CODSTA-142" lnHash="1322250738" rule.header="Global functions shall not declare parameters with array type" tool="c++test" lineHash="1322250738" unbViolId="9546cda7-afa1-3668-8702-99fef37fd710" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2a4e8278-b93a-3952-9f3e-1cb8d5b41b4e" locEndPos="26" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CERT_C-API00-a" lnHash="1322250738" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1322250738" unbViolId="80f211cb-8cb0-3b9b-ae0b-de0813062fa0" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eb6a95aa-ada5-39c5-bcf8-325765de0d74" locEndPos="26" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="3" locFile="/test/../../../../../../../../test/main.cpp" locStartln="3" sev="3" auth="lyao" locRef="3" rule="CODSTA-86" lnHash="1322250738" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1322250738" unbViolId="45db6923-aa21-301d-9da3-6210ea9fb4f9" locStartPos="25" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3beae7c6-6e8e-3789-b923-af58de981def" locEndPos="26" locType="sr" hash="1598712918" locEndLn="3" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="4" locFile="/test/../../../../../../../../test/main.cpp" locStartln="4" sev="2" auth="lyao" locRef="3" rule="SECURITY-35" lnHash="462088924" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="462088924" unbViolId="840489d7-049c-33cb-a8be-6b90883555d9" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15abe5e7-db2c-3168-a5e7-65e0e05cb26f" locEndPos="3" locType="sr" hash="1598712918" locEndLn="4" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="4" locFile="/test/../../../../../../../../test/main.cpp" locStartln="4" sev="2" auth="lyao" locRef="3" rule="SECURITY-35" lnHash="462088924" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="462088924" unbViolId="2a0635cc-a16c-3b34-83b6-c027bb23bb03" locStartPos="28" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="13e83625-d642-3ecb-8b8a-4a87f65877dc" locEndPos="29" locType="sr" hash="1598712918" locEndLn="4" goals="0,"/>
    <StdViol msg="Expression of array type is passed as argument to function 'InitGoogleTest'" ln="4" locFile="/test/../../../../../../../../test/main.cpp" locStartln="4" sev="2" auth="lyao" locRef="3" rule="JSF-097_d" lnHash="462088924" rule.header="Arrays shall not be passed to functions as array/pointer parameters" tool="c++test" lineHash="462088924" unbViolId="9414715a-68e8-38aa-8c91-9684255fa163" locStartPos="35" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9d5f2f9e-ae92-34d0-b10d-d2f51e6c1975" locEndPos="36" locType="sr" hash="1598712918" locEndLn="4" goals="0,"/>
    <StdViol msg="Expression of array type is passed as argument to function 'InitGoogleTest'" ln="4" locFile="/test/../../../../../../../../test/main.cpp" locStartln="4" sev="3" auth="lyao" locRef="3" rule="HICPP-4_1_1-b" lnHash="462088924" rule.header="Do not pass an expression with array type to a function with a pointer or array type parameter" tool="c++test" lineHash="462088924" unbViolId="8a493d3d-ecc7-3c50-aa93-8e31f04e73b4" locStartPos="35" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f8a2d225-c8ce-39e9-af96-ad9d3a388471" locEndPos="36" locType="sr" hash="1598712918" locEndLn="4" goals="0,"/>
    <StdViol msg="Expression of array type is passed as argument to function 'InitGoogleTest'" ln="4" locFile="/test/../../../../../../../../test/main.cpp" locStartln="4" sev="3" auth="lyao" locRef="3" rule="PB-41_b" lnHash="462088924" rule.header="Do not pass an expression with array type to a function with a pointer or array type parameter" tool="c++test" lineHash="462088924" unbViolId="3bf92e87-2aa2-3ffb-acfd-e398c5ce4c13" locStartPos="35" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6fa18a8d-05f6-3544-85ed-67c91f7c0436" locEndPos="36" locType="sr" hash="1598712918" locEndLn="4" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="5" locFile="/test/../../../../../../../../test/main.cpp" locStartln="5" sev="3" auth="lyao" locRef="3" rule="FORMAT-27" lnHash="-545848069" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-545848069" unbViolId="c07ec913-70e0-3a57-a340-47fcaa686a1b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="23dec478-74ba-36fa-baaf-e3ea7ee20b2b" locEndPos="1" locType="sr" hash="1598712918" locEndLn="5" goals="0,"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="5" locFile="/test/../../../../../../../../test/main.cpp" locStartln="5" sev="3" auth="lyao" locRef="3" rule="FORMAT-25_b" lnHash="-545848069" rule.header="Parenthesis shall be used with the &quot;return&quot; statement" tool="c++test" lineHash="-545848069" unbViolId="9946f79f-7e7f-39e5-8c29-dd02295bd1af" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="26ea4c89-b775-361b-8f0c-70f29c121cab" locEndPos="3" locType="sr" hash="1598712918" locEndLn="5" goals="0,"/>
    <StdViol msg="The global function 'RUN_ALL_TESTS' is called without scope resolution operator '::'" ln="5" locFile="/test/../../../../../../../../test/main.cpp" locStartln="5" sev="5" auth="lyao" locRef="3" rule="CODSTA-CPP-23" lnHash="-545848069" rule.header="Whenever a global function  is  referenced, use the :: operator" tool="c++test" lineHash="-545848069" unbViolId="6eb8400a-6a77-326a-bf1d-719490dfe23d" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ac959b90-69bf-37fd-bd74-46ecbb2a4193" locEndPos="10" locType="sr" hash="1598712918" locEndLn="5" goals="0,"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="METRICS-31" lnHash="1504" rule.header="The assertion density of the code should average to a minimum of two assertions per function" tool="c++test" lineHash="1504" unbViolId="1f302e12-7ba1-3721-b4a7-88ada64c162b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1610ed53-ac19-3c46-a729-47b8ba7bcd91" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'divider_tests.cpp' should have the file name extension &quot;.cc&quot;" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="NAMING-38" lnHash="1504" rule.header="Implementation files in C++ always have the file name extension &quot;.cc&quot;" tool="c++test" lineHash="1504" unbViolId="c6c3c285-b678-3dae-ab9f-3f0a243b2995" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7731156e-e99b-3786-b5b4-531ab5a44c96" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'divider_tests.cpp' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="5" auth="lyao" locRef="4" rule="PFO-04" lnHash="1504" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="1504" unbViolId="a44af632-5fb4-3ed6-a4b4-71e48dbb6438" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b1f8850f-7292-3b89-b483-c7b3dd0aa366" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="File 'divider_tests.cpp'  should have the &quot;.icc&quot; file name extension" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="NAMING-39" lnHash="1504" rule.header="Inline definition files always have the file name extension &quot;.icc&quot;" tool="c++test" lineHash="1504" unbViolId="d7224707-be11-33bf-bb4b-eee53cd68d8e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed900461-0416-3eb3-93e8-216f4321b2e5" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'divider_tests.cpp'" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="COMMENT-02" lnHash="1504" rule.header="Provide copyright information" tool="c++test" lineHash="1504" unbViolId="76109505-800d-3ad0-b47e-8c998093203b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="891c009f-8e6f-3d4e-82b3-b9679e98c2cb" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the copyright information at the begin of file 'divider_tests.cpp'" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="JSF-133_b" lnHash="1504" rule.header="Every source file will contain copyright information" tool="c++test" lineHash="1504" unbViolId="f78feedf-179d-3069-a81a-e5a47a2189f0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6e13dacb-7d28-3809-8d91-7e8a0d98af86" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'divider_tests.cpp'" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="COMMENT-03" lnHash="1504" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1504" unbViolId="5900920d-a090-3ffe-8f01-6a160bb4048e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0d81df86-f65c-366d-8245-854198377641" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'divider_tests.cpp'" ln="1" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="1" sev="3" auth="lyao" locRef="4" rule="JSF-133_a" lnHash="1504" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1504" unbViolId="0f391a05-b404-34cb-aaf4-9da0290be32e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ebe0334a-c57a-31a6-98e6-e0b538da7946" locEndPos="1" locType="sr" hash="-69735008" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="5" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="5" sev="2" auth="lyao" locRef="4" rule="PREPROC-09" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="9f4ffb12-3548-357d-9d8b-be5417e03302" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="29be0177-eab2-38e1-8706-b4f6b5ca2555" locEndPos="1" locType="sr" hash="-69735008" locEndLn="5" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="5" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="5" sev="2" auth="lyao" locRef="4" rule="JSF-033" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="60511a9c-fdf4-3c82-ad63-e28aea52083d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0159ccce-10bb-3a21-98db-d0c0c4d7dbe3" locEndPos="1" locType="sr" hash="-69735008" locEndLn="5" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="7" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="7" sev="3" auth="lyao" locRef="4" rule="HICPP-7_3_1-a" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="e9799dc4-b290-3e69-aafb-165fbf9b2f51" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="80ec3cd1-72c2-379f-857b-0ca68255c472" locEndPos="1" locType="sr" hash="-69735008" locEndLn="7" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="7" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="7" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M7_3_4-a" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="4273d8a9-b5f2-3d7a-a267-cd7be6e3a9a0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="07a2c1f2-1f14-3173-ab8c-d5a8a920b17b" locEndPos="1" locType="sr" hash="-69735008" locEndLn="7" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="7" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="7" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-75" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="888505a9-0f6e-340c-80f8-648a877909e2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="97741037-94fe-32e5-a1a5-b3a4cdb65e9e" locEndPos="1" locType="sr" hash="-69735008" locEndLn="7" goals="0,"/>
    <StdViol msg="'using' directive was found: namespace 'std' " ln="7" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="7" sev="2" auth="lyao" locRef="4" rule="MISRA2008-7_3_4" lnHash="316495161" rule.header="using-directives shall not be used" tool="c++test" lineHash="316495161" unbViolId="5957616d-068c-3b05-82cd-80443e54c6cb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="960410ea-9c39-36ed-a13e-145656ff2827" locEndPos="1" locType="sr" hash="-69735008" locEndLn="7" goals="0,"/>
    <StdViol msg="Do not use the macro definition 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="3" auth="lyao" locRef="4" rule="JSF-031" lnHash="633583052" rule.header="The #define pre-processor directive will only be used as part of the technique to prevent multiple inclusions of the same header file" tool="c++test" lineHash="633583052" unbViolId="0a191dc7-a296-385b-b523-3ac501906ab2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="823c29b0-0329-3eb9-80cf-20996762414f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Do not use the macro definition 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="2" auth="lyao" locRef="4" rule="MISRA2008-16_2_1_a" lnHash="633583052" rule.header="Avoid using macro definitions" tool="c++test" lineHash="633583052" unbViolId="1263b6f4-9b09-3760-8107-2ecf0039fc0f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7f5d97b8-d85e-3a51-9579-59bfa291d16a" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Do not use the macro definition 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="3" auth="lyao" locRef="4" rule="HICPP-16_1_1-a" lnHash="633583052" rule.header="Avoid using macro definitions" tool="c++test" lineHash="633583052" unbViolId="d88a460f-8e57-3ecd-85e1-58a520288fc3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="73e91e25-0734-37d5-a353-4bfef73c3f23" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Do not use the macro definition 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="3" auth="lyao" locRef="4" rule="PREPROC-01" lnHash="633583052" rule.header="Avoid using macro definitions" tool="c++test" lineHash="633583052" unbViolId="3e660449-e469-3a69-a0fe-2bba3be99a79" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9457637c-9350-3d99-906b-bcd1c83fea81" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Do not use the macro definition 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A16_0_1-d" lnHash="633583052" rule.header="Avoid using macro definitions" tool="c++test" lineHash="633583052" unbViolId="2041b841-9760-3c69-b349-436fd058ced9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="18ae9e2f-75be-396c-9516-4314472f6a8e" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="'VI' part of statement" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="4" auth="lyao" locRef="4" rule="PREPROC-04" lnHash="633583052" rule.header="Don't define part of statement" tool="c++test" lineHash="633583052" unbViolId="f7f51b7d-d5ed-3348-96ec-1d7ff652f3f0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3dca99be-ac2b-3ff1-af22-b59d0459b386" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Do not use #define to define constant: 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="2" auth="lyao" locRef="4" rule="MISRA2008-16_2_2" lnHash="633583052" rule.header="C++ macros shall only be used for: include guards, type qualifiers, or storage class specifiers" tool="c++test" lineHash="633583052" unbViolId="b97e847b-1d0a-3fe9-ba38-46dd1245932c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1ebba5bc-d9d6-3e23-ac35-559acb470f05" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Do not use #define to define constant: 'VI'" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="3" auth="lyao" locRef="4" rule="PREPROC-12" lnHash="633583052" rule.header="C++ macros shall only be used for include guards, type qualifiers, or storage class specifiers" tool="c++test" lineHash="633583052" unbViolId="80d87bfc-1938-383d-9a2c-a5ab61b97c7b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e65bcf1-41bb-377f-950f-f0156ce22241" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Not all body of macro 'VI' is enclosed in braces" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="3" auth="lyao" locRef="4" rule="PREPROC-14" lnHash="633583052" rule.header="All macros must expand into complete syntactic units" tool="c++test" lineHash="633583052" unbViolId="bf69cfb6-4efa-3354-a620-8b58900d86e3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="284b29ad-c19e-348e-b3b0-f43a05a32228" locEndPos="1" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'long long' basic numerical type" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="3" auth="lyao" locRef="4" rule="CODSTA-223" lnHash="633583052" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="633583052" unbViolId="56b203be-5dfd-3247-98c4-bc4b1c9e4c1a" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2f831f7a-d841-36bf-b292-7e01e069d69b" locEndPos="24" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'long long' basic numerical type" ln="10" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="10" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A3_9_1-b" lnHash="633583052" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="633583052" unbViolId="387ade00-3ba5-3751-a36d-6f0b249814e4" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="33f8de03-70e8-3d95-91c3-c09dd08aad1f" locEndPos="24" locType="sr" hash="-69735008" locEndLn="10" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="-808361079" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-808361079" unbViolId="baf54035-51ba-3d4b-bfce-5ff920dda769" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="41468bd3-18a6-334a-8035-a4484ca30fb3" locEndPos="1" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="-808361079" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-808361079" unbViolId="d6e82ae3-3a2d-30bc-a2fd-b3dbd135fac3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c60eb42f-56e5-36dd-8f6e-a0c54a5be47c" locEndPos="1" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Type 'DividerTest' is declared in global namespace" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="4" auth="lyao" locRef="4" rule="JSF-098" lnHash="-808361079" rule.header="Every nonlocal name, except main(), should be placed in some namespace" tool="c++test" lineHash="-808361079" unbViolId="d9bda02d-0f10-339d-b6f9-7b1a48856215" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="68c74219-d813-35cc-aa28-460423e21fa1" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Type 'DividerTest' is declared in global namespace" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M7_3_1-a" lnHash="-808361079" rule.header="The global namespace shall only contain main() and namespace declarations" tool="c++test" lineHash="-808361079" unbViolId="017e21e1-9bb1-3ebc-9dcc-96162dd56955" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7c194549-32d3-3ce4-8002-b97a0fb3fe84" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Type 'DividerTest' is declared in global namespace" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-36" lnHash="-808361079" rule.header="The global namespace shall only contain main() and namespace declarations" tool="c++test" lineHash="-808361079" unbViolId="807e9caf-b018-31f9-96d2-e387f6654887" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="42a5bfd5-c630-3ff4-8e1b-9a9b43a27d9a" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Type 'DividerTest' is declared in global namespace" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="2" auth="lyao" locRef="4" rule="MISRA2008-7_3_1" lnHash="-808361079" rule.header="The global namespace shall only contain main, namespace declarations and extern &quot;C&quot; declarations" tool="c++test" lineHash="-808361079" unbViolId="fd598317-4c3d-3adc-8311-07449d8563d0" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b8bdd933-8329-3aa1-a783-fa268311e7b1" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="The declaration of the 'DividerTest' type should be preceded by a comment that contains the '@brief' tag" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="-808361079" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-808361079" unbViolId="0737bbb1-2dc0-362c-bb75-6dc9595af43f" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6c248535-9499-3863-89f7-2866edcf78f2" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="The declaration of the 'DividerTest' type should be preceded by a comment that contains the '@brief' tag" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="-808361079" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-808361079" unbViolId="ad20605b-e532-396f-84fc-641df67c3331" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f40d8b26-6a52-3a1b-9a29-9f462b97b89c" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Class 'DividerTest' does not define any constructors" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="2" auth="lyao" locRef="4" rule="CODSTA-CPP-19" lnHash="-808361079" rule.header="Declare at least one constructor to prevent the compiler from doing so" tool="c++test" lineHash="-808361079" unbViolId="21435616-6b06-3ee5-8cc2-03dd172d6b84" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cbeb4726-b2f3-39ff-942b-f896130ea1c9" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="In the protected section of a class 'DividerTest' items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations, other" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-48" lnHash="-808361079" rule.header="In the protected section of a class items shall be declared in the following order: Constructors, Destructor, Member Functions, Member Operator Function, Enumerations and others" tool="c++test" lineHash="-808361079" unbViolId="65cbe1c9-e7f5-31da-9187-35f812a23069" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9f4de95b-c6f2-364a-93b7-ed40dc08c047" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Explicitly declare default constructor in 'DividerTest'" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="HICPP-12_5_1-a" lnHash="-808361079" rule.header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" tool="c++test" lineHash="-808361079" unbViolId="7c2eb1d4-ecc5-3d52-87cb-d7d8d70dd2bd" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5ca3a446-31d6-312a-994a-5b05b917d35e" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Explicitly declare destructor in 'DividerTest'" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="HICPP-12_5_1-a" lnHash="-808361079" rule.header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" tool="c++test" lineHash="-808361079" unbViolId="ea1ca334-0ab1-35d0-9df9-16c1fa843549" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a313c9b3-8dbe-3dbf-9d93-ebb432b1ce38" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Explicitly declare copy assignment operator in 'DividerTest'" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="HICPP-12_5_1-a" lnHash="-808361079" rule.header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" tool="c++test" lineHash="-808361079" unbViolId="229ea685-8685-3a1f-a272-3e553c5720d2" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a9ce08e4-d5f6-38fd-844c-b28aa0b4a62e" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Explicitly declare move assignment operator in 'DividerTest'" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="HICPP-12_5_1-a" lnHash="-808361079" rule.header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" tool="c++test" lineHash="-808361079" unbViolId="86493611-e256-32d6-89a1-968734b2ecb0" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4793910f-19b3-38f7-9f0e-97c44bf89bd0" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Explicitly declare copy constructor in 'DividerTest'" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="HICPP-12_5_1-a" lnHash="-808361079" rule.header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" tool="c++test" lineHash="-808361079" unbViolId="88b46795-d2d5-30da-b060-d4eacabb921c" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa2f17dd-2d18-35c5-90eb-bfcea50a1aec" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Explicitly declare move constructor in 'DividerTest'" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="HICPP-12_5_1-a" lnHash="-808361079" rule.header="Explicitly define =default or =delete special member functions of concrete classes implicitly provided by the compiler" tool="c++test" lineHash="-808361079" unbViolId="1d05362e-526f-3e87-a962-6e0b9ed4b414" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d98efc8d-e339-3682-b297-7076e88f1ce1" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Class 'DividerTest' missing assignment operator or special comment" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="MRM-04" lnHash="-808361079" rule.header="All classes should contain the assignment operator or appropriate comment" tool="c++test" lineHash="-808361079" unbViolId="db3b8587-2eac-3f04-968b-f2e71d525b13" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="10cb03bd-fc46-30ec-a2ba-b35d999dcc37" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Class 'DividerTest' missing copy constructor or special comment" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="MRM-05" lnHash="-808361079" rule.header="All classes should contain the copy constructor or appropriate comment" tool="c++test" lineHash="-808361079" unbViolId="8b89d8e8-4d3c-3b7e-88f4-8450c48e3590" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92131fb3-2571-38e7-bee9-9284dfb486d9" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Class 'DividerTest' missing assignment operator or special comment" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="MRM-47" lnHash="-808361079" rule.header="Classes containing at least one non-static member variable should declare the assignment operator or contain appropriate comment" tool="c++test" lineHash="-808361079" unbViolId="d4d454a5-2952-3a81-b3af-9d0e362b0ed2" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="da007945-5463-33b9-91f7-081a4d1ab869" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Class 'DividerTest' missing copy constructor or special comment" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="MRM-48" lnHash="-808361079" rule.header="Classes containing at least one non-static member variable should declare the copy constructor or contain appropriate comment" tool="c++test" lineHash="-808361079" unbViolId="5d81cc6e-1207-346d-ac8e-53aedc0aee5b" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8fa4c14e-93b9-3549-acb2-cd5bdf28b00f" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="All letters beside the first one in name 'DividerTest' should be lowercase" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="NAMING-40" lnHash="-808361079" rule.header="Only the first word of the name of a class, structure, namespace, enumeration, or typedef will begin with an uppercase letter" tool="c++test" lineHash="-808361079" unbViolId="452f4de8-7ddd-33f5-bf6c-2acbc474c087" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3baeb8ee-82dd-3864-a38c-156e617e3659" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="The 'DividerTest' identifier should have the 'C' prefix" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-19" lnHash="-808361079" rule.header="Hungarian notation for class declaration" tool="c++test" lineHash="-808361079" unbViolId="0b39977b-176a-3b8b-9be1-b307171d99c6" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d14bca04-5001-35c7-afb5-434d8859ca1f" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Put base class 'DividerTest' into separate file" ln="12" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="12" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-12" lnHash="-808361079" rule.header="Put classes that are used as base classes and classes that are used as member variables into separate include files" tool="c++test" lineHash="-808361079" unbViolId="b5512589-5899-3a9a-9dad-17dbdd10eaa0" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a86d65b6-faa7-3403-89bc-189eb2bd8f52" locEndPos="7" locType="sr" hash="-69735008" locEndLn="12" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="737444506" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="737444506" unbViolId="f1f56469-36ff-35ae-a7fe-66e9280e0157" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b128b7f8-42b8-3e04-8cc6-d663857caf8d" locEndPos="1" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="No single ASCII space character preceding assignment operator: '=' " ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="FORMAT-07" lnHash="737444506" rule.header="There shall be a single ASCII space character preceding assignment operators" tool="c++test" lineHash="737444506" unbViolId="ac7c7306-9452-3ed6-8d32-e442b4898792" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="41885493-21f6-3a1c-b82c-b3d7bb45f1e2" locEndPos="6" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="The definition of the 'numerators' variable should contain a braced initializer" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="737444506" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="737444506" unbViolId="be0934bd-f99d-3b5d-9f0e-6f94b3f9197c" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ba59505f-8414-3a24-890a-72c7b6d5a643" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="The definition of the 'numerators' variable should contain a braced initializer" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="737444506" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="737444506" unbViolId="7ab84b8d-e5f8-330c-881e-c3047825bdb5" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a40b1ee3-6439-3a2f-8356-18f36d66fcd0" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="The 'numerators' member variable should be preceded by a comment that contains the '@brief' tag" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="737444506" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="737444506" unbViolId="e30649ef-f55c-3641-841d-4dd34f2fbb84" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4b39f914-2806-3b2e-82c9-1a7f688b80ab" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="The 'numerators' member variable should be preceded by a comment that contains the '@brief' tag" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="737444506" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="737444506" unbViolId="0f37ba07-18fc-3bae-a9c2-e3fff5a9dc04" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9b031083-d054-3abd-80e2-347ca5a8d043" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="A private typedef for container should be used: 'numerators'" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="5" auth="lyao" locRef="4" rule="STL-01" lnHash="737444506" rule.header="Instead of trying to write the container-independent code use class encapsulation" tool="c++test" lineHash="737444506" unbViolId="8f0f4ff2-c069-33e3-92b2-21999ec97986" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b98680e8-ca21-35b9-9c46-778b705092d1" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Data members 'numerators' is declared as 'protected'" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="2" auth="lyao" locRef="4" rule="HICPP-11_1_1-b" lnHash="737444506" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="737444506" unbViolId="aa11c0ac-c282-3d18-9b98-a7038c8fd69b" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="db90f686-d938-382b-a053-9997819e08ce" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Data members 'numerators' is declared as 'protected'" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="4" auth="lyao" locRef="4" rule="JSF-067_b" lnHash="737444506" rule.header="Protected data should only be used in structs, not in classes" tool="c++test" lineHash="737444506" unbViolId="53131208-5ba8-3dba-a275-424310b76804" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f72c925-dc99-3197-ac0d-707af9451d0e" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Data members 'numerators' is declared as 'protected'" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="2" auth="lyao" locRef="4" rule="OOP-19" lnHash="737444506" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="737444506" unbViolId="8d883147-6473-3487-b475-cd2df519689e" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="58d35b4e-373c-3643-9589-2b8af118805a" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Variable 'numerators' should be declared using 'auto' specifier" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="737444506" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="737444506" unbViolId="78293de1-8f1e-3ce8-beff-78f40a9f13bc" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8a46e371-0a3a-3ac9-bf4a-1923367dd1a0" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Naming convention not followed: numerators" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="NAMING-14" lnHash="737444506" rule.header="Begin class data member names with 'its'" tool="c++test" lineHash="737444506" unbViolId="7f160d8e-9f7a-3767-b113-12f22b712a0b" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7e13ef4-b157-3da3-a90c-71abdaad0221" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="The 'numerators' identifier should have the 'm_' prefix" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-29" lnHash="737444506" rule.header="Hungarian notation for member variables" tool="c++test" lineHash="737444506" unbViolId="48015941-41d9-3a34-8297-04c6d0aee0ab" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e404a218-a64c-3ae2-8224-db0aadf89af5" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Member variable 'numerators' should be declared as private" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M11_0_1-a" lnHash="737444506" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="737444506" unbViolId="c4242629-2152-348f-b738-da86be1eb58a" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1274e600-09d4-33d3-816e-1dc4aece66ce" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Member variable 'numerators' should be declared as private" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="2" auth="lyao" locRef="4" rule="MISRA2008-11_0_1" lnHash="737444506" rule.header="Member data in non-POD class types shall be private" tool="c++test" lineHash="737444506" unbViolId="1f528d01-f8b1-3358-b89e-0e01e515049d" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bbdf1a74-2e5d-3eb8-af78-919358e50a09" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Member variable 'numerators' should be declared as private" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="OOP-48" lnHash="737444506" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="737444506" unbViolId="897c2ce6-05d2-30ab-aa9d-608283462542" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92136ebe-325e-350c-8875-62e6a50df79e" locEndPos="21" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="The suffix 'L' should not be used directly with constant '933345453464353416L'" ln="15" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="15" sev="3" auth="lyao" locRef="4" rule="PORT-17" lnHash="737444506" rule.header="Don't use 'i64' or 'L' suffixes directly" tool="c++test" lineHash="737444506" unbViolId="87f2f301-b562-3a40-8fde-09de2863cde4" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b40f6f9c-d25a-3481-9506-d0690ea543d5" locEndPos="32" locType="sr" hash="-69735008" locEndLn="15" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-1683585221" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-1683585221" unbViolId="9b377f8a-d789-3a27-9b2d-cf60d57861a7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="59098113-1aa0-39c3-bc93-386fa4cda803" locEndPos="1" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="The definition of the 'denominators' variable should contain a braced initializer" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="-1683585221" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-1683585221" unbViolId="0c471f7e-0828-3c37-a9b2-8688b30bea30" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ad244c90-8d0e-323a-bf65-4fcc61107bf4" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="The definition of the 'denominators' variable should contain a braced initializer" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="-1683585221" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-1683585221" unbViolId="fe7ca626-f287-39ea-9a18-0ad76e547cda" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="059a3b26-61b4-32ba-8bf7-b94991e2a8c1" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="The 'denominators' member variable should be preceded by a comment that contains the '@brief' tag" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="-1683585221" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-1683585221" unbViolId="21c496de-971c-3c30-a241-5207600cf479" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e4308620-3542-3f03-aa3d-ba311e362243" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="The 'denominators' member variable should be preceded by a comment that contains the '@brief' tag" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="-1683585221" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-1683585221" unbViolId="5448b288-9371-3251-afbb-7393b8d4dc99" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="70d3491b-849c-3655-be14-fc7a01449470" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="A private typedef for container should be used: 'denominators'" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="5" auth="lyao" locRef="4" rule="STL-01" lnHash="-1683585221" rule.header="Instead of trying to write the container-independent code use class encapsulation" tool="c++test" lineHash="-1683585221" unbViolId="cfe5e79f-607f-3392-be5c-4102295eda4a" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c2709d2b-99de-3f40-8872-81b000d31b50" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Data members 'denominators' is declared as 'protected'" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="2" auth="lyao" locRef="4" rule="HICPP-11_1_1-b" lnHash="-1683585221" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="-1683585221" unbViolId="b9be4f05-bf9f-35fc-9108-bb3a19ab9bf4" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d71333b6-b16e-31df-884b-8c87e191483a" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Data members 'denominators' is declared as 'protected'" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="4" auth="lyao" locRef="4" rule="JSF-067_b" lnHash="-1683585221" rule.header="Protected data should only be used in structs, not in classes" tool="c++test" lineHash="-1683585221" unbViolId="de9ea61d-e385-3536-afad-66ba2eeaf5ed" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a3e25476-f738-3057-b6e9-577541ec3875" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Data members 'denominators' is declared as 'protected'" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="2" auth="lyao" locRef="4" rule="OOP-19" lnHash="-1683585221" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="-1683585221" unbViolId="79748f8e-005d-30eb-b5fe-5ebb7c6edc1a" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9ad1172e-004c-37f9-b751-19a381d60157" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Variable 'denominators' should be declared using 'auto' specifier" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="-1683585221" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="-1683585221" unbViolId="66cfe53d-d7d3-318d-a111-2d5ae0155911" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="670bad4e-76f3-3d15-98e3-3daf9a7635c9" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Naming convention not followed: denominators" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="NAMING-14" lnHash="-1683585221" rule.header="Begin class data member names with 'its'" tool="c++test" lineHash="-1683585221" unbViolId="0e78a6d4-8d70-37b7-becd-62f89c48c676" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d8ea74d1-2c94-371b-b174-5ae83d4dcd35" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="The 'denominators' identifier should have the 'm_' prefix" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-29" lnHash="-1683585221" rule.header="Hungarian notation for member variables" tool="c++test" lineHash="-1683585221" unbViolId="33769730-c773-3b33-a697-96791b11d158" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="99e3841f-da71-33ed-91d0-90ae05312999" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Member variable 'denominators' should be declared as private" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M11_0_1-a" lnHash="-1683585221" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="-1683585221" unbViolId="dc316d0c-6be5-3607-8271-eb73d2e5c81c" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e9b4548a-f357-380c-aac7-c46262037420" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Member variable 'denominators' should be declared as private" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="2" auth="lyao" locRef="4" rule="MISRA2008-11_0_1" lnHash="-1683585221" rule.header="Member data in non-POD class types shall be private" tool="c++test" lineHash="-1683585221" unbViolId="72dcc235-0adc-30c3-9adf-9a39b6915675" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b8b432d4-fd60-32ad-84b8-8907b5c6b1d8" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Member variable 'denominators' should be declared as private" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="OOP-48" lnHash="-1683585221" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="-1683585221" unbViolId="8916526c-8302-3465-885b-f3dee06dc1da" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="729e40dd-d232-353b-b1d7-72b5fc55c3ff" locEndPos="21" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="The suffix 'L' should not be used directly with constant '978737423423423499L'" ln="16" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="16" sev="3" auth="lyao" locRef="4" rule="PORT-17" lnHash="-1683585221" rule.header="Don't use 'i64' or 'L' suffixes directly" tool="c++test" lineHash="-1683585221" unbViolId="47b233b0-1e05-3019-916b-baa0bb7b6443" locStartPos="31" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b1f5a8e4-1737-3bf7-b80d-af8ec0355d88" locEndPos="32" locType="sr" hash="-69735008" locEndLn="16" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-93806294" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-93806294" unbViolId="b0f74709-6a36-3f86-845d-4b37d1ff4160" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3f05b5a6-05d0-3068-9965-aba7ed5a09ce" locEndPos="1" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="No single ASCII space character preceding assignment operator: '=' " ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="FORMAT-07" lnHash="-93806294" rule.header="There shall be a single ASCII space character preceding assignment operators" tool="c++test" lineHash="-93806294" unbViolId="e5014a40-4be7-3f75-aedd-cfb38de02206" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="460afe79-83c0-36c2-bdde-243096af4dc9" locEndPos="6" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="The definition of the 'divisions' variable should contain a braced initializer" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="-93806294" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-93806294" unbViolId="dbcbff68-4274-385f-a13b-bc2d9456019c" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d1cb47bd-bbbf-3409-a358-dc40460b7e02" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="The definition of the 'divisions' variable should contain a braced initializer" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="-93806294" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-93806294" unbViolId="0ca207d7-2bfb-364f-9768-19cbc4664225" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a74dc45-295c-34fc-bbfa-34cf021db9f7" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="The 'divisions' member variable should be preceded by a comment that contains the '@brief' tag" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="-93806294" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-93806294" unbViolId="1fccf590-7b7e-381d-8ace-2771653ed8b8" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="353ed068-5f5c-3021-8b2f-67ab45567932" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="The 'divisions' member variable should be preceded by a comment that contains the '@brief' tag" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="-93806294" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-93806294" unbViolId="6269e86e-898b-3e2a-9380-541d40574515" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c332736e-755f-37dd-b6d8-23fce968eed2" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="A private typedef for container should be used: 'divisions'" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="5" auth="lyao" locRef="4" rule="STL-01" lnHash="-93806294" rule.header="Instead of trying to write the container-independent code use class encapsulation" tool="c++test" lineHash="-93806294" unbViolId="8ea1dcd1-329a-3ff0-8620-c0aa6306f1c7" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="57eb8e49-4064-3217-a1f7-9d7a618028e0" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Data members 'divisions' is declared as 'protected'" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="2" auth="lyao" locRef="4" rule="HICPP-11_1_1-b" lnHash="-93806294" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="-93806294" unbViolId="f06623f5-f0e1-374d-a7bc-429be88c7ed0" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9e74fb7b-d434-3f84-b312-47cb6b147677" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Data members 'divisions' is declared as 'protected'" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="4" auth="lyao" locRef="4" rule="JSF-067_b" lnHash="-93806294" rule.header="Protected data should only be used in structs, not in classes" tool="c++test" lineHash="-93806294" unbViolId="0d0eacdf-bdcd-375f-a6fd-7068f65edad5" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5c9335cb-a2ca-3249-9609-f0ef98ef2019" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Data members 'divisions' is declared as 'protected'" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="2" auth="lyao" locRef="4" rule="OOP-19" lnHash="-93806294" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="-93806294" unbViolId="a5eb11d3-3918-3b69-8024-cd515e91bdd6" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="77e1aa7c-0d7f-32af-a01a-ae5d473e2930" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Variable 'divisions' should be declared using 'auto' specifier" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="-93806294" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="-93806294" unbViolId="ebda82d2-8859-3685-ab6f-4548d0681ed4" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ea44a4c0-e819-3508-adce-1bf474d2bb20" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Naming convention not followed: divisions" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="NAMING-14" lnHash="-93806294" rule.header="Begin class data member names with 'its'" tool="c++test" lineHash="-93806294" unbViolId="347d25f4-38f1-396b-9031-6b4f151e0dc0" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1b1c8c8d-d0d4-3700-880f-270da34c5770" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="The 'divisions' identifier should have the 'm_' prefix" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-29" lnHash="-93806294" rule.header="Hungarian notation for member variables" tool="c++test" lineHash="-93806294" unbViolId="42a995ec-9dda-3477-a428-68d356d3ed8b" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a5c71f72-f009-36c8-aa67-252ca4e510d2" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Member variable 'divisions' should be declared as private" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M11_0_1-a" lnHash="-93806294" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="-93806294" unbViolId="3c09cc92-f740-3fe3-a37b-1e016d4ebc4b" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bc9e8035-b280-3e74-8f91-01d345c948ad" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Member variable 'divisions' should be declared as private" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="2" auth="lyao" locRef="4" rule="MISRA2008-11_0_1" lnHash="-93806294" rule.header="Member data in non-POD class types shall be private" tool="c++test" lineHash="-93806294" unbViolId="37cc10e8-7bf1-3eae-bb96-b4c0a6670e41" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e13ccb70-f11c-3582-8492-d29233815111" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Member variable 'divisions' should be declared as private" ln="17" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="17" sev="3" auth="lyao" locRef="4" rule="OOP-48" lnHash="-93806294" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="-93806294" unbViolId="0513cb84-61de-39eb-b420-852545580004" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="83b27c74-e26a-3854-ba22-6bceed78867a" locEndPos="21" locType="sr" hash="-69735008" locEndLn="17" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-734206963" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-734206963" unbViolId="bb7a4be5-b853-3cea-a42b-8fe5294148c9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a100dc9-12f0-3893-a531-e39206dda302" locEndPos="1" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="No single ASCII space character preceding assignment operator: '=' " ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="FORMAT-07" lnHash="-734206963" rule.header="There shall be a single ASCII space character preceding assignment operators" tool="c++test" lineHash="-734206963" unbViolId="8c2feb0a-e146-36c8-bf84-6186874841de" locStartPos="5" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="49491fa9-fda1-39f5-8b18-be781b3249b1" locEndPos="6" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="The definition of the 'remainders' variable should contain a braced initializer" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="-734206963" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-734206963" unbViolId="50bee3af-4f29-3abc-a086-bb40d3abb820" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c4e22ab0-3b42-3648-b0ea-d53bd8e88568" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="The definition of the 'remainders' variable should contain a braced initializer" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="-734206963" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-734206963" unbViolId="21dd3f6f-fc0c-3e3d-96a7-7efec1ebaf94" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="95d40799-1aec-3764-9f4d-b923faf51a6b" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="The 'remainders' member variable should be preceded by a comment that contains the '@brief' tag" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="-734206963" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-734206963" unbViolId="b8358569-d987-3696-abbf-a7f116dd0349" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dabbea6b-3655-38db-8381-ddad51d16f0f" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="The 'remainders' member variable should be preceded by a comment that contains the '@brief' tag" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="-734206963" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-734206963" unbViolId="17370a12-6c5e-3630-852d-be5c2177ccee" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="397025ee-8c77-3952-8dc7-d99afcf18ba1" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="A private typedef for container should be used: 'remainders'" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="5" auth="lyao" locRef="4" rule="STL-01" lnHash="-734206963" rule.header="Instead of trying to write the container-independent code use class encapsulation" tool="c++test" lineHash="-734206963" unbViolId="668b3893-f554-39e0-b64a-66244b220c89" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c5231382-c62d-33f7-be47-f8224c74a399" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Data members 'remainders' is declared as 'protected'" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="2" auth="lyao" locRef="4" rule="HICPP-11_1_1-b" lnHash="-734206963" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="-734206963" unbViolId="a70ba212-93ee-35a2-a138-3036f076c241" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="888e5d19-c128-3766-aaee-a16fe4346ecf" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Data members 'remainders' is declared as 'protected'" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="4" auth="lyao" locRef="4" rule="JSF-067_b" lnHash="-734206963" rule.header="Protected data should only be used in structs, not in classes" tool="c++test" lineHash="-734206963" unbViolId="3d89bc29-be34-3d6b-b288-9adafd349ad6" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f7b6f024-2442-3a51-a6c5-4075ebfa8344" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Data members 'remainders' is declared as 'protected'" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="2" auth="lyao" locRef="4" rule="OOP-19" lnHash="-734206963" rule.header="Avoid 'protected' data members" tool="c++test" lineHash="-734206963" unbViolId="3616d7dc-84e6-3a9f-9cbc-e79e5d28b223" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0643976c-e97d-3c7a-93a5-a08a824e4ed5" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Variable 'remainders' should be declared using 'auto' specifier" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="-734206963" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="-734206963" unbViolId="57828406-7244-3c70-b916-8b50c8354956" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="74d82769-f2c9-36d7-8932-f0dd3f3db910" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Naming convention not followed: remainders" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="NAMING-14" lnHash="-734206963" rule.header="Begin class data member names with 'its'" tool="c++test" lineHash="-734206963" unbViolId="d1635305-a102-385d-8832-037083220360" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5d3b7496-60df-34dc-8429-e70635dbfa6a" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="The 'remainders' identifier should have the 'm_' prefix" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-29" lnHash="-734206963" rule.header="Hungarian notation for member variables" tool="c++test" lineHash="-734206963" unbViolId="c0d60e11-c909-38d9-a483-00c711cfa148" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f396f223-3fc1-3aa3-9f12-009828adf1c0" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Member variable 'remainders' should be declared as private" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M11_0_1-a" lnHash="-734206963" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="-734206963" unbViolId="0171f3ab-1af1-310c-beeb-a95b20af566a" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8b5c0b58-06ae-3e63-81b0-97c37e4d716f" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Member variable 'remainders' should be declared as private" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="2" auth="lyao" locRef="4" rule="MISRA2008-11_0_1" lnHash="-734206963" rule.header="Member data in non-POD class types shall be private" tool="c++test" lineHash="-734206963" unbViolId="9c847164-7c7f-3a5e-b3bf-e524c32d207f" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0858605a-2050-3b95-9ec1-d0b7498485dc" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Member variable 'remainders' should be declared as private" ln="18" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="18" sev="3" auth="lyao" locRef="4" rule="OOP-48" lnHash="-734206963" rule.header="Member data in non-POD types shall be private" tool="c++test" lineHash="-734206963" unbViolId="d62bcf03-6b25-3985-9c3e-d7ae4c8c8c5f" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="54f59540-4c1f-348b-a77a-f8579483b0d1" locEndPos="21" locType="sr" hash="-69735008" locEndLn="18" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="354021186" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="354021186" unbViolId="76d9b760-ffcf-3672-a78d-335673f1df33" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3ead3bfd-44cd-34a6-86bf-1edcf69ac28f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="354021186" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="354021186" unbViolId="35f43818-b90e-363f-b479-16e79a6ea86b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6988dd09-89ba-323b-a5dc-3edaf809edca" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="354021186" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="354021186" unbViolId="0adc2662-8490-39ca-b902-0288a63d927b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="60d566e9-e7cd-3e14-9565-844b5b19b5ef" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="354021186" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="354021186" unbViolId="8ab4918f-a1f3-3811-b216-e018fac81a8f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7c72f722-7bd9-3e9f-bd95-f04f37ca4d35" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="354021186" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="354021186" unbViolId="5fd551a7-083a-395d-9c95-1e8de8cd9491" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d8a85b4c-e6d6-3a90-965c-ea86940aec1f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="354021186" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="354021186" unbViolId="580f9a6e-96fb-37b8-a714-c7e88ecd8190" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="073b755b-5dd4-3c31-8c31-1a167d68226e" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="354021186" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="354021186" unbViolId="f991be27-6911-34c0-add5-12ba9a66ca5d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a270d592-7972-3072-b519-826651e05976" locEndPos="1" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest::SetUp(void)&quot;" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="21" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="354021186" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="20" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1926945156" lang="cpp" violId="dcb00783-d6bd-3d54-b5fc-bf81b1830b59" locEndPos="0" locEndLn="21" goals="0," locStartln="20" sev="4" locRef="4" tool="c++test" lineHash="354021186" unbViolId="64b7e256-e667-3635-ac8b-06c9e02e2db5" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="354021186" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="virtual void SetUp() {" ElType="CP" rngLn="20">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest::SetUp(void)&quot;" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="21" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="354021186" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="20" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-125376696" lang="cpp" violId="b0c0dde2-e7cf-37a8-a1a0-6f1f399136fe" locEndPos="0" locEndLn="21" goals="0," locStartln="20" sev="4" locRef="4" tool="c++test" lineHash="354021186" unbViolId="f2dc3209-bcce-3ca3-8708-dba68f3f5c8e" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="354021186" ln="20" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="virtual void SetUp() {" ElType="CP" rngLn="20">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The definition of the 'SetUp' function is not preceded by a comment" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="COMMENT-04" lnHash="354021186" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="354021186" unbViolId="aa968bff-17ee-3d12-824f-c3b2fddd423c" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dfc5580a-fd6a-3730-8c6f-99ddcd3c7a9e" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The definition of the 'SetUp' function is not preceded by a comment" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="4" auth="lyao" locRef="4" rule="JSF-134" lnHash="354021186" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="354021186" unbViolId="ffa2dc9d-fbd8-34cf-99cd-95d0512fd9b4" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="42c4ce7e-53a3-3e68-9cd1-b574cfcadfea" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The name 'SetUp' should be composed only of lowercase letters" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="JSF-051" lnHash="354021186" rule.header="All letters contained in function and variable names will be composed entirely of lowercase letters" tool="c++test" lineHash="354021186" unbViolId="28d83ea9-0fde-335c-912e-5c991251b228" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="67668670-c8aa-361d-bdb6-2b34e48b5637" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The name 'SetUp' should be composed only of lowercase letters" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="NAMING-44" lnHash="354021186" rule.header="All letters contained in function and variable names will be composed entirely of lowercase letters" tool="c++test" lineHash="354021186" unbViolId="907a0905-78b3-3985-9b48-1c69354158bc" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6ab9d4a6-a8ed-36be-ad40-20a0441fbd0d" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The identifier 'SetUp' differs only by case from identifier 'Setup' declared in file 'gtest.h'" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="NAMING-45" lnHash="354021186" rule.header="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" tool="c++test" lineHash="354021186" unbViolId="968cb47e-f5d8-34a1-9a23-e7417256e4ae" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2dc7d867-d013-39aa-8b23-799827704faf" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The identifier 'SetUp' differs only by case from identifier 'Setup' declared in file 'gtest.h'" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="JSF-048" lnHash="354021186" rule.header="Identifiers will not differ by mixture of case, the underscore character, interchange of the similarly looking letters and numbers" tool="c++test" lineHash="354021186" unbViolId="7d614612-b07b-343b-a7bb-70f575246e88" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e71f6816-a332-35c9-9e85-1aac54f6b0f5" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The 'SetUp' function should be preceded by a comment that contains the '@brief' tag" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="354021186" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="354021186" unbViolId="c144b14e-f339-30c4-9b7f-dc10ac1545b3" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8312dd19-5145-3bcb-bf58-a77b82d6c130" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The 'SetUp' function should be preceded by a comment that contains the '@brief' tag" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="354021186" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="354021186" unbViolId="1d75cd29-8968-3abb-97b7-a0d88fa989da" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="78ea274f-e595-32a8-b4d1-f63892f2c2f5" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Identifier name: 'SetUp' differs only by case from identifier name: 'Setup' declared in base class" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="MISRA2008-2_10_1" lnHash="354021186" rule.header="Different identifiers shall be typographically unambiguous" tool="c++test" lineHash="354021186" unbViolId="e974ac84-f442-33e4-9dec-48636d635b89" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a605dd56-9f01-369a-8344-0eb4cdea30be" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Identifier name: 'SetUp' differs only by case from identifier name: 'Setup' declared in base class" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="HICPP-2_4_1-a" lnHash="354021186" rule.header="Different identifiers shall be typographically unambiguous" tool="c++test" lineHash="354021186" unbViolId="2b677c3a-3b62-3f3c-b3bf-c1246d193685" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b3da942d-9d7d-3828-afe0-0a4d8a6362d8" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Identifier name: 'SetUp' differs only by case from identifier name: 'Setup' declared in base class" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M2_10_1-a" lnHash="354021186" rule.header="Different identifiers shall be typographically unambiguous" tool="c++test" lineHash="354021186" unbViolId="fb1f12bc-3fc9-3cb9-9881-2f4dfbf850c5" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="705a7c7a-a51f-3749-af15-1d39f7d94ffe" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Identifier name: 'SetUp' differs only by case from identifier name: 'Setup' declared in base class" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="NAMING-47" lnHash="354021186" rule.header="Different identifiers shall be typographically unambiguous" tool="c++test" lineHash="354021186" unbViolId="4f0edee5-e60f-3421-9feb-37a58e1de4ba" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="18ece148-5b2f-339e-b538-fd1756096019" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Inline function 'SetUp' was found in source file" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-51" lnHash="354021186" rule.header="Do not define inline functions in source files" tool="c++test" lineHash="354021186" unbViolId="f8b1bc46-7852-3b5c-b167-bce089e2fca3" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="77324984-d65f-333a-9f4b-55532a5fa30d" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The 'SetUp' function should be declared with the 'override' specifier" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-05" lnHash="354021186" rule.header="Each overriding virtual function shall be declared with the override or final specifier" tool="c++test" lineHash="354021186" unbViolId="9f55f33c-2219-3793-926c-5e2f45b9d923" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a8b2ba75-c504-3396-a5e8-8f400f135551" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The 'SetUp' function should be declared with the 'override' specifier" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A10_3_2-a" lnHash="354021186" rule.header="Each overriding virtual function shall be declared with the override or final specifier" tool="c++test" lineHash="354021186" unbViolId="5e22dddc-6a49-3c67-a949-7a8077031851" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="762ba0d8-ca01-3de8-a6b0-d0af96692a19" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The 'SetUp' function should be declared with the 'override' specifier" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="HICPP-10_2_1-a" lnHash="354021186" rule.header="Each overriding virtual function shall be declared with the override or final specifier" tool="c++test" lineHash="354021186" unbViolId="2d50b4cf-aba2-3702-b68b-f2182210bf70" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4eafbfa7-b064-3ec7-9898-f690332274ef" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Return type is not placed in line before function 'SetUp'" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="FORMAT-28" lnHash="354021186" rule.header="In a function definition, the return type of the function should be written on a separate line directly above the function name" tool="c++test" lineHash="354021186" unbViolId="1f04f65c-21a0-3943-a9d1-2e55ac8cc541" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3f67bbb4-a2b5-3ed8-afb0-3ac625da283a" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Function 'SetUp' has Cyclomatic Complexity value: 1" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="5" auth="lyao" locRef="4" rule="METRICS-29" lnHash="354021186" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="354021186" unbViolId="49622b4d-bbe1-3210-951e-e10e019178b4" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="27036f56-3b25-37ae-a581-16c5d42ce5cd" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Function 'SetUp' has Essential Complexity value: 1" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="5" auth="lyao" locRef="4" rule="METRICS-33" lnHash="354021186" rule.header="Report Essential Complexity" tool="c++test" lineHash="354021186" unbViolId="62dc319c-997b-3953-9c96-756b14536474" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa7615bf-a2f5-3526-833d-9c97f6a5b765" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="The incorrect member function name SetUp was found" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="NAMING-35" lnHash="354021186" rule.header="Member function names should start with lowercase" tool="c++test" lineHash="354021186" unbViolId="624b5e86-3a11-3c24-ae85-5d3195d03cc4" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="366f6248-fe3e-3e02-a1ad-a2f907ee700e" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Function 'SetUp' is both virtual and inline" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="3" auth="lyao" locRef="4" rule="OOP-25" lnHash="354021186" rule.header="Avoid declaring virtual functions inline" tool="c++test" lineHash="354021186" unbViolId="15b122af-71ed-3538-b460-625e3c3058a2" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa2fc3ab-034a-314e-a1e8-3f8265bcfeb0" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Function 'SetUp' is empty" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_8_b" lnHash="354021186" rule.header="All functions with void return type shall have external side effect(s)" tool="c++test" lineHash="354021186" unbViolId="e1806506-6083-386e-bb71-0c182299dc1d" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7a74f280-c6d0-3eac-8b28-4e4403f07c02" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Function 'SetUp' is empty" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="4" auth="lyao" locRef="4" rule="OPT-32_b" lnHash="354021186" rule.header="Functions with void return type shall not be empty" tool="c++test" lineHash="354021186" unbViolId="ac0547fc-a702-3566-858c-a934d1c0693c" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1d8b7db4-2b6a-3a40-a985-a3093a7406eb" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <StdViol msg="Function 'SetUp' is empty" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_8-b" lnHash="354021186" rule.header="Functions with void return type shall not be empty" tool="c++test" lineHash="354021186" unbViolId="05b3b031-0cb3-3e13-bb52-cb9aa0cecec5" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a6a637ce-6e47-3f91-bc18-4824c1774b15" locEndPos="16" locType="sr" hash="-69735008" locEndLn="20" goals="0,"/>
    <DupViol msg="Duplicated function: 'virtual void SetUp ( ) {'" ln="20" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="20" sev="2" auth="lyao" locRef="4" rule="CDD-DUPM" lnHash="354021186" rule.header="Avoid function duplication" tool="c++test" lineHash="354021186" unbViolId="d1799351-5ace-3ab7-9b32-970a673e765e" locStartPos="23" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="5e9fd0bf-f24a-34be-9c55-021d4ae71472" locType="sr" locEndPos="3" urgent="true" hash="-69735008" locEndLn="21" goals="1,">
      <ElDescList>
        <ElDesc lineHash="354021186" ln="20" srcRngStartPos="23" srcRngEndPos="3" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="20" srcRngEndLn="21" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 20] Duplicated function in file 'divider_tests.cpp'" rngLn="20"/>
        <ElDesc lineHash="-1586541929" ln="23" srcRngStartPos="26" srcRngEndPos="3" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 23] Duplicated function in file 'divider_tests.cpp'" rngLn="23"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="Line is incorrectly indented" ln="21" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="21" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="987998" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="987998" unbViolId="42eca1c3-c8b6-3118-8e50-d4a3738cdd3d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b7644b9d-17d0-3a2b-9257-3068ef63f7fd" locEndPos="1" locType="sr" hash="-69735008" locEndLn="21" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="21" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="21" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="987998" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="987998" unbViolId="12c516e3-6888-3b6a-b21b-b9c6b94ffd3d" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d56aba6a-fa5d-3840-b573-b71b7ca860e4" locEndPos="3" locType="sr" hash="-69735008" locEndLn="21" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="21" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="21" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="987998" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="987998" unbViolId="fce12839-391e-322e-8deb-367df3ea79b8" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1ba57209-f6ec-37b1-9f35-acc03141bd2e" locEndPos="3" locType="sr" hash="-69735008" locEndLn="21" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="21" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="21" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="987998" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="987998" unbViolId="a6cfc5e2-270e-3dd0-9390-96c5a05cccca" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9ea9db0-62fd-3cd0-8eb6-84cd84d47b83" locEndPos="3" locType="sr" hash="-69735008" locEndLn="21" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="-1586541929" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="-1586541929" unbViolId="0d06dee3-6413-3ee0-818c-10a71ceecb46" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="80d513e3-ae59-317f-a555-8512cece9b8c" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-1586541929" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-1586541929" unbViolId="6c9099c0-8ab2-340f-8383-113b6d37b0b2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4fd27715-c458-3d17-a2ca-3b08dafacbe7" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-1586541929" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-1586541929" unbViolId="376ff0aa-5ec0-36ea-b12b-4150e105f12b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bb48ec0e-abf9-343d-818d-f2fa289232a8" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-1586541929" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-1586541929" unbViolId="eccf7860-01cc-34b9-b7ad-e2b86bca3db1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c9912372-062d-3c22-ad75-0fc4d6eaf149" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="-1586541929" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-1586541929" unbViolId="b12deab3-c5d0-3462-83bf-6dd46eae3db5" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2de729f1-eb01-369c-bb45-0f089a6c4893" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="-1586541929" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-1586541929" unbViolId="4d70a6b6-fb35-3c06-9299-5be2091c2da8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ba684bbe-6c2f-318e-becf-de2fa3709a5d" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-1586541929" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-1586541929" unbViolId="7022b639-393b-3b8e-81e5-7be5411e0d7b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dff61239-f3b4-3476-b87e-7539841f88fe" locEndPos="1" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest::TearDown(void)&quot;" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="24" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="-1586541929" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="23" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1489235793" lang="cpp" violId="0693462f-c8e9-3df4-9219-a049a66d04b5" locEndPos="0" locEndLn="24" goals="0," locStartln="23" sev="4" locRef="4" tool="c++test" lineHash="-1586541929" unbViolId="747c501c-78a6-366e-bedd-9a1a45ce1637" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-1586541929" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="virtual void TearDown() {" ElType="CP" rngLn="23">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest::TearDown(void)&quot;" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="24" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="-1586541929" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="23" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-761278051" lang="cpp" violId="42ceab90-068f-3492-b777-bc1f68b4ce6e" locEndPos="0" locEndLn="24" goals="0," locStartln="23" sev="4" locRef="4" tool="c++test" lineHash="-1586541929" unbViolId="3557766a-29fa-3117-9fd7-32ab38da9ed1" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-1586541929" ln="23" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="23" srcRngEndLn="24" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="virtual void TearDown() {" ElType="CP" rngLn="23">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The definition of the 'TearDown' function is not preceded by a comment" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="COMMENT-04" lnHash="-1586541929" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="-1586541929" unbViolId="a7c278d5-e30e-3c7e-9f57-d2d971c483ee" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ce2efce2-a79f-3f64-ac15-807150418384" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The definition of the 'TearDown' function is not preceded by a comment" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="4" auth="lyao" locRef="4" rule="JSF-134" lnHash="-1586541929" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="-1586541929" unbViolId="ed6bb2c2-18ff-375a-bd3b-d8efaabe0476" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f589899c-19e8-385b-a043-a1a975a209b8" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The name 'TearDown' should be composed only of lowercase letters" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="JSF-051" lnHash="-1586541929" rule.header="All letters contained in function and variable names will be composed entirely of lowercase letters" tool="c++test" lineHash="-1586541929" unbViolId="acb142bf-8264-3e88-a088-8c481e116cd7" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b64a91e5-7d59-35d0-a1ba-035e771cfa63" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The name 'TearDown' should be composed only of lowercase letters" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="NAMING-44" lnHash="-1586541929" rule.header="All letters contained in function and variable names will be composed entirely of lowercase letters" tool="c++test" lineHash="-1586541929" unbViolId="fffcc1bc-fc6e-3f92-8f4e-548d8bc483f9" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="781fa82c-6ec6-3412-9c0d-cb01cbac391e" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'TearDown' function should be preceded by a comment that contains the '@brief' tag" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="-1586541929" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-1586541929" unbViolId="c8f667d9-3e28-37af-965f-bfb34d6d61e7" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fb03815e-4f1e-34e7-b200-baeb1f76d8d6" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'TearDown' function should be preceded by a comment that contains the '@brief' tag" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="-1586541929" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-1586541929" unbViolId="07ea7175-c55a-30e0-a7e7-199f6d98ee3b" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f06e60f-2e43-3e48-ac71-8e260fdbeff8" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Inline function 'TearDown' was found in source file" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-51" lnHash="-1586541929" rule.header="Do not define inline functions in source files" tool="c++test" lineHash="-1586541929" unbViolId="4a5a3c64-d6cb-3717-af4b-1da7e2b934ca" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2f419412-a354-39f6-b9e0-b3064b4bbd6a" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'TearDown' function should be declared with the 'override' specifier" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-05" lnHash="-1586541929" rule.header="Each overriding virtual function shall be declared with the override or final specifier" tool="c++test" lineHash="-1586541929" unbViolId="72c947ac-528b-3cc8-a822-062ea3025a7d" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f797db23-80d3-39dd-998b-0c7dd3d19f92" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'TearDown' function should be declared with the 'override' specifier" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A10_3_2-a" lnHash="-1586541929" rule.header="Each overriding virtual function shall be declared with the override or final specifier" tool="c++test" lineHash="-1586541929" unbViolId="a59c49c0-07b3-3713-9077-84c52f3f2934" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ab016273-d48d-3c55-be16-0f327be33120" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The 'TearDown' function should be declared with the 'override' specifier" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="HICPP-10_2_1-a" lnHash="-1586541929" rule.header="Each overriding virtual function shall be declared with the override or final specifier" tool="c++test" lineHash="-1586541929" unbViolId="a813aec8-f8b1-34ad-9b80-8eec1640b58e" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c7a8dba9-20d2-309d-bcd4-e197fc08a0ef" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Return type is not placed in line before function 'TearDown'" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="FORMAT-28" lnHash="-1586541929" rule.header="In a function definition, the return type of the function should be written on a separate line directly above the function name" tool="c++test" lineHash="-1586541929" unbViolId="cef77930-3da4-3a53-909c-7721b39a17c8" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9d7469b0-54ab-3592-b3c1-712ed1f8db81" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Function 'TearDown' has Cyclomatic Complexity value: 1" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="5" auth="lyao" locRef="4" rule="METRICS-29" lnHash="-1586541929" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="-1586541929" unbViolId="c855c00f-1cd0-3d35-ba75-600c591ed47f" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5a590471-4238-31c7-ada9-7a58f8c91222" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Function 'TearDown' has Essential Complexity value: 1" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="5" auth="lyao" locRef="4" rule="METRICS-33" lnHash="-1586541929" rule.header="Report Essential Complexity" tool="c++test" lineHash="-1586541929" unbViolId="c8802484-58c0-3363-adb1-2b90740e7d7c" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="87b99525-ac73-339a-95f3-509b6d792ddd" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="The incorrect member function name TearDown was found" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="NAMING-35" lnHash="-1586541929" rule.header="Member function names should start with lowercase" tool="c++test" lineHash="-1586541929" unbViolId="9df5c21d-5496-32fc-a913-4a83070f95b0" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1fc5df3f-8e6f-302f-a5d9-3756856939f1" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Function 'TearDown' is both virtual and inline" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="3" auth="lyao" locRef="4" rule="OOP-25" lnHash="-1586541929" rule.header="Avoid declaring virtual functions inline" tool="c++test" lineHash="-1586541929" unbViolId="60cd36dc-2759-3bdb-a863-7e678e99e09d" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f1e89d2d-df1b-3eee-bf26-9dde690cffb9" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Function 'TearDown' is empty" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_8_b" lnHash="-1586541929" rule.header="All functions with void return type shall have external side effect(s)" tool="c++test" lineHash="-1586541929" unbViolId="a7803ff6-c766-3ebd-bc9b-56270496c6fb" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a3f97d3c-687d-38ab-b40c-3c120515bc38" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Function 'TearDown' is empty" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="4" auth="lyao" locRef="4" rule="OPT-32_b" lnHash="-1586541929" rule.header="Functions with void return type shall not be empty" tool="c++test" lineHash="-1586541929" unbViolId="84348c22-4652-343d-9f5e-be61a6be4a58" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b1484c75-3364-372b-978e-8b62d889e0d7" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Function 'TearDown' is empty" ln="23" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="23" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_8-b" lnHash="-1586541929" rule.header="Functions with void return type shall not be empty" tool="c++test" lineHash="-1586541929" unbViolId="5f727521-4921-38a1-9240-132f5ae8ed0a" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d156f494-6eab-39e4-812e-b3d0caabf5e3" locEndPos="16" locType="sr" hash="-69735008" locEndLn="23" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="24" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="24" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="987998" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="987998" unbViolId="f40f4041-94a1-3907-aa6d-76228114d7bf" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="817054b4-1ae2-3162-8228-1149e22ac5d7" locEndPos="1" locType="sr" hash="-69735008" locEndLn="24" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="24" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="24" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="987998" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="987998" unbViolId="941a923e-a817-3de9-9d3e-d7b3b0234507" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e1927246-57ce-3a3e-9990-07dcb0489114" locEndPos="3" locType="sr" hash="-69735008" locEndLn="24" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="24" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="24" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="987998" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="987998" unbViolId="e8fa2474-2722-338e-b6a5-ec33f6db9aa5" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5e2cb312-d2b9-3ff4-8e01-3583dbee5086" locEndPos="3" locType="sr" hash="-69735008" locEndLn="24" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="24" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="24" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="987998" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="987998" unbViolId="b69163f3-3363-39fc-b254-0faebd748bad" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5d298851-f2e5-3436-a029-e58148b349c3" locEndPos="3" locType="sr" hash="-69735008" locEndLn="24" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="884604027" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="884604027" unbViolId="518f3d40-7d1d-3b40-8180-97129fe9a5d1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56d37b18-560d-30ae-a95c-e74f596012f1" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="884604027" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="884604027" unbViolId="72b45bbd-daf2-3d92-953b-8e583b577106" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="82bcb723-e682-3b3b-a1a2-421ac2ab1833" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="884604027" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="884604027" unbViolId="001eee08-b520-34c4-8c88-02be766bb1a7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ec3a2bb8-8049-3296-93b8-cd63a4c9e4da" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="884604027" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="884604027" unbViolId="3f300d37-868f-3864-a1a7-011ccc4a2944" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8a6a9e3d-476f-36a3-91fa-094926b50ea9" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="884604027" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="884604027" unbViolId="025f88e6-5826-3e1b-a1f2-5b2f8e3cacd3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1e2f4e5f-6c97-3c46-9d62-14a4db3508e2" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="884604027" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="884604027" unbViolId="02d18b1e-29ca-3891-83e7-10cf5b166277" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="850742a0-ddf5-3ea1-b531-cc0aedd85f9f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="884604027" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="884604027" unbViolId="31478ccb-eecc-3628-a83a-3bad1d425ec0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b0cbf1f1-9af6-3091-bab4-895673c60478" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="884604027" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="884604027" unbViolId="93ce89ec-515c-3fb5-bcfc-2903d0436b3b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bc766905-3799-3a94-9e28-ebb684e3399b" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="884604027" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="884604027" unbViolId="fae46ebc-31fa-35dd-9019-b88de9c03027" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c61278e4-a3e7-3c9a-86d3-b7455f0eea00" locEndPos="1" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The definition of the 'verify' function is not preceded by a comment" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="COMMENT-04" lnHash="884604027" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="884604027" unbViolId="3786c024-3986-32be-9784-769107fbaff1" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a35c198a-d8ca-3a9d-a6f1-f26a12af88ee" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The definition of the 'verify' function is not preceded by a comment" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="4" auth="lyao" locRef="4" rule="JSF-134" lnHash="884604027" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="884604027" unbViolId="0608611e-a8fb-35e1-9d3a-549f43de1196" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fae3424c-68f3-3877-8e67-96bfe4544000" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'verify' function should be preceded by a comment that contains the '@brief' tag" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="COMMENT-14" lnHash="884604027" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="884604027" unbViolId="2c7e75b1-8d40-3167-9cda-b83482146b07" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7cd444fc-7ed6-39c0-902a-a15ad53b52fd" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'verify' function should be preceded by a comment that contains the '@brief' tag" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-a" lnHash="884604027" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="884604027" unbViolId="6919d4d0-f55d-345c-a4c7-6ac80fd56635" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8344b67f-041e-31d6-a875-982e0de2fa44" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'index' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A2_7_3-b" lnHash="884604027" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="884604027" unbViolId="ffe7eda4-ea33-3a96-837b-3f424e86f763" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="48b81afe-840f-307b-9d1d-c34f845c963b" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'index' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="COMMENT-14_b" lnHash="884604027" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="884604027" unbViolId="76b7013d-819f-3315-ae8e-c58e95199fac" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4f70e094-006f-31a3-9102-9c31324f4d68" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Inline function 'verify' was found in source file" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-51" lnHash="884604027" rule.header="Do not define inline functions in source files" tool="c++test" lineHash="884604027" unbViolId="1d70836f-b634-3d9f-a170-376b5d801791" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a21d2d3f-6e95-3716-a786-1d3fe40ebbbd" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Return type is not placed in line before function 'verify'" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="FORMAT-28" lnHash="884604027" rule.header="In a function definition, the return type of the function should be written on a separate line directly above the function name" tool="c++test" lineHash="884604027" unbViolId="73f7f2a1-033a-3ee4-8426-7d4cbea7fe8b" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b2d42051-5cff-3a54-97fc-c181b2ea5b9a" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The function 'verify' has a cost of '77' and should not be called inline" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_5-a" lnHash="884604027" rule.header="Do not inline large functions" tool="c++test" lineHash="884604027" unbViolId="b81dc292-1d00-3021-af96-9c117df11539" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="31650c15-d5e4-3b4b-8e5b-1b88d37a0adc" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Function 'verify' has 15 function calls" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="METRICS-04" lnHash="884604027" rule.header="Number of function calls within function" tool="c++test" lineHash="884604027" unbViolId="b35e30e5-42f9-32e6-b7c5-be287eb12bca" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f4056be6-a56b-33f2-a01d-4422ad4bc893" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Function 'verify' has Cyclomatic Complexity value: 3" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="5" auth="lyao" locRef="4" rule="METRICS-29" lnHash="884604027" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="884604027" unbViolId="fdcd2bc8-0a2b-3248-b643-3abff25bea9c" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="03bbeac3-db9f-3613-9477-f7a6101f37f9" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Function 'verify' has Essential Complexity value: 1" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="5" auth="lyao" locRef="4" rule="METRICS-33" lnHash="884604027" rule.header="Report Essential Complexity" tool="c++test" lineHash="884604027" unbViolId="03d5c045-50a1-3474-a96e-687ad68b089f" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e5f1eebb-cd6b-3701-8868-1eb4ef2767b4" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Naming convention not followed: verify" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="NAMING-17" lnHash="884604027" rule.header="Begin all function names with uppercase letter" tool="c++test" lineHash="884604027" unbViolId="188e5994-12d8-3636-81ee-041e3ae02e50" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9574a06f-37aa-341d-81bc-8ad225c241e8" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Function 'verify' is both virtual and inline" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="OOP-25" lnHash="884604027" rule.header="Avoid declaring virtual functions inline" tool="c++test" lineHash="884604027" unbViolId="d3aebcd2-a01a-30b6-93d1-1cc3d4f562a7" locStartPos="15" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4803f920-5d41-3742-ae6e-709c185b7cfa" locEndPos="16" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="4" auth="lyao" locRef="4" rule="MISRA2008-3_9_2" lnHash="884604027" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="884604027" unbViolId="f1f68884-1053-35cc-ad98-4a8c1f905ee5" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b45ef03b-de3f-399f-8a94-5a7c856684d7" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="MISRA-013" lnHash="884604027" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="884604027" unbViolId="7e7c78a3-0746-37c1-b676-4620671847b5" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d4adc172-fcb0-300e-9ef8-24bfd7577b24" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'int' basic numerical type" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="CODSTA-223" lnHash="884604027" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="884604027" unbViolId="9343465e-6d78-34af-91be-302eb7316371" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c45fecb6-0202-32ab-bdbf-d4662f34ac4d" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'int' basic numerical type" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A3_9_1-b" lnHash="884604027" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="884604027" unbViolId="3e4b1703-71d6-3c36-b866-282742bf8924" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="63fb2345-dbb1-34f9-af45-a2e998b63632" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_6-b" lnHash="884604027" rule.header="Use class types or typedefs to abstract scalar quantities and standard integer types" tool="c++test" lineHash="884604027" unbViolId="bc63b3fa-8e8c-37a8-af25-2ca0388ba55c" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0ab05f28-7441-3fd1-9574-9f9cff6d07cf" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="4" auth="lyao" locRef="4" rule="MISRAC2012-DIR_4_6-b" lnHash="884604027" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="884604027" unbViolId="47bbfb79-87aa-3aa7-ac62-027f1fa3e0d0" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b3893926-2aeb-3b94-a593-a3d75b9016ff" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="2" auth="lyao" locRef="4" rule="JSF-209_b" lnHash="884604027" rule.header="Typedefs that indicate size and signedness shall be used in place of the basic types" tool="c++test" lineHash="884604027" unbViolId="5a472b60-f91e-3a15-9caa-2ca67154b75c" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="77afb6b2-e434-3b90-862e-2ee8aec55f60" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="MISRA2004-6_3_b" lnHash="884604027" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="884604027" unbViolId="b3c491d9-1062-3a80-a155-17a9e95771d6" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="66e586c2-2d41-3db1-8681-b921ef5cfef3" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="4" auth="lyao" locRef="4" rule="MISRA2012-DIR-4_6_b" lnHash="884604027" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="884604027" unbViolId="01b697a1-9948-3397-ad89-d8df16dd9168" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6abc21da-9739-3e3e-a978-92f98e44b843" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="HICPP-3_5_1-b" lnHash="884604027" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="884604027" unbViolId="7c029895-b1fe-38e1-b204-fa6b09d01dea" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bc0b8c26-597b-37e5-b338-b0129db52049" locEndPos="23" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="'index' shall be declared as unsigned int or signed int" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="PORT-13" lnHash="884604027" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="884604027" unbViolId="91538358-d070-3d96-aa37-21ec01d23f48" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b0e1209e-7a7d-3999-abc9-62801e655b58" locEndPos="27" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Parameter 'index' is not validated before use" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="CERT_C-API00-a" lnHash="884604027" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="884604027" unbViolId="9d536afd-f243-3e84-9d1d-6138fab8f4a4" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dbf491b7-a13f-33ee-802c-98e1b40aafb0" locEndPos="27" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Parameter 'index' is not validated before use" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="CODSTA-86" lnHash="884604027" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="884604027" unbViolId="5ff8de1e-eada-3414-8885-2bc939628ef6" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="db1406b9-cf9d-3588-8247-34f5611892d7" locEndPos="27" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'index' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-22" lnHash="884604027" rule.header="Hungarian notation for int types" tool="c++test" lineHash="884604027" unbViolId="7117b57a-26c1-3a93-a555-0b562bcc0ca5" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5e33b7e9-3254-38bb-8e6e-271006fcc412" locEndPos="27" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'index' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-30" lnHash="884604027" rule.header="Hungarian notation for int types" tool="c++test" lineHash="884604027" unbViolId="da2c1582-f825-3c7c-9953-6ecc098f205c" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d381b8b4-1592-3271-9966-915c4af913ab" locEndPos="27" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="The 'index' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="26" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="26" sev="3" auth="lyao" locRef="4" rule="NAMING-HN-43" lnHash="884604027" rule.header="Hungarian notation for word types" tool="c++test" lineHash="884604027" unbViolId="fd4995ac-a486-305e-a7d0-8652ed89ee53" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1ec5d5b6-74ab-35d2-af05-6c54c31a08cb" locEndPos="27" locType="sr" hash="-69735008" locEndLn="26" goals="0,"/>
    <StdViol msg="Line has over 79 characters" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="FORMAT-04" lnHash="1625162035" rule.header="Physical lines should be less than eighty characters" tool="c++test" lineHash="1625162035" unbViolId="2e056598-12b6-3fe2-a062-eab3cf1e3f26" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eedfac39-f967-3d5b-8462-9ab279d6580c" locEndPos="1" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The definition of the 'f' variable should contain a braced initializer" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="1625162035" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="1625162035" unbViolId="15931020-526a-3f77-b596-66131b191b6d" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9a69b507-a355-3465-b21b-3a4b20a223e2" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The definition of the 'f' variable should contain a braced initializer" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="1625162035" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="1625162035" unbViolId="095cfb1c-2611-3bd7-a831-1fcdf171f892" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c4981d62-2370-3637-81fa-681dcea0e705" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The 'f' variable should be declared with the 'auto' type specifier" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="CODSTA-MCPP-08_a" lnHash="1625162035" rule.header="Prefer 'auto' to explicit type names in variable declarations" tool="c++test" lineHash="1625162035" unbViolId="986ef766-b015-301e-9839-0ff24e58dab4" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d4bab0e2-2235-3b6c-9943-4f76a1ff261e" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Declare local variable 'f' as const" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="CERT_C-DCL00-a" lnHash="1625162035" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1625162035" unbViolId="729796d9-2c10-32b3-9440-b6abb811997b" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eff7d10e-1f00-3dea-adc2-cc1998c157fc" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Declare local variable 'f' as const" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A7_1_1-a" lnHash="1625162035" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1625162035" unbViolId="8b5f0b14-99b3-3e25-a7c3-2285bac8a673" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75cead43-4150-3610-9f34-2c9e7024e92a" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Declare local variable 'f' as const" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="MISRA2008-7_1_1" lnHash="1625162035" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1625162035" unbViolId="348e0f2a-e3b2-332b-baf2-75bb9c298472" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9ef17c3d-f599-3e89-b612-ddd5c5d358fd" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Declare local variable 'f' as const" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-53" lnHash="1625162035" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1625162035" unbViolId="4563b85f-4ef8-3707-9443-1945c6591470" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="352cfb01-541c-3b96-940f-d723b487b4b6" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Declare local variable 'f' as const" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_2-a" lnHash="1625162035" rule.header="Declare local variable as const whenever possible" tool="c++test" lineHash="1625162035" unbViolId="e9bed1fc-9c42-34d7-adc2-dd758d9b4f4b" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="24d9d8c4-4428-3c8c-a53f-9245cee17c8c" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The 'f' variable should be commented" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="JSF-132_a" lnHash="1625162035" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="1625162035" unbViolId="910b6e84-2b41-307d-bf67-a0b5232f9ce8" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="82688e50-4bf7-3b1a-9a43-a51672288162" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The 'f' variable should be commented" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="COMMENT-05" lnHash="1625162035" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="1625162035" unbViolId="a84c48ae-0828-358e-a42d-67963464b661" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2059672b-a269-3d80-ae5f-f6fd2454a019" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Variable 'f' should be declared using 'auto' specifier" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="1625162035" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="1625162035" unbViolId="a9e614cd-c474-365d-8a01-615e181fffe5" locStartPos="13" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0d00b96d-ab3d-3336-90ed-b88feedee122" locEndPos="14" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="No single ASCII space character preceding assignment operator: '=' " ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="FORMAT-07" lnHash="1625162035" rule.header="There shall be a single ASCII space character preceding assignment operators" tool="c++test" lineHash="1625162035" unbViolId="02f53707-79b4-3887-a6ed-0c1a30e268ee" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a327922f-ec58-3797-b788-2a85f1d9c5eb" locEndPos="20" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The type 'int' of function argument number '1' does not match declared type 'unsigned long long'" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="PB-11" lnHash="1625162035" rule.header="Declared types of formal and actual parameters to functions must match" tool="c++test" lineHash="1625162035" unbViolId="d9bf31e0-db74-37b2-95bb-a7b7e8e992aa" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="09e71bab-2037-38d5-b5c9-1cea6959afbb" locEndPos="27" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="MISRA2008-5_0_4_a" lnHash="1625162035" rule.header="An implicit integral conversion shall not change the signedness of the underlying type" tool="c++test" lineHash="1625162035" unbViolId="93121cf4-4287-3086-98c1-74cbb558dd37" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1a7a32eb-1ff4-3300-a675-34f730b1d7b5" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M5_0_4-a" lnHash="1625162035" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="1625162035" unbViolId="82499790-f7e9-3edf-9d33-ff332732f846" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f2dfa3fc-a2f7-35f4-9328-8bf012bfe919" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_a" lnHash="1625162035" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="1625162035" unbViolId="555f15c2-502f-3fd4-ab90-255d094c158e" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8cfc01d5-3f50-3a98-a5d7-65f70b476f4b" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="In the 'at' function call, the type of the argument number '1' does not match the declared type 'unsigned long long'" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_g" lnHash="1625162035" rule.header="Avoid implicit conversions of function arguments" tool="c++test" lineHash="1625162035" unbViolId="de2d74a5-b7c9-3b19-ad07-37386ab77d42" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="919fcd5f-a545-38f0-bd61-2078b3bcfc03" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A4_7_1-a" lnHash="1625162035" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="1625162035" unbViolId="2126368f-d5ff-3d44-9591-77885252b8d0" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1a04ef47-40fb-353c-8698-8b97419f9217" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="PB-56" lnHash="1625162035" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="1625162035" unbViolId="347feef7-a838-3461-9d91-9e710969462a" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="64c4f17d-33dc-3b7e-b4f6-7ac69c0d521d" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="JSF-180_e" lnHash="1625162035" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="1625162035" unbViolId="651cbc11-cd9a-3152-a84d-a27c679a6e64" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7e7c811f-330a-35d8-acc5-9c17fbe9b261" locEndPos="41" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="The type 'int' of function argument number '1' does not match declared type 'unsigned long long'" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="PB-11" lnHash="1625162035" rule.header="Declared types of formal and actual parameters to functions must match" tool="c++test" lineHash="1625162035" unbViolId="943028f7-f09d-395c-8e66-970433e2fbe2" locStartPos="48" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7d2422f-821e-3356-875c-34d04531402e" locEndPos="49" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="MISRA2008-5_0_4_a" lnHash="1625162035" rule.header="An implicit integral conversion shall not change the signedness of the underlying type" tool="c++test" lineHash="1625162035" unbViolId="d9e4f7ff-3fc1-3a12-a40f-5ed2156ffccc" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e25675eb-8dbf-3cdc-8fc3-d5169d48a4db" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M5_0_4-a" lnHash="1625162035" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="1625162035" unbViolId="778a75f0-a2d0-333f-9326-85f204f1bf3e" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6068a381-3e14-3895-b84b-7673a619ed67" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_a" lnHash="1625162035" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="1625162035" unbViolId="46503263-049d-3962-af54-dc2e4a64dbf8" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1770a0d6-b59b-3c64-93a4-a489eeea7c0c" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="In the 'at' function call, the type of the argument number '1' does not match the declared type 'unsigned long long'" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_g" lnHash="1625162035" rule.header="Avoid implicit conversions of function arguments" tool="c++test" lineHash="1625162035" unbViolId="ef56549b-3fbf-3034-a700-559cfebd61a0" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e67c31f9-d90c-3a1f-9643-d354d1d7725b" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A4_7_1-a" lnHash="1625162035" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="1625162035" unbViolId="322a0ab7-51c3-3391-8407-4a331eb79724" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1a7e2585-ce0a-3cfe-b38b-cb70e8ed874b" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="3" auth="lyao" locRef="4" rule="PB-56" lnHash="1625162035" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="1625162035" unbViolId="ffc5f4f3-0e6e-3788-bb16-e136440d0c58" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1e082e1e-d23c-3e15-8ec1-5bb2976fe7e9" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="27" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="27" sev="2" auth="lyao" locRef="4" rule="JSF-180_e" lnHash="1625162035" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="1625162035" unbViolId="426d6ed5-90b8-38a3-928b-bed1927e4bb2" locStartPos="64" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a9cb18fc-83d4-391c-8f01-240a2b9bc2c9" locEndPos="65" locType="sr" hash="-69735008" locEndLn="27" goals="0,"/>
    <StdViol msg="Line has over 79 characters" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="FORMAT-04" lnHash="-1552163738" rule.header="Physical lines should be less than eighty characters" tool="c++test" lineHash="-1552163738" unbViolId="00ebc04c-687b-39cc-83cd-b84ffa66263a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bb43cacd-6b50-3781-9584-fee2585250d7" locEndPos="1" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The definition of the 'expected' variable should contain a braced initializer" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="-1552163738" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-1552163738" unbViolId="8e3d9a34-0643-393d-9a02-3361e7a4b1a8" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1dc1c0cf-81eb-355e-9eff-d178ea7a46bf" locEndPos="20" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The definition of the 'expected' variable should contain a braced initializer" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="-1552163738" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-1552163738" unbViolId="a92ea323-e8dd-3551-8d54-04ce6adeb1da" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ecc7a1d3-1ccf-3e93-bf95-2cdc18fff10f" locEndPos="20" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The 'expected' variable should be declared with the 'auto' type specifier" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="CODSTA-MCPP-08_a" lnHash="-1552163738" rule.header="Prefer 'auto' to explicit type names in variable declarations" tool="c++test" lineHash="-1552163738" unbViolId="a98d40ae-b39a-3d9b-963b-147fcc9090ad" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cd93e4fc-ba27-3fea-8c3c-b96cc35b11fa" locEndPos="20" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The 'expected' variable should be commented" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="JSF-132_a" lnHash="-1552163738" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="-1552163738" unbViolId="79adab57-94cd-3d52-a257-c929aea313f9" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="27447384-4ab4-3fda-825e-761b3b2b154d" locEndPos="20" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The 'expected' variable should be commented" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="COMMENT-05" lnHash="-1552163738" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="-1552163738" unbViolId="93a4d0bd-a686-3fe2-9524-91b7269bfbdb" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e86db92-6fcd-3eb8-8b2d-af0d491df5be" locEndPos="20" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Variable 'expected' should be declared using 'auto' specifier" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="-1552163738" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="-1552163738" unbViolId="ad91ee32-50a9-3d4f-9434-d3781d6dc9a7" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="73094c68-fb07-363b-88f2-680b0c7fb6e1" locEndPos="20" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The type 'int' of function argument number '1' does not match declared type 'unsigned long long'" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="PB-11" lnHash="-1552163738" rule.header="Declared types of formal and actual parameters to functions must match" tool="c++test" lineHash="-1552163738" unbViolId="5e6616d3-a69b-30a8-99cb-d0855663bfb0" locStartPos="45" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="88f163b8-a0bf-377e-b072-41e350a74bd5" locEndPos="46" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="MISRA2008-5_0_4_a" lnHash="-1552163738" rule.header="An implicit integral conversion shall not change the signedness of the underlying type" tool="c++test" lineHash="-1552163738" unbViolId="2e3ec3a2-22b9-3122-854a-74bc36e4a220" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="13dc8ff5-c60b-399c-bafc-3fae3efd94af" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M5_0_4-a" lnHash="-1552163738" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="-1552163738" unbViolId="65948c80-43ca-3090-8875-0530d24c14f6" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="67fa5147-2b67-3547-81fc-95da78cd942b" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_a" lnHash="-1552163738" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="-1552163738" unbViolId="dfe4f3b3-b43c-3919-915c-829f35ca3e62" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="238ded56-5ef9-358f-bcad-fb936e1dbdd9" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="In the 'at' function call, the type of the argument number '1' does not match the declared type 'unsigned long long'" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_g" lnHash="-1552163738" rule.header="Avoid implicit conversions of function arguments" tool="c++test" lineHash="-1552163738" unbViolId="915b90d3-c2d2-3ca6-a3f7-0c7926003c4f" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3e7864e0-18c8-36d7-8efd-c88928125055" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A4_7_1-a" lnHash="-1552163738" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="-1552163738" unbViolId="e9aadfee-3825-3e9e-a9ba-145aea722a0d" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="22eae607-2423-3a5e-97ed-1b9559672e72" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="PB-56" lnHash="-1552163738" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="-1552163738" unbViolId="9804501f-63a2-3d07-b353-195470ff8e75" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8bcb6c64-ef3d-3cfd-abf6-f09e5993df5d" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="JSF-180_e" lnHash="-1552163738" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="-1552163738" unbViolId="c01461c8-15b0-32de-8e08-7f3de88ab70a" locStartPos="58" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d5bc7e3a-b6bd-3c83-882d-2955050e9004" locEndPos="59" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The type 'int' of function argument number '1' does not match declared type 'unsigned long long'" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="PB-11" lnHash="-1552163738" rule.header="Declared types of formal and actual parameters to functions must match" tool="c++test" lineHash="-1552163738" unbViolId="4df347ab-06a7-3063-b756-24890009cb2b" locStartPos="66" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8159984f-7784-3514-aa05-7c23139f2157" locEndPos="67" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="MISRA2008-5_0_4_a" lnHash="-1552163738" rule.header="An implicit integral conversion shall not change the signedness of the underlying type" tool="c++test" lineHash="-1552163738" unbViolId="d60d82fb-99f4-3203-8b28-c73ae166378d" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b11580c0-c656-38d3-aeba-8ae0dded7b6d" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M5_0_4-a" lnHash="-1552163738" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="-1552163738" unbViolId="41624322-5415-367f-9aa4-50ccb0c15ef7" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e2d9068-9ab8-3ac6-b93c-f7cd45d4f3c8" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion between signed and unsigned type in the function call on argument '1' shall not be used" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_a" lnHash="-1552163738" rule.header="Avoid implicit conversions between signed and unsigned integer types" tool="c++test" lineHash="-1552163738" unbViolId="4cfbe014-0e4b-33c7-b259-ef66b4d465f1" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a1e23f02-a7ef-32ae-b0ff-30093a3588f0" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="In the 'at' function call, the type of the argument number '1' does not match the declared type 'unsigned long long'" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="MISRA2004-10_1_g" lnHash="-1552163738" rule.header="Avoid implicit conversions of function arguments" tool="c++test" lineHash="-1552163738" unbViolId="a60014fe-c03b-3fb1-afbb-d9603241188f" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f372237c-e510-31f4-8c2c-3e5616f2aea3" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A4_7_1-a" lnHash="-1552163738" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="-1552163738" unbViolId="defe5da2-f722-3468-9a1b-52d6b52d244e" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ead66bfd-e24f-384d-a4ec-eaa64c8a418e" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="3" auth="lyao" locRef="4" rule="PB-56" lnHash="-1552163738" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="-1552163738" unbViolId="5ed7f2ae-a794-3111-a733-4a3e390a0878" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7fae563-48f4-3e42-bd66-bac9f9173455" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="Implicit conversion from signed type to unsigned type in function's argument" ln="28" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="28" sev="2" auth="lyao" locRef="4" rule="JSF-180_e" lnHash="-1552163738" rule.header="Avoid implicit conversions from signed to unsigned type" tool="c++test" lineHash="-1552163738" unbViolId="6353a02b-e807-3993-a30f-59816e80ca3c" locStartPos="80" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0ea6d347-1024-30d4-bd29-8402898ef287" locEndPos="81" locType="sr" hash="-69735008" locEndLn="28" goals="0,"/>
    <StdViol msg="The definition of the 'result' variable should contain a braced initializer" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="-264498879" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-264498879" unbViolId="8ee3cdef-251c-3fd5-aef0-82e7d1d123af" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cef2ef0d-41ba-3ad0-b72f-9823f63f29e7" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="The definition of the 'result' variable should contain a braced initializer" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="-264498879" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-264498879" unbViolId="c4b48f29-5bc3-3b36-8ad3-79e99b2ec2f2" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="16009757-e8d0-3e41-a40b-81ba73a2339f" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="A tag name 'result' is reused" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="3" auth="lyao" locRef="4" rule="MISRA2004-5_4_a" lnHash="-264498879" rule.header="A tag name shall not be reused for other purpose within the program" tool="c++test" lineHash="-264498879" unbViolId="a115197a-53c8-3aed-a66c-fa90b4bf7ee3" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="558558f5-57a8-3a56-b45f-9809e85590cc" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="The 'result' variable should be declared with the 'auto' type specifier" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="2" auth="lyao" locRef="4" rule="CODSTA-MCPP-08_a" lnHash="-264498879" rule.header="Prefer 'auto' to explicit type names in variable declarations" tool="c++test" lineHash="-264498879" unbViolId="4d0f74bf-2bcd-35e3-b367-8767b92f0357" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aa53268d-a094-3ef7-a981-7e17f040ff8b" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="Variable 'result' should be declared using 'auto' specifier" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="-264498879" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="-264498879" unbViolId="03c88376-82f9-3ef3-8d11-6f626addc877" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1f4e44ad-cdcb-3e19-bed3-9f2326511373" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="The 'result' variable should be commented" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="3" auth="lyao" locRef="4" rule="JSF-132_a" lnHash="-264498879" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="-264498879" unbViolId="3f38ed00-d4fa-3c2d-a117-9d6e3ff173f2" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="262c507d-5994-3f2e-afe4-c7aa2806cc5c" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="The 'result' variable should be commented" ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="3" auth="lyao" locRef="4" rule="COMMENT-05" lnHash="-264498879" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="-264498879" unbViolId="7bee4146-69da-342e-a454-567a185b7463" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3a8378d3-3633-37f9-b8a9-49556019ed72" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="No single ASCII space character preceding assignment operator: '=' " ln="29" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="29" sev="3" auth="lyao" locRef="4" rule="FORMAT-07" lnHash="-264498879" rule.header="There shall be a single ASCII space character preceding assignment operators" tool="c++test" lineHash="-264498879" unbViolId="0cb4ec5d-51f6-3adf-a2bc-487cc1c0381b" locStartPos="19" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="00f09fc4-3680-37bf-a836-0d07f8b0f224" locEndPos="20" locType="sr" hash="-69735008" locEndLn="29" goals="0,"/>
    <StdViol msg="R-239: selector expression is constant" ln="30" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="30" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-979015143" rule.header="Parser remark" tool="c++test" lineHash="-979015143" unbViolId="ddc3d0b9-d9d1-3617-a0d3-9593c6518c5f" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c5264ab5-21f2-3308-bd0c-26d1309bd295" locEndPos="13" locType="sr" hash="-69735008" locEndLn="30" goals="0,"/>
    <StdViol msg="R-239: selector expression is constant" ln="31" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="31" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-1114737281" rule.header="Parser remark" tool="c++test" lineHash="-1114737281" unbViolId="14ae943b-d99d-3ff0-8d88-86a430a87198" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="81dcdd7c-f295-3576-9687-0b6dc4547a84" locEndPos="13" locType="sr" hash="-69735008" locEndLn="31" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="32" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="32" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="31869" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="31869" unbViolId="f5814ba8-2cb3-3ffb-a5f5-50b35e5377de" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="62981580-5c66-3538-aa4f-1ff46de2653d" locEndPos="1" locType="sr" hash="-69735008" locEndLn="32" goals="0,"/>
    <DupViol msg="Duplicated code: 'TEST_F(DividerTest, 5_DivideBy_2) {  verify(0);}'" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="CDD-DUPC" lnHash="1858869639" rule.header="Avoid code duplication" tool="c++test" lineHash="1858869639" unbViolId="a5611ecd-c24c-33a2-8145-98a48e8cc48f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="b72db557-0660-30d5-aad9-7cdf313af995" locType="sr" locEndPos="1" urgent="true" hash="-69735008" locEndLn="37" goals="1,">
      <ElDescList>
        <ElDesc lineHash="1858869639" ln="35" srcRngStartPos="0" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="35" srcRngEndLn="37" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 35] Duplicated code in file 'divider_tests.cpp'" rngLn="35"/>
        <ElDesc lineHash="-700827926" ln="39" srcRngStartPos="0" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="39" srcRngEndLn="41" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 39] Duplicated code in file 'divider_tests.cpp'" rngLn="39"/>
        <ElDesc lineHash="469592918" ln="43" srcRngStartPos="0" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="43" srcRngEndLn="45" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 43] Duplicated code in file 'divider_tests.cpp'" rngLn="43"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="1858869639" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="1858869639" unbViolId="01f4ae3d-46fc-3827-849f-f7037d9c980b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75f4cfff-af3f-319f-8ea6-cf707effefd0" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="1858869639" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1858869639" unbViolId="b192d551-ad28-33b2-9e91-294d6bac3afc" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="13a091f2-f87a-326f-9bc4-1c726d24e4e0" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="1858869639" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1858869639" unbViolId="fe0be33d-ac51-371a-8fe5-213c1a2f2593" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eba891da-e12d-3d91-8371-8c61331cde87" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="1858869639" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1858869639" unbViolId="262e45a2-9ff7-36cb-bd0e-b385932dfcec" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ba9aabc1-155f-3b2e-a833-e5c83fb33902" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="1858869639" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1858869639" unbViolId="c2742df6-4bb6-305b-a896-4724fc19bf3c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="338798c4-3a6e-394b-89e9-333d29474537" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="1858869639" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1858869639" unbViolId="865aef92-ae1c-33b9-a10f-d3f2c4775b02" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e79be498-23e5-3ed9-8134-f168fdfd34a0" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="1858869639" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="1858869639" unbViolId="9b093b2b-2d5f-3ab8-bef9-0f65d01b4a51" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ea6ce2c2-06ca-39ce-88a7-dfac807b8219" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="1858869639" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="1858869639" unbViolId="918dc009-d513-3619-9237-7ed92f426c60" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="48132809-098f-3e72-94a3-f2afaa4e7d04" locEndPos="1" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_5_DivideBy_2_Test::TestBody(void)&quot;" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="36" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="1858869639" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="35" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-421072634" lang="cpp" violId="c743bfd5-42b8-3175-a070-d53751173a67" locEndPos="0" locEndLn="36" goals="0," locStartln="35" sev="4" locRef="4" tool="c++test" lineHash="1858869639" unbViolId="dfec8ec7-96d9-3919-a19d-40c61c5699e5" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="1858869639" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, 5_DivideBy_2) {" ElType="CP" rngLn="35">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_5_DivideBy_2_Test::TestBody(void)&quot;" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="36" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="1858869639" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="35" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1824182218" lang="cpp" violId="9ac61717-813a-3d50-8f61-aceb591ceade" locEndPos="0" locEndLn="36" goals="0," locStartln="35" sev="4" locRef="4" tool="c++test" lineHash="1858869639" unbViolId="20141b1a-a6ea-33d6-b371-bff0efb4d512" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="1858869639" ln="35" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="35" srcRngEndLn="36" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, 5_DivideBy_2) {" ElType="CP" rngLn="35">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The type name 'DividerTest_5_DivideBy_2_Test' is not a unique identifier in the testing scope" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="1858869639" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="1858869639" unbViolId="2dabb331-11bd-34f0-8a8e-f4a51c6f497d" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ec740996-8f94-37ee-9fb0-3ccf67cb48f1" locEndPos="7" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="The type name 'DividerTest_5_DivideBy_2_Test' is not a unique identifier in the testing scope" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="1858869639" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="1858869639" unbViolId="8a8f6795-363b-38ed-8af2-f575e6dc84b0" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="3c95f9c7-0422-3724-a92a-c873f9c0fa23" locEndPos="7" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="The 'DividerTest_5_DivideBy_2_Test' identifier is the same as the name of a type defined in the testing scope" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="1858869639" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="1858869639" unbViolId="bb69a863-e69e-38a5-bede-291978bb9f66" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ea81fff7-9c21-39ba-bbb5-1135ed16a59a" locEndPos="35" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="The 'DividerTest_5_DivideBy_2_Test' identifier is the same as the name of a type defined in the testing scope" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="1858869639" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="1858869639" unbViolId="1dc861cb-f96f-3c44-b7ca-1287bcb9d4b9" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="af9d0ea2-de55-3d6e-af67-6e37cbc86d3f" locEndPos="35" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_4-a" lnHash="1858869639" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="1858869639" unbViolId="a6df3871-973f-3996-9168-5b2d881daf86" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="d42af34e-88cb-331d-8f07-17cd2364a96b" locEndPos="35" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_4" lnHash="1858869639" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="1858869639" unbViolId="d8ebd519-9847-3229-b931-5d20e2ead726" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="fc2bb75c-b885-3402-a61c-c61539ce8c4e" locEndPos="35" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="3" auth="lyao" locRef="4" rule="GLOBAL-ONEUSEVAR" lnHash="1858869639" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="1858869639" unbViolId="a593f88e-da80-33a6-abc9-ce96f0641d70" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="0dc22b31-9a94-376c-a40d-d9e6a6808ddb" locEndPos="35" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <DupViol msg="Duplicated function: 'TEST_F ( DividerTest , 5_DivideBy_2 ) { verify ( 0 ) ;'" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="2" auth="lyao" locRef="4" rule="CDD-DUPM" lnHash="1858869639" rule.header="Avoid function duplication" tool="c++test" lineHash="1858869639" unbViolId="838d4944-db4a-3377-8f56-5c66f69316df" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="f8aca5a6-0d3f-305c-8021-b69efc49f725" locType="sr" locEndPos="1" urgent="true" hash="-69735008" locEndLn="37" goals="1,">
      <ElDescList>
        <ElDesc lineHash="1858869639" ln="35" srcRngStartPos="34" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="35" srcRngEndLn="37" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 35] Duplicated function in file 'divider_tests.cpp'" rngLn="35"/>
        <ElDesc lineHash="-700827926" ln="39" srcRngStartPos="34" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="39" srcRngEndLn="41" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 39] Duplicated function in file 'divider_tests.cpp'" rngLn="39"/>
        <ElDesc lineHash="469592918" ln="43" srcRngStartPos="36" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="43" srcRngEndLn="45" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 43] Duplicated function in file 'divider_tests.cpp'" rngLn="43"/>
        <ElDesc lineHash="-1461991892" ln="47" srcRngStartPos="40" srcRngEndPos="1" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="47" srcRngEndLn="49" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 47] Duplicated function in file 'divider_tests.cpp'" rngLn="47"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="R-342: value copied to temporary, reference to temporary used" ln="35" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="35" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="1858869639" rule.header="Parser remark" tool="c++test" lineHash="1858869639" unbViolId="dc7f5808-b023-3e5e-945e-6180d478ca3d" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3de0b97b-0c03-3412-8be8-b4484a463f37" locEndPos="37" locType="sr" hash="-69735008" locEndLn="35" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="36" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="36" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="1428394035" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1428394035" unbViolId="c2649894-724a-3260-b054-0cf457efb9e9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0383477b-0e32-3b5e-b260-96b26e0074e5" locEndPos="1" locType="sr" hash="-69735008" locEndLn="36" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="-700827926" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="-700827926" unbViolId="99ac8d2c-9669-3e10-91d2-e9e200a04d16" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="92ce1b10-ef78-3758-9d07-26f342721e1e" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-700827926" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-700827926" unbViolId="9ab16793-1bdc-3b46-a395-f882f3a3f119" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="268731ed-0927-3c15-bfc4-72e5973e4245" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-700827926" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-700827926" unbViolId="b1940bff-3e60-3840-be81-056749733b90" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b5b38b3c-c918-3f1f-9274-c6425d092f60" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-700827926" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-700827926" unbViolId="549c571b-8500-3601-a51e-6bac05681c4a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2e151e5a-30ae-3ee5-995e-150ad28a84fd" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="-700827926" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-700827926" unbViolId="a1522625-d6b9-33f6-acf5-5ae2dc274108" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="16ea4168-0bb6-32bf-9412-7b882cdd9f5a" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="-700827926" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-700827926" unbViolId="ef5a4cf1-3d6e-3846-b40d-25ece4c00792" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e4a46c9-b747-358a-b85e-082a65c6d51a" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="-700827926" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-700827926" unbViolId="675e72af-728e-36c3-bb40-46c903348568" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="af63dce5-f832-34a3-9219-61fd5e792fa6" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="-700827926" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-700827926" unbViolId="02ae508e-5ec3-35e3-8420-aafb9a1b84ed" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bfe358b3-308a-3cda-9a95-6b95949bdfa6" locEndPos="1" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_9_DivideBy_3_Test::TestBody(void)&quot;" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="40" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="-700827926" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="39" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="630692553" lang="cpp" violId="a0cda0f0-a710-3cf1-aa61-f9a8211e461b" locEndPos="0" locEndLn="40" goals="0," locStartln="39" sev="4" locRef="4" tool="c++test" lineHash="-700827926" unbViolId="0f4a4dab-bd2f-3ebb-8a04-3693588d4f6d" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-700827926" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, 9_DivideBy_3) {" ElType="CP" rngLn="39">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_9_DivideBy_3_Test::TestBody(void)&quot;" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="40" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="-700827926" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="39" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1345608699" lang="cpp" violId="3f27cfe4-3726-3970-865b-a976577331d8" locEndPos="0" locEndLn="40" goals="0," locStartln="39" sev="4" locRef="4" tool="c++test" lineHash="-700827926" unbViolId="aa4fd9ef-29d3-37b7-b7e5-a930e3221ff8" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-700827926" ln="39" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="39" srcRngEndLn="40" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, 9_DivideBy_3) {" ElType="CP" rngLn="39">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The type name 'DividerTest_9_DivideBy_3_Test' is not a unique identifier in the testing scope" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="-700827926" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-700827926" unbViolId="8f78c3f1-3f5f-3145-b5cc-79aeba9cb5f0" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="227eca99-344c-3976-8955-5692b670bdaa" locEndPos="7" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="The type name 'DividerTest_9_DivideBy_3_Test' is not a unique identifier in the testing scope" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="-700827926" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-700827926" unbViolId="fd222a3a-bdce-30e6-91b7-81dfcee47db8" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="937f599a-3f14-30c6-92ef-4fdf44452e88" locEndPos="7" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="The 'DividerTest_9_DivideBy_3_Test' identifier is the same as the name of a type defined in the testing scope" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="-700827926" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-700827926" unbViolId="4f901e62-0ed8-382e-82de-89d34989d1e7" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="f8c7449a-3155-35a1-8631-7915c6303853" locEndPos="35" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="The 'DividerTest_9_DivideBy_3_Test' identifier is the same as the name of a type defined in the testing scope" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="-700827926" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-700827926" unbViolId="878dc317-ed03-3fab-9ce4-1315a099d6c9" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="9ae9c0a4-77cb-32d4-88f1-44e7af33e29c" locEndPos="35" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_4-a" lnHash="-700827926" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-700827926" unbViolId="775bd8e4-5ac8-3c09-999b-cb04d8da1562" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e39fd755-b655-3488-8fb2-0782400c9f55" locEndPos="35" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_4" lnHash="-700827926" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-700827926" unbViolId="a3a6cdfc-9054-3aa4-b644-2fde1c2413a6" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="68cec7dc-2014-33c2-833e-8947ca647c0d" locEndPos="35" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="3" auth="lyao" locRef="4" rule="GLOBAL-ONEUSEVAR" lnHash="-700827926" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-700827926" unbViolId="d175dc76-b197-372d-a399-4ed8c5f640e8" locStartPos="34" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e61c1ed2-deda-3004-94a5-2b8b7d19dd7d" locEndPos="35" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="R-342: value copied to temporary, reference to temporary used" ln="39" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="39" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-700827926" rule.header="Parser remark" tool="c++test" lineHash="-700827926" unbViolId="241a6ced-7d4f-3aec-9013-6d3727315712" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="807e0ab0-b1ad-3275-bfe0-5a2a2e9361b7" locEndPos="37" locType="sr" hash="-69735008" locEndLn="39" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="40" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="40" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="1428394996" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1428394996" unbViolId="d5c99389-1dcd-3fa7-83c5-56e62c1ead01" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="58ca758e-ff9f-3486-8a40-309bf51f2307" locEndPos="1" locType="sr" hash="-69735008" locEndLn="40" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="469592918" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="469592918" unbViolId="23c050a1-7f31-36db-990e-0c68abcea26d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ebc5d598-3bcf-3963-8b4f-756e8e8c4c5f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="469592918" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="469592918" unbViolId="f995eb85-03a0-378a-a0df-6dceeae751cb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f83b5d67-7a60-3fad-93dc-7aa7c1ec492a" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="469592918" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="469592918" unbViolId="49aee841-75f0-31e4-8f13-0d47fcae25d2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="68206c86-ffc5-31f4-a0ec-01165eff9a19" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="469592918" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="469592918" unbViolId="ca939a59-eafd-3934-a23a-38e5ddef7b17" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7345f5c9-3d4f-316f-9323-a6c435219d98" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="469592918" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="469592918" unbViolId="eaeb7ec3-6d85-3507-b4c1-4aa3b0d014ef" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fb55bd7e-a3ef-3ce3-8196-f004f8b9bdfd" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="469592918" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="469592918" unbViolId="1e149cb7-286f-360e-a359-abc317b23164" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="af095e94-f396-3566-8293-ad50200b9762" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="469592918" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="469592918" unbViolId="755509bc-9e7f-3aba-8171-f3c751e9aae1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="394e0249-ad75-344b-957f-be9b07ba08f7" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="469592918" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="469592918" unbViolId="d35bdb21-b1dd-34ef-8958-621288afa67f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="21b50771-57c8-30a7-a2c8-5069c75d4036" locEndPos="1" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_17_DivideBy_19_Test::TestBody(void)&quot;" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="44" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="469592918" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="43" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-713686027" lang="cpp" violId="2a02fca2-57da-374e-a7c3-611007017fce" locEndPos="0" locEndLn="44" goals="0," locStartln="43" sev="4" locRef="4" tool="c++test" lineHash="469592918" unbViolId="a7e75279-617f-3a12-9770-bc2c8c4f8796" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="469592918" ln="43" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="43" srcRngEndLn="44" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, 17_DivideBy_19) {" ElType="CP" rngLn="43">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_17_DivideBy_19_Test::TestBody(void)&quot;" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="44" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="469592918" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="43" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1596603705" lang="cpp" violId="87edd0f3-d4de-3105-a9a0-ece1ff26014a" locEndPos="0" locEndLn="44" goals="0," locStartln="43" sev="4" locRef="4" tool="c++test" lineHash="469592918" unbViolId="fd774a65-c1a2-3020-be63-e2f389936bf7" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="469592918" ln="43" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="43" srcRngEndLn="44" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, 17_DivideBy_19) {" ElType="CP" rngLn="43">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The type name 'DividerTest_17_DivideBy_19_Test' is not a unique identifier in the testing scope" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="469592918" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="469592918" unbViolId="a452c69c-4fb7-38f9-b62a-25b071b444c7" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="cb9b55aa-2ed6-3ce1-8bfd-e647896c567e" locEndPos="7" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="The type name 'DividerTest_17_DivideBy_19_Test' is not a unique identifier in the testing scope" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="469592918" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="469592918" unbViolId="7a042393-e3cb-368c-9336-0c395565e1d4" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="1a6422ba-6f2d-320c-819e-ad6977cd49e3" locEndPos="7" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="The 'DividerTest_17_DivideBy_19_Test' identifier is the same as the name of a type defined in the testing scope" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="469592918" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="469592918" unbViolId="3d1cc925-f909-3c4c-af49-0040a28efcc5" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="c4cc5f1b-b81d-37ca-8930-e8d8d54c7cfe" locEndPos="37" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="The 'DividerTest_17_DivideBy_19_Test' identifier is the same as the name of a type defined in the testing scope" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="469592918" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="469592918" unbViolId="0d241d97-fc68-3e38-8224-7bd2eb4d7b32" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e2fcc0a2-b9fa-34e6-9a08-d62d5b9e9817" locEndPos="37" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_4-a" lnHash="469592918" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="469592918" unbViolId="90bc2d21-2eee-33f0-b32a-c0286c65d49f" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="7aca1ac2-1a1a-3d72-aa48-8d18f7831a69" locEndPos="37" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_4" lnHash="469592918" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="469592918" unbViolId="bc58e65c-2639-3a6f-8bae-106eb7e36851" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="a724155c-d5d4-3d0a-9f2e-b166ceaf98d1" locEndPos="37" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="3" auth="lyao" locRef="4" rule="GLOBAL-ONEUSEVAR" lnHash="469592918" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="469592918" unbViolId="18b6b250-2a11-3d3b-83c5-65fb761dbdac" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="86b7e623-4dc8-399a-871d-87074969edc2" locEndPos="37" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="R-342: value copied to temporary, reference to temporary used" ln="43" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="43" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="469592918" rule.header="Parser remark" tool="c++test" lineHash="469592918" unbViolId="f47feafb-7a45-3c47-8839-595508d5db4b" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="85386b63-a4bc-3909-a825-417c45208334" locEndPos="37" locType="sr" hash="-69735008" locEndLn="43" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="44" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="44" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="1428395957" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1428395957" unbViolId="5bc215c2-ca48-3637-8585-03f63feac829" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cacf3c12-24c1-3a61-84bd-245554ced071" locEndPos="1" locType="sr" hash="-69735008" locEndLn="44" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="44" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="44" sev="3" auth="lyao" locRef="4" rule="JSF-151" lnHash="1428395957" rule.header="Numeric values in code will not be used; symbolic values will be used instead" tool="c++test" lineHash="1428395957" unbViolId="863faefa-da29-33c9-8645-cfe49a32eb93" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1778f5cd-670d-34a8-bf51-2fbe01e3d31f" locEndPos="10" locType="sr" hash="-69735008" locEndLn="44" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="44" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="44" sev="3" auth="lyao" locRef="4" rule="CODSTA-26" lnHash="1428395957" rule.header="Avoid magic numbers" tool="c++test" lineHash="1428395957" unbViolId="ba3ddf97-1eb9-3289-8a4d-ce2dd5bbf227" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ab60bba1-b292-347a-a468-90bc69753ca1" locEndPos="10" locType="sr" hash="-69735008" locEndLn="44" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="44" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="44" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A5_1_1-a" lnHash="1428395957" rule.header="Avoid magic numbers" tool="c++test" lineHash="1428395957" unbViolId="7fd66000-5da8-335f-82c0-977ee2e83edb" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9dabea47-0a10-3a75-be22-c407446feb0e" locEndPos="10" locType="sr" hash="-69735008" locEndLn="44" goals="0,"/>
    <StdViol msg="Literal constant '2' is used" ln="44" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="44" sev="3" auth="lyao" locRef="4" rule="HICPP-5_1_1-a" lnHash="1428395957" rule.header="Avoid magic numbers" tool="c++test" lineHash="1428395957" unbViolId="b120b665-04d7-3cd5-84bd-13ce4b4163e0" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="259d4718-904f-3236-8cf4-360db1a2c2b3" locEndPos="10" locType="sr" hash="-69735008" locEndLn="44" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="-1461991892" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="-1461991892" unbViolId="fc12f454-f6dd-3214-9bff-adb477e4c3cf" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a2de532c-0986-37c1-b5b8-0bc9d465249f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-1461991892" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-1461991892" unbViolId="7e524d72-30e4-3c53-88e1-e0a61bccb531" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4c1b208e-004b-3873-bf55-d499534fc045" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-1461991892" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-1461991892" unbViolId="bcd48390-db0c-39f0-801c-29e151c2dd25" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="89382990-02b9-304f-b772-dafa328bef2b" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-1461991892" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-1461991892" unbViolId="2639dc3e-775b-3383-9b65-a3e6890b9ccd" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4ecf5ef1-28b7-321d-87f9-ecf7e8914807" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="-1461991892" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-1461991892" unbViolId="8e564599-4881-3edf-bab5-154ec0078125" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ee075481-078e-3a60-ab12-db8a609b7ffc" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="-1461991892" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-1461991892" unbViolId="ff9af895-6f1a-3d71-8f2c-5709ded93793" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8830687a-3057-3c1d-83c0-be2d2445ffe2" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="-1461991892" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-1461991892" unbViolId="535c9fbf-abdd-3551-86c9-d846185a7784" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7a08d345-12a6-3a39-bc11-15e53e5ee79f" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="-1461991892" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-1461991892" unbViolId="670d9f1b-1503-376e-bd86-24aa5f627b98" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f35f79a-1b85-3ea8-919d-97128e097ac6" locEndPos="1" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_Long_DivideBy_Long_Test::TestBody(void)&quot;" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="48" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="-1461991892" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="47" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="1158166347" lang="cpp" violId="2723e1b8-b0b6-3be3-b7a5-9906bd66fe8f" locEndPos="0" locEndLn="48" goals="0," locStartln="47" sev="4" locRef="4" tool="c++test" lineHash="-1461991892" unbViolId="231859a5-0974-3ce1-88ee-f5749855b12d" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-1461991892" ln="47" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="47" srcRngEndLn="48" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, Long_DivideBy_Long) {" ElType="CP" rngLn="47">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_Long_DivideBy_Long_Test::TestBody(void)&quot;" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="48" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="-1461991892" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="47" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-816576121" lang="cpp" violId="3394c98d-904a-317c-b722-14c9c695aba2" locEndPos="0" locEndLn="48" goals="0," locStartln="47" sev="4" locRef="4" tool="c++test" lineHash="-1461991892" unbViolId="03fc929a-de32-3ffa-9a26-3dc7ef122efa" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-1461991892" ln="47" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="47" srcRngEndLn="48" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, Long_DivideBy_Long) {" ElType="CP" rngLn="47">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The type name 'DividerTest_Long_DivideBy_Long_Test' is not a unique identifier in the testing scope" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="-1461991892" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-1461991892" unbViolId="e5f40968-11d9-3e90-9990-3ee625015eb7" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="49a42c70-7f9f-366d-b358-a845d9895524" locEndPos="7" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="The type name 'DividerTest_Long_DivideBy_Long_Test' is not a unique identifier in the testing scope" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="-1461991892" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-1461991892" unbViolId="3b13492e-0c77-3667-b5fc-bc8d65da2395" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e07a7045-c98f-31ae-8dcb-027ceb68db55" locEndPos="7" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="R-342: value copied to temporary, reference to temporary used" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-1461991892" rule.header="Parser remark" tool="c++test" lineHash="-1461991892" unbViolId="2b1e2acf-9007-32fb-8eec-56227b279864" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="59410ec0-4b2b-3d72-8f1d-269786ebaa4c" locEndPos="37" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="The 'DividerTest_Long_DivideBy_Long_Test' identifier is the same as the name of a type defined in the testing scope" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="-1461991892" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-1461991892" unbViolId="95297d96-5a29-3c40-8d70-fd9f574018e3" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="c6bfe8f2-6dcb-3f5c-8eab-094a67ee8fda" locEndPos="41" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="The 'DividerTest_Long_DivideBy_Long_Test' identifier is the same as the name of a type defined in the testing scope" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="-1461991892" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-1461991892" unbViolId="eef47411-6863-38b5-9700-07c29c424a05" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="2a723af7-ff6b-300d-bba5-c2c55d5e945a" locEndPos="41" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_4-a" lnHash="-1461991892" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-1461991892" unbViolId="5848c9b3-1980-30b6-8347-278effe43963" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ad3cd02a-ca36-33f3-8caf-c6854238cc3f" locEndPos="41" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_4" lnHash="-1461991892" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-1461991892" unbViolId="54a674e7-155d-37cb-a3f5-c8ead2a558f5" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="69ed1c05-ec85-363c-b131-8d8f3423e721" locEndPos="41" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="47" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="47" sev="3" auth="lyao" locRef="4" rule="GLOBAL-ONEUSEVAR" lnHash="-1461991892" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-1461991892" unbViolId="6677ad7e-8df9-3ac9-80c1-030b4e5c3219" locStartPos="40" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="1cb374e8-9880-3a8e-a6f2-89b0f328d2f6" locEndPos="41" locType="sr" hash="-69735008" locEndLn="47" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="48" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="48" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="1428396918" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1428396918" unbViolId="c12b8fae-cde0-3c4c-b832-2c7a13d976a7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="743e4ef1-8241-3353-a5b1-6295013b3438" locEndPos="1" locType="sr" hash="-69735008" locEndLn="48" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="48" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="48" sev="3" auth="lyao" locRef="4" rule="JSF-151" lnHash="1428396918" rule.header="Numeric values in code will not be used; symbolic values will be used instead" tool="c++test" lineHash="1428396918" unbViolId="4509a9b4-cfe7-3e05-afdf-ccbe7d125174" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f41f8eb1-9dcf-3e3c-ad81-6da1be4e872a" locEndPos="10" locType="sr" hash="-69735008" locEndLn="48" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="48" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="48" sev="3" auth="lyao" locRef="4" rule="CODSTA-26" lnHash="1428396918" rule.header="Avoid magic numbers" tool="c++test" lineHash="1428396918" unbViolId="91a1a2ff-2b22-3ca8-8237-3ca8e5b714f7" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="345d7421-d88a-338b-8f0e-787dcf618504" locEndPos="10" locType="sr" hash="-69735008" locEndLn="48" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="48" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="48" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A5_1_1-a" lnHash="1428396918" rule.header="Avoid magic numbers" tool="c++test" lineHash="1428396918" unbViolId="b5f971e7-19c4-3409-a5b9-b344784b4c8a" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d8333f75-1fe1-3e01-84d4-7043700e8542" locEndPos="10" locType="sr" hash="-69735008" locEndLn="48" goals="0,"/>
    <StdViol msg="Literal constant '3' is used" ln="48" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="48" sev="3" auth="lyao" locRef="4" rule="HICPP-5_1_1-a" lnHash="1428396918" rule.header="Avoid magic numbers" tool="c++test" lineHash="1428396918" unbViolId="02103dc3-2812-31c0-a34d-e5a9ccf04952" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="08789f23-6015-31de-8657-a11d4a1f2622" locEndPos="10" locType="sr" hash="-69735008" locEndLn="48" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="METRICS-19" lnHash="-2042871000" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="-2042871000" unbViolId="1504fb78-1802-3739-ac55-29ae2dcb8327" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="20ae6b85-95d1-3290-9eff-b5a2cf89eb59" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-2042871000" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2042871000" unbViolId="e6e2f14c-87db-3121-b67e-3b2681ca380c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d9a41bc6-ecf7-3451-b6b1-3082712f2faa" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-2042871000" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2042871000" unbViolId="cf526f32-d29b-334e-a831-b46f262a9ac2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ebd9f480-e020-3815-8878-109a3d9ae7e3" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-2042871000" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2042871000" unbViolId="a3fb0fdb-af25-3d95-8db7-c2199efa5734" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="37b3d114-6981-3b73-835b-b3f2c0f83644" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="-2042871000" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-2042871000" unbViolId="d494acff-cd05-3f86-8e5a-f38496784d74" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="55a9461a-6be6-3d74-bcb1-51dd0599e619" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="-2042871000" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-2042871000" unbViolId="ae88ee4c-f684-30df-92a0-c57e97f85995" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f86c0bd6-a5be-3d03-8e25-be9a8bc5c407" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="-2042871000" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-2042871000" unbViolId="b9d52609-857b-3f31-8329-43c85b2843e3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a9d173c4-edee-340d-ae9a-485fa5707b31" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="-2042871000" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-2042871000" unbViolId="ab56a7c3-402f-3ae0-b2d1-cb030f7ecbe7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bd8ede65-91b4-3756-b6c6-fe27ad944d36" locEndPos="1" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_DivisionByZero_Test::TestBody(void)&quot;" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="52" rule="BD-PB-UCMETH" FirstElSrcRngStartPos="0" lnHash="-2042871000" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="51" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="71542471" lang="cpp" violId="fd423cf9-b2d7-3ab6-908e-eea6a69336f4" locEndPos="0" locEndLn="52" goals="0," locStartln="51" sev="4" locRef="4" tool="c++test" lineHash="-2042871000" unbViolId="33ec6e63-4d87-353f-92f0-c16ee1aa38ac" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-2042871000" ln="51" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="51" srcRngEndLn="52" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, DivisionByZero) {" ElType="CP" rngLn="51">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <FlowViol msg="Unreachable method: &quot;virtual void DividerTest_DivisionByZero_Test::TestBody(void)&quot;" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" ruleSAFMsg="Unreachable method header" FirstElSrcRngEndPos="0" auth="lyao" FirstElSrcRngEndLn="52" rule="HICPP-1_2_1-h" FirstElSrcRngStartPos="0" lnHash="-2042871000" ruleSCSCMsg="Unreachable method header" FirstElSrcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" rule.header="Avoid unreachable methods" FirstElSrcRngStartln="51" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.flow" id="-1910532085" lang="cpp" violId="58b33307-f242-3cad-afd7-86f77a6afcfc" locEndPos="0" locEndLn="52" goals="0," locStartln="51" sev="4" locRef="4" tool="c++test" lineHash="-2042871000" unbViolId="08132c82-13dc-3731-89d8-cdfa33a0b1c8" locType="sr" hash="-69735008" causeLocRef="4">
      <Props/>
      <ElDescList>
        <ElDesc lineHash="-2042871000" ln="51" srcRngStartPos="0" srcRngEndPos="0" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="51" srcRngEndLn="52" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="TEST_F(DividerTest, DivisionByZero) {" ElType="CP" rngLn="51">
          <Anns>
            <Ann msg="Unreachable method header" kind="cause"/>
            <Ann msg="Unreachable method header" kind="point"/>
          </Anns>
        </ElDesc>
      </ElDescList>
    </FlowViol>
    <StdViol msg="The type name 'DividerTest_DivisionByZero_Test' is not a unique identifier in the testing scope" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="-2042871000" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-2042871000" unbViolId="58d15862-57d3-380e-b4d5-957de792da41" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="87bbe7d8-e6e4-3c8a-b1ab-5506c4191001" locEndPos="7" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="The type name 'DividerTest_DivisionByZero_Test' is not a unique identifier in the testing scope" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="-2042871000" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-2042871000" unbViolId="4a13f467-b449-3d23-98d1-e436c1092fab" locStartPos="6" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="49308a97-504e-3405-90b7-7bfdd0a6047b" locEndPos="7" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="The 'DividerTest_DivisionByZero_Test' identifier is the same as the name of a type defined in the testing scope" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-5_7_a" lnHash="-2042871000" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-2042871000" unbViolId="f0c99b16-6181-3338-9c83-e41b89617e90" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="7d4522af-4bd4-3936-a619-b601a24a0c0c" locEndPos="37" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="The 'DividerTest_DivisionByZero_Test' identifier is the same as the name of a type defined in the testing scope" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_5_7-a" lnHash="-2042871000" rule.header="A tag name shall be a unique identifier" tool="c++test" lineHash="-2042871000" unbViolId="60115294-154e-3daa-85b3-f6129bd0aad4" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e733a09f-9fc8-36cc-b36d-cbe488bf40d0" locEndPos="37" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M0_1_4-a" lnHash="-2042871000" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-2042871000" unbViolId="69ff80d5-072f-3e09-ae0a-21eb488e1525" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ce19ad20-3e48-3357-a76d-89643cf84eb3" locEndPos="37" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_4" lnHash="-2042871000" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-2042871000" unbViolId="2726a1db-eb1b-3f50-b2d8-41fe686301af" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="df9cade6-eee9-3d0c-b24e-2b561d119b92" locEndPos="37" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="The 'test_info_' variable has only one use" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="3" auth="lyao" locRef="4" rule="GLOBAL-ONEUSEVAR" lnHash="-2042871000" rule.header="A project shall not contain non-volatile POD variables having only one use" tool="c++test" lineHash="-2042871000" unbViolId="eaf80527-3bd3-33e9-92d6-680e217f7339" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="6baa94be-b511-34c1-81e8-a4e56cfccc03" locEndPos="37" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="R-342: value copied to temporary, reference to temporary used" ln="51" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="51" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-2042871000" rule.header="Parser remark" tool="c++test" lineHash="-2042871000" unbViolId="d5591931-62fe-3a46-bc53-7692b79b169c" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6c49e8cd-f688-315f-839e-476de513ca5c" locEndPos="37" locType="sr" hash="-69735008" locEndLn="51" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-835499660" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-835499660" unbViolId="fd4cfb0c-5e1a-3b33-b0a8-7fadad30895a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d6658932-d58d-33d0-bbb8-2a621f36ff64" locEndPos="1" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="The definition of the 'd' variable should contain a braced initializer" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A8_5_2-a" lnHash="-835499660" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-835499660" unbViolId="8fc31472-454c-3c74-8549-ec5710db8b81" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="41a85ebb-f450-3d28-b4bc-a6a9d420a2f7" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="The definition of the 'd' variable should contain a braced initializer" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="CODSTA-MCPP-38" lnHash="-835499660" rule.header="Braced-initialization {}, without equals sign, shall be used for variable initialization" tool="c++test" lineHash="-835499660" unbViolId="eef39434-32ac-3065-b7d2-d47270a487a7" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e1f8598e-611b-399a-89da-e120a22a5327" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable &quot;d&quot; should be declared as locally as possible" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="2" auth="lyao" locRef="4" rule="MISRA2008-3_4_1_a" lnHash="-835499660" rule.header="An identifier declared to be an object or type shall be defined in a block that minimizes its visibility" tool="c++test" lineHash="-835499660" unbViolId="4e10267d-73c4-3f11-9a3c-dc8d4267f253" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56095193-657e-3872-adbe-5775a7f7c73b" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable &quot;d&quot; should be declared as locally as possible" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-M3_4_1-a" lnHash="-835499660" rule.header="Declare variables as locally as possible" tool="c++test" lineHash="-835499660" unbViolId="5534b068-dcad-384f-b245-daa1f45cad42" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c55cf7f3-bbb9-389e-a35a-0e515ff34169" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable &quot;d&quot; should be declared as locally as possible" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="4" auth="lyao" locRef="4" rule="JSF-136_b" lnHash="-835499660" rule.header="Declarations of local variables should be at the smallest feasible scope" tool="c++test" lineHash="-835499660" unbViolId="ce44bdec-50a3-3888-bfb0-a1d92440b382" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a548e3ff-caa6-32c1-aac0-a1a575c7f64b" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable &quot;d&quot; should be declared as locally as possible" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="OPT-01" lnHash="-835499660" rule.header="Declare variables as locally as possible" tool="c++test" lineHash="-835499660" unbViolId="0874ecfb-0df9-3430-ac25-1a636f81d322" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7c6c5345-a7e9-36e5-aa2e-a7bef89223f4" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable &quot;d&quot; should be declared as locally as possible" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="CERT_C-DCL19-a" lnHash="-835499660" rule.header="Declare variables as locally as possible" tool="c++test" lineHash="-835499660" unbViolId="92822c26-0f1f-3a1a-a977-d06287f0d705" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3ed1304a-a597-31b0-9c76-ea5b53d7232b" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable &quot;d&quot; should be declared as locally as possible" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="HICPP-6_4_1-a" lnHash="-835499660" rule.header="Declare variables as locally as possible" tool="c++test" lineHash="-835499660" unbViolId="efe018bf-7a2d-328f-b414-8d47a5fb0186" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="246e570c-8f7c-3046-b6b3-5550e2ec8e56" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="The 'd' variable should be commented" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="JSF-132_a" lnHash="-835499660" rule.header="Each variable declaration will be commented" tool="c++test" lineHash="-835499660" unbViolId="02826764-e87f-3131-8e5f-704e9c8a043f" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c686e967-f556-3f1f-81c8-48164c6b0fa4" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="The 'd' variable should be commented" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="COMMENT-05" lnHash="-835499660" rule.header="Each variable declaration should be commented" tool="c++test" lineHash="-835499660" unbViolId="c49923de-1ca8-3087-8721-fd2b9e59fc79" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c2d2ec54-1ab3-38b8-a948-b29482097d6b" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Variable 'd' should be declared using 'auto' specifier" ln="52" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="52" sev="3" auth="lyao" locRef="4" rule="HICPP-7_1_8-a" lnHash="-835499660" rule.header="Use auto id = expr when declaring a variable that is the same type as the initializer function call" tool="c++test" lineHash="-835499660" unbViolId="0b42caf1-49f5-3812-8bec-1ba73b8b4c01" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="775e45c5-b328-3dfe-9c3d-d38aab467d6c" locEndPos="12" locType="sr" hash="-69735008" locEndLn="52" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-637878442" unbViolId="d277010e-15aa-3c06-bed1-c98abfa6b62a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c923ce53-58ba-357b-a1d8-84a8c29dc867" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-637878442" unbViolId="709939f2-2f5c-3d62-8353-06157bf065e2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4c8df8c4-2b56-3435-9a4e-6586a6ca01a0" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-637878442" unbViolId="d2bf9177-2547-3ac3-8cc1-f63e4bfde5b8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9b5c65c9-509f-3568-8bb2-75bcb764d3c5" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-637878442" unbViolId="1cc34514-b305-3728-84c4-c1968a508ef1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e4e4dbdd-33b7-3edf-8fbd-db1a8d077ce8" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="-637878442" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-637878442" unbViolId="e8cb0cc4-1212-38c6-a00e-363b29708e58" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e5913042-502a-3ac3-9517-582ccef46a85" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-637878442" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-637878442" unbViolId="2ce55104-9cdc-3a80-bcb0-8c754cab7290" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7681f388-7e37-30e7-afd6-fe41f612499c" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="-637878442" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-637878442" unbViolId="4826e655-7aa6-378c-acb8-20c1780efad2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="258e6047-4b99-3e23-9b8b-784c6479c072" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="-637878442" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-637878442" unbViolId="37e02c9e-2980-346e-9594-a34f4bd504a2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aca77ec2-10e5-3e7f-95c0-d0643e24eff0" locEndPos="1" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'TestBody'" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="2" auth="lyao" locRef="4" rule="JSF-208" lnHash="-637878442" rule.header="C++ exceptions shall not be used" tool="c++test" lineHash="-637878442" unbViolId="ee5b10ef-86c6-33bd-9e29-837d582e027a" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0a6c07cf-0562-3371-9de6-063de96c61b2" locEndPos="3" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'TestBody'" ln="53" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="53" sev="2" auth="lyao" locRef="4" rule="EXCEPT-05" lnHash="-637878442" rule.header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" tool="c++test" lineHash="-637878442" unbViolId="38732f75-7d90-3563-a83f-76b6b9747f55" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6f75aafa-629e-3382-a413-df6a4ccce442" locEndPos="3" locType="sr" hash="-69735008" locEndLn="53" goals="0,"/>
    <StdViol msg="The error from the 'divide' library function should be indicated by a return value instead of an exception" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="4" auth="lyao" locRef="4" rule="PORT-30" lnHash="-313082057" rule.header="Do not throw an exception across execution boundaries" tool="c++test" lineHash="-313082057" unbViolId="89bf2058-c305-3e61-afe3-bd272f706a27" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="add829fb-b2e2-34f6-9c01-3239742ba105" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="The error from the 'divide' library function should be indicated by a return value instead of an exception" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A15_1_5-a" lnHash="-313082057" rule.header="Do not throw an exception across execution boundaries" tool="c++test" lineHash="-313082057" unbViolId="e2a2703f-171b-30c2-af83-0344f1d8bb48" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="52a32f7e-5843-3dfc-82ec-5fb0ed35dbfd" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="The error from the 'divide' library function should be indicated by a return value instead of an exception" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="1" auth="lyao" locRef="4" rule="CERT_CPP-ERR59-a" lnHash="-313082057" rule.header="Do not throw an exception across execution boundaries" tool="c++test" lineHash="-313082057" unbViolId="023b8ca4-0a0f-33bf-9b70-a758b58c9e19" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8302bc14-e67e-33fe-b4c5-c2f8d2cc1328" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's 'divide' return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A0_1_2-a" lnHash="-313082057" rule.header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-313082057" unbViolId="8be06cdd-81ea-36a1-9093-87e0f5cfd72c" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="800a4808-5af2-3aff-908d-30a2b98cedb2" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's 'divide' return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="3" auth="lyao" locRef="4" rule="CODSTA-CPP-58" lnHash="-313082057" rule.header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-313082057" unbViolId="b631066d-1cac-33da-978c-c67512dc4b3a" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="07deced1-3b52-3599-9103-3c219798e819" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's 'divide' return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="2" auth="lyao" locRef="4" rule="MISRA2008-0_1_7" lnHash="-313082057" rule.header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-313082057" unbViolId="fc9c3107-67b5-3a39-968c-11c9a98f1d02" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d64aff7c-2d5c-35c0-9b48-d57611e400c5" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's 'divide' return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="4" auth="lyao" locRef="4" rule="JSF-115_a" lnHash="-313082057" rule.header="Value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-313082057" unbViolId="e90be3f5-b678-33e2-bd8f-b68e57e93b12" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="42f45582-143f-3144-9be6-806e9077c22b" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's &quot;divide&quot; return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="3" auth="lyao" locRef="4" rule="CODSTA-122_a" lnHash="-313082057" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-313082057" unbViolId="30858a55-0c02-3326-89e0-376c50f3480e" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f632835f-cf62-368e-bff9-ea01f9f0b720" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's &quot;divide&quot; return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="2" auth="lyao" locRef="4" rule="MISRAC2012-RULE_17_7-a" lnHash="-313082057" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-313082057" unbViolId="9cc37d11-8c1d-3b03-ba86-17ef70b021d5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5772c566-1997-3687-8cf3-4d82dc86392a" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's &quot;divide&quot; return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="3" auth="lyao" locRef="4" rule="CERT_C-EXP12-a" lnHash="-313082057" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-313082057" unbViolId="1243da4f-70db-373e-8ed1-fe24a3f87279" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c0114edb-5b61-3053-8b28-53d555184085" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Unused function's &quot;divide&quot; return value" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="2" auth="lyao" locRef="4" rule="MISRA2012-RULE-17_7_a" lnHash="-313082057" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-313082057" unbViolId="6dca5e1b-43c3-3005-84ee-5e4ba281bbe5" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c8cf283e-6b51-36e3-aea3-22bdadab4240" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="54" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="54" sev="3" auth="lyao" locRef="4" rule="FORMAT-37" lnHash="-313082057" rule.header="First line in control statement body should be indented more than control statement keyword" tool="c++test" lineHash="-313082057" unbViolId="93fd691a-32ca-39b9-ba13-dec528cdaffb" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="712b01c2-95ec-3a21-8736-593a74820295" locEndPos="5" locType="sr" hash="-69735008" locEndLn="54" goals="0,"/>
    <DupViol msg="Duplicated code: 'FAIL() &lt;&lt; &quot;Expected divide() method to throw DivisionByZeroE...'" ln="55" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="55" sev="3" auth="lyao" locRef="4" rule="CDD-DUPC" lnHash="1522795611" rule.header="Avoid code duplication" tool="c++test" lineHash="1522795611" unbViolId="139a5f84-a700-31ec-b688-3b30e9076207" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="566fccb0-f4ca-3b69-884b-62e21df78071" locType="sr" locEndPos="74" urgent="true" hash="-69735008" locEndLn="55" goals="1,">
      <ElDescList>
        <ElDesc lineHash="1522795611" ln="55" srcRngStartPos="4" srcRngEndPos="74" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="55" srcRngEndLn="55" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 55] Duplicated code in file 'divider_tests.cpp'" rngLn="55"/>
        <ElDesc lineHash="1623057276" ln="60" srcRngStartPos="4" srcRngEndPos="50" locRef="4" locType="sr" srcRnghash="-69735008" srcRngStartln="60" srcRngEndLn="60" srcRngFile="/test/../../../../../../../../test/src/divider_tests.cpp" desc="[Line 60] Duplicated code in file 'divider_tests.cpp'" rngLn="60"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="Put the opening brace '{' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2110495820" unbViolId="093ca159-dc98-375a-ab86-3ac114ceed3f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b7637512-0662-36d5-a798-25f3d6b13a2e" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2110495820" unbViolId="0a58dc8e-04ec-3417-a7c6-c88ee8c2ec0b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f20e9274-4583-39df-b888-185b76283744" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2110495820" unbViolId="81a9efa5-143f-39f6-b6da-595e58d41184" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e8057501-340e-32ca-b659-158e29d1de3d" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-2110495820" unbViolId="02dcda14-f066-332d-8732-f1619fd0cdf9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75ce390b-ea6c-3f9e-9005-cad8ce47f417" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-2110495820" unbViolId="509312d7-f921-3ee8-b86d-79518fbc5079" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7d24c00d-ed54-3920-843f-65621db3dd41" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="-2110495820" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-2110495820" unbViolId="adcf01ec-ac44-3a3d-bf55-62e1baaf5c3c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="de31063d-fbc6-38cb-9473-2fad6bc04b18" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="-2110495820" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-2110495820" unbViolId="7485e0fd-45b0-35b1-bf60-cd4e6ba15c6f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a0792d57-e7b6-3f7d-9335-98e4e14a41cc" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="-2110495820" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-2110495820" unbViolId="52f2a285-22e7-38e5-9390-617f5f7686e1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9a81bd6e-3bf0-30aa-b759-2252515ddaf2" locEndPos="1" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2110495820" unbViolId="7f160b97-230c-3e9b-836d-bd5c2e98fe3c" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="31f1374e-4d22-3398-b6df-520dbf4dcbca" locEndPos="3" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2110495820" unbViolId="2c276af9-2a81-3076-b6b6-b502c860a405" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ebc7df3b-bca6-3ec2-88c2-b49d05b43b41" locEndPos="3" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="-2110495820" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-2110495820" unbViolId="ff73c3a2-4edc-3d94-8432-5309e21cbe18" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f78c9512-be63-35e8-b4c5-171e73efbd67" locEndPos="3" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Put the closing brace '}' on its own line" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="3" auth="lyao" locRef="4" rule="FORMAT-03" lnHash="-2110495820" rule.header="Place a closing brace '}' on its own line" tool="c++test" lineHash="-2110495820" unbViolId="2f197656-e587-32f5-a280-b130beb38d79" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="50027685-1730-3b1f-a9e4-78065d1171d5" locEndPos="3" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'TestBody'" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="2" auth="lyao" locRef="4" rule="JSF-208" lnHash="-2110495820" rule.header="C++ exceptions shall not be used" tool="c++test" lineHash="-2110495820" unbViolId="b545f6df-3f64-3faf-a888-ebfed9099e60" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="64df6e15-fdd8-30ce-a06f-62db979368b2" locEndPos="5" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'TestBody'" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="2" auth="lyao" locRef="4" rule="EXCEPT-05" lnHash="-2110495820" rule.header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" tool="c++test" lineHash="-2110495820" unbViolId="c92c1e96-277f-3400-b012-5f33ad6ac7c7" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="890f0ca3-55a5-38e9-8126-04acdd45100c" locEndPos="5" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="2" auth="lyao" locRef="4" rule="OWASP2021-A9-a" lnHash="-2110495820" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="-2110495820" unbViolId="be07bca0-c8d2-3927-bec8-c5f41463227f" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8ff39ad6-76ea-3eb3-b364-9a1adde9b043" locEndPos="5" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="2" auth="lyao" locRef="4" rule="OWASP2019-API10-a" lnHash="-2110495820" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="-2110495820" unbViolId="9e206204-833c-374c-bf1b-9db0d98b6755" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4f26564d-19d5-3644-93f8-44e47ba1f1f6" locEndPos="5" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="2" auth="lyao" locRef="4" rule="OWASP2017-A10-a" lnHash="-2110495820" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="-2110495820" unbViolId="218a3161-6bef-3e0a-b929-05f626692b4b" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="037649b4-cdcb-3244-ac3d-77ea290fd588" locEndPos="5" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="56" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="56" sev="2" auth="lyao" locRef="4" rule="EXCEPT-04" lnHash="-2110495820" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="-2110495820" unbViolId="25f2ccbc-37f4-3cf5-b21b-5c1399089e93" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="241aa873-c269-3e43-b464-eedf254062ef" locEndPos="5" locType="sr" hash="-69735008" locEndLn="56" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="57" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="57" sev="3" auth="lyao" locRef="4" rule="FORMAT-37" lnHash="-22859056" rule.header="First line in control statement body should be indented more than control statement keyword" tool="c++test" lineHash="-22859056" unbViolId="ffda2447-5b52-33aa-ad2d-199e6b567003" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d11e9a38-ad4d-3ce5-bd16-52099d0e6d00" locEndPos="5" locType="sr" hash="-69735008" locEndLn="57" goals="0,"/>
    <StdViol msg="R-239: selector expression is constant" ln="57" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="57" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-22859056" rule.header="Parser remark" tool="c++test" lineHash="-22859056" unbViolId="52d4fa55-e1ba-342e-88aa-a57e785b7c1a" locStartPos="12" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="19dacab4-f588-38c0-85c0-bbe338aac24b" locEndPos="13" locType="sr" hash="-69735008" locEndLn="57" goals="0,"/>
    <StdViol msg="R-342: value copied to temporary, reference to temporary used" ln="57" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="57" sev="5" auth="lyao" locRef="4" rule="PARSER-REMARK" lnHash="-22859056" rule.header="Parser remark" tool="c++test" lineHash="-22859056" unbViolId="46271ad9-11aa-32f0-9057-00d086960156" locStartPos="232" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5d4e4f01-2c92-3f2e-917b-8f79a13fc35c" locEndPos="233" locType="sr" hash="-69735008" locEndLn="57" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="58" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="58" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="31869" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="31869" unbViolId="54ad0eed-672a-3af2-8a4b-50b37df87dbf" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="687c31a7-aaaf-315b-b80f-1986c4e21aee" locEndPos="1" locType="sr" hash="-69735008" locEndLn="58" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="JSF-061" lnHash="1530006233" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1530006233" unbViolId="aed08fce-67ee-34c5-9a56-519f367205f5" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ceb589be-e5e3-3ffd-80c6-6649393f600d" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="FORMAT-42" lnHash="1530006233" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1530006233" unbViolId="dddc00dc-b50e-3492-9945-ac40069cb74c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c12d2f63-ad17-3666-bc08-81c26dac4e4a" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="JSF-060_a" lnHash="1530006233" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1530006233" unbViolId="b5e6f4b9-5010-365b-a676-1769254d558d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bd2278a0-6941-3823-b0c1-2951df12bddc" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="FORMAT-43" lnHash="1530006233" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1530006233" unbViolId="4f70b49f-d1d4-3646-8c56-c636f422e45a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c9b2ce79-ec4e-3124-84be-1a2699280fd0" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="JSF-060_b" lnHash="1530006233" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1530006233" unbViolId="c398c17c-4c36-3ad8-80c0-9be341267559" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7498ffd3-4263-37eb-bb26-79d0f33a708d" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="1530006233" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1530006233" unbViolId="61df0df7-25e1-3e53-b5c2-c627f7334f99" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3e67d1ec-50af-33d9-a339-ba164cff7e17" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="FORMAT-02" lnHash="1530006233" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="1530006233" unbViolId="c03350d6-cde8-384f-908c-4dc2a99033ec" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e913cfa7-2dc2-3a8b-acd4-6006b40d7d66" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="FORMAT-34" lnHash="1530006233" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="1530006233" unbViolId="63f25d18-7d9f-32f0-8535-36802bb0261c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2d1e1ac0-5a99-3123-8d30-bec69ebb3cff" locEndPos="1" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'TestBody'" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="JSF-208" lnHash="1530006233" rule.header="C++ exceptions shall not be used" tool="c++test" lineHash="1530006233" unbViolId="e9b1a478-22b2-3085-be53-1b0ac688fe0a" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15c8e71e-624c-36be-858e-0931454686c4" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="c++ exception handling structure is used in function 'TestBody'" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="EXCEPT-05" lnHash="1530006233" rule.header="C++ exceptions shall not be used (i.e. throw, catch and try shall not be used.)" tool="c++test" lineHash="1530006233" unbViolId="a83751bd-950a-3680-8ec1-b7ca0a87c473" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="08059ae2-92c6-3b78-a2e9-56a869cfddff" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="The catch-all handler should be replaced by a catch handler for the specific exception type" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="AUTOSAR-A15_3_4-a" lnHash="1530006233" rule.header="Avoid using catch-all exception handlers" tool="c++test" lineHash="1530006233" unbViolId="54af7118-9d61-307a-9f0b-dc59538fe30a" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ab4c954d-809d-325b-adce-857140aafd29" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="The catch-all handler should be replaced by a catch handler for the specific exception type" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="3" auth="lyao" locRef="4" rule="EXCEPT-26" lnHash="1530006233" rule.header="Avoid using catch-all exception handlers" tool="c++test" lineHash="1530006233" unbViolId="5a488bab-e7d3-309a-b7e6-c54bd8f6ebfa" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8219529d-f7f5-367a-a258-b5e682b42b58" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="OWASP2021-A9-a" lnHash="1530006233" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="1530006233" unbViolId="cd2663e4-8f0b-323d-a65c-f0bd7a91e3ec" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e8fbaa0f-c5e6-3456-b737-9df462fbb296" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="OWASP2019-API10-a" lnHash="1530006233" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="1530006233" unbViolId="7919c319-329c-3dd9-bde6-553ecd64be35" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="77cb23d4-60d4-3f7a-9842-e0263dd96a6a" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="OWASP2017-A10-a" lnHash="1530006233" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="1530006233" unbViolId="57e49a3c-b3c6-347d-bdac-f164ee2a8723" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dc40d939-b7cc-37f6-9fec-da463dfc317b" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Rethrow or log all exceptions using standard logger" ln="59" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="59" sev="2" auth="lyao" locRef="4" rule="EXCEPT-04" lnHash="1530006233" rule.header="All exceptions should be rethrown or logged with standard logger" tool="c++test" lineHash="1530006233" unbViolId="f00c7620-9e98-383a-bf42-a7f4dc3ef145" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="da3c4c71-2516-31dc-abbc-233a3221a80f" locEndPos="3" locType="sr" hash="-69735008" locEndLn="59" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="60" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="60" sev="3" auth="lyao" locRef="4" rule="FORMAT-37" lnHash="1623057276" rule.header="First line in control statement body should be indented more than control statement keyword" tool="c++test" lineHash="1623057276" unbViolId="8acdd773-5013-3a3a-a283-092149d5a04d" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4dd10021-02b3-3978-b81f-bbd57e673ac3" locEndPos="5" locType="sr" hash="-69735008" locEndLn="60" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="61" locFile="/test/../../../../../../../../test/src/divider_tests.cpp" locStartln="61" sev="3" auth="lyao" locRef="4" rule="FORMAT-27" lnHash="31869" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="31869" unbViolId="6ef211e6-f0ff-3990-859b-074077a9ee56" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c4738058-7499-3b3b-b8a3-4a48f5ecbbec" locEndPos="1" locType="sr" hash="-69735008" locEndLn="61" goals="0,"/>
    <StdViol msg="'gmock-all.cc' filename extension does not adhere to naming conventions" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="1" sev="3" auth="lyao" locRef="5" rule="NAMING-43" lnHash="1129189924" rule.header="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" tool="c++test" lineHash="1129189924" unbViolId="008dc3d7-bb45-3a38-94f2-c78d10a6e792" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d052127f-820f-3fcc-b0d8-aa9487c3f2a7" locEndPos="1" locType="sr" hash="1220095087" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock-all.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="1" sev="3" auth="lyao" locRef="5" rule="JSF-054" lnHash="1129189924" rule.header="Implementation files will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="c738ed00-047e-34ad-a169-9153041386d9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4dc80c37-e48c-36c9-b0ec-d9cd41cd699e" locEndPos="1" locType="sr" hash="1220095087" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock-all.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="1" sev="4" auth="lyao" locRef="5" rule="AUTOSAR-A3_1_3-a" lnHash="1129189924" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="364990c6-aca6-3821-a8b1-4b52dd9a9961" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="267afae7-66a2-374b-9113-81cbe7a17e58" locEndPos="1" locType="sr" hash="1220095087" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock-all.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="1" sev="4" auth="lyao" locRef="5" rule="NAMING-49" lnHash="1129189924" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="70e0b166-0a53-3072-bf11-fc8a8e525e15" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a1e40d86-9a2a-30e0-bb41-0eb64e8d62f5" locEndPos="1" locType="sr" hash="1220095087" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock-all.cc' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="1" sev="5" auth="lyao" locRef="5" rule="PFO-04" lnHash="1129189924" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="1129189924" unbViolId="ffb33405-14b4-3fff-9889-7f355274bebb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e8cff0f2-221b-3c1a-b05c-ca50319d8ca4" locEndPos="1" locType="sr" hash="1220095087" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gmock/gmock.h&quot;" ln="39" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="39" sev="2" auth="lyao" locRef="5" rule="PREPROC-09" lnHash="-1004506916" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1004506916" unbViolId="78774d4e-42be-3b56-9bf2-68f17b8ab8d3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cfed0bbf-c41c-3e98-9bb5-cb8c52c35b9c" locEndPos="1" locType="sr" hash="1220095087" locEndLn="39" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gmock/gmock.h&quot;" ln="39" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="39" sev="2" auth="lyao" locRef="5" rule="JSF-033" lnHash="-1004506916" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1004506916" unbViolId="b7c4761b-776d-3104-a483-77df49b0abfd" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ccf08b4f-cd66-3161-b958-4c59be461ef6" locEndPos="1" locType="sr" hash="1220095087" locEndLn="39" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-cardinalities.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="42" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="42" sev="3" auth="lyao" locRef="5" rule="NAMING-53" lnHash="-1957976142" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-1957976142" unbViolId="02c25c78-c38c-3057-b621-0ff4a524d68b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6646e442-f0d6-3546-b545-c56167f5184a" locEndPos="1" locType="sr" hash="1220095087" locEndLn="42" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-cardinalities.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="42" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="42" sev="2" auth="lyao" locRef="5" rule="AUTOSAR-A3_1_2-a" lnHash="-1957976142" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-1957976142" unbViolId="726c797a-0c6b-30bd-8955-2bb7f1dd18a5" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="24359e8d-504f-3323-ae04-f615a5d3ca48" locEndPos="1" locType="sr" hash="1220095087" locEndLn="42" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-cardinalities.cc&quot;" ln="42" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="42" sev="3" auth="lyao" locRef="5" rule="JSF-032" lnHash="-1957976142" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-1957976142" unbViolId="6ddedefc-3fcd-3423-a9ba-1e412365dcc5" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7d6649e6-a9b2-3dce-b328-02efd0b42ae9" locEndPos="1" locType="sr" hash="1220095087" locEndLn="42" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-cardinalities.cc&quot;" ln="42" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="42" sev="3" auth="lyao" locRef="5" rule="PREPROC-08" lnHash="-1957976142" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-1957976142" unbViolId="b869305e-fa08-3eea-afc7-6f911d9145e1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed6de8c3-1595-3499-8845-e231682f9e70" locEndPos="1" locType="sr" hash="1220095087" locEndLn="42" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-cardinalities.cc&quot;" ln="42" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="42" sev="2" auth="lyao" locRef="5" rule="PREPROC-09" lnHash="-1957976142" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1957976142" unbViolId="3649593f-f0c6-30f4-a4e7-5c4779e9fcf0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b494bbfc-795b-3b7e-b780-c7915013a60c" locEndPos="1" locType="sr" hash="1220095087" locEndLn="42" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-cardinalities.cc&quot;" ln="42" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="42" sev="2" auth="lyao" locRef="5" rule="JSF-033" lnHash="-1957976142" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1957976142" unbViolId="80523b7d-ee38-3a03-9fbf-4f78eae2d6f8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="24d45ae6-45cc-3ae7-9a95-306cd50724f7" locEndPos="1" locType="sr" hash="1220095087" locEndLn="42" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-internal-utils.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="43" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="43" sev="3" auth="lyao" locRef="5" rule="NAMING-53" lnHash="890650115" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="890650115" unbViolId="218b57d6-623d-3a45-ae76-ca5934050aab" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4620f202-1001-35c2-ba31-380c1c6f1567" locEndPos="1" locType="sr" hash="1220095087" locEndLn="43" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-internal-utils.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="43" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="43" sev="2" auth="lyao" locRef="5" rule="AUTOSAR-A3_1_2-a" lnHash="890650115" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="890650115" unbViolId="9792a54e-7d8f-3afb-bfe3-35cbcdc58657" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fbf7e2ab-855d-311c-8669-edf434079c66" locEndPos="1" locType="sr" hash="1220095087" locEndLn="43" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-internal-utils.cc&quot;" ln="43" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="43" sev="3" auth="lyao" locRef="5" rule="JSF-032" lnHash="890650115" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="890650115" unbViolId="cdf001e2-29e7-3b13-ab14-f548bfcfc1e1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ba733eb2-2c4b-382b-8b0d-902204068350" locEndPos="1" locType="sr" hash="1220095087" locEndLn="43" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-internal-utils.cc&quot;" ln="43" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="43" sev="3" auth="lyao" locRef="5" rule="PREPROC-08" lnHash="890650115" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="890650115" unbViolId="4319d7c8-1ec5-36f7-9a8d-b5785fb457f9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cfa1f9d1-8e64-3a48-a564-2e8d5e96d165" locEndPos="1" locType="sr" hash="1220095087" locEndLn="43" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-internal-utils.cc&quot;" ln="43" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="43" sev="2" auth="lyao" locRef="5" rule="PREPROC-09" lnHash="890650115" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="890650115" unbViolId="6236031b-729b-3c20-9528-d1afcfe60867" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="38eeadae-b766-3808-b191-27e0ff3dd1f8" locEndPos="1" locType="sr" hash="1220095087" locEndLn="43" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-internal-utils.cc&quot;" ln="43" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="43" sev="2" auth="lyao" locRef="5" rule="JSF-033" lnHash="890650115" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="890650115" unbViolId="a15ff01b-386d-322b-a3c4-9bf655368872" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b993e76f-3c14-3c3d-8639-ca52fef27aff" locEndPos="1" locType="sr" hash="1220095087" locEndLn="43" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-matchers.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="44" sev="3" auth="lyao" locRef="5" rule="NAMING-53" lnHash="-1051368349" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-1051368349" unbViolId="290655dc-8675-3174-8c7d-6c57b2e8e085" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9a74a3fa-b73f-3e91-93eb-6bee842e2306" locEndPos="1" locType="sr" hash="1220095087" locEndLn="44" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-matchers.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="44" sev="2" auth="lyao" locRef="5" rule="AUTOSAR-A3_1_2-a" lnHash="-1051368349" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-1051368349" unbViolId="6d2e6dd7-56fc-38f9-bf6f-e44ff862a593" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fe49c340-f1c1-3904-b81b-74d47aa76e7c" locEndPos="1" locType="sr" hash="1220095087" locEndLn="44" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-matchers.cc&quot;" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="44" sev="3" auth="lyao" locRef="5" rule="JSF-032" lnHash="-1051368349" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-1051368349" unbViolId="2f16d78a-902f-3434-a89c-8470e59e4520" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5ac80642-5bb1-38a1-ab22-df061542d2e2" locEndPos="1" locType="sr" hash="1220095087" locEndLn="44" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-matchers.cc&quot;" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="44" sev="3" auth="lyao" locRef="5" rule="PREPROC-08" lnHash="-1051368349" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-1051368349" unbViolId="ebe238b3-27e7-3d0a-b487-7591bff56586" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1f84cde3-0d28-3190-920c-c1decf4d4c78" locEndPos="1" locType="sr" hash="1220095087" locEndLn="44" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-matchers.cc&quot;" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="44" sev="2" auth="lyao" locRef="5" rule="PREPROC-09" lnHash="-1051368349" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1051368349" unbViolId="013febc8-b679-3f80-8224-b85721887276" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d35c30b5-ad04-334f-83ba-3dd845202ab2" locEndPos="1" locType="sr" hash="1220095087" locEndLn="44" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-matchers.cc&quot;" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="44" sev="2" auth="lyao" locRef="5" rule="JSF-033" lnHash="-1051368349" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1051368349" unbViolId="2e6a0833-2094-3346-bc57-3ca508a498e8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b40fcee8-f524-31b9-b734-6956ca141f18" locEndPos="1" locType="sr" hash="1220095087" locEndLn="44" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-spec-builders.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="45" sev="3" auth="lyao" locRef="5" rule="NAMING-53" lnHash="1589397520" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="1589397520" unbViolId="07e277f5-7921-3ce2-a45f-694207dfea69" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cf03f9bd-224f-3bb4-8ca4-56e36b72d6f4" locEndPos="1" locType="sr" hash="1220095087" locEndLn="45" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock-spec-builders.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="45" sev="2" auth="lyao" locRef="5" rule="AUTOSAR-A3_1_2-a" lnHash="1589397520" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="1589397520" unbViolId="9d508724-25fe-36db-bbb9-4678732dbaa2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b87f4dcf-9347-34a3-b448-5baa67090e16" locEndPos="1" locType="sr" hash="1220095087" locEndLn="45" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-spec-builders.cc&quot;" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="45" sev="3" auth="lyao" locRef="5" rule="JSF-032" lnHash="1589397520" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="1589397520" unbViolId="fc9d06eb-1972-3ded-afd0-4f732f524121" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0f5c1aa0-526c-31a6-9a80-9736939b96bc" locEndPos="1" locType="sr" hash="1220095087" locEndLn="45" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock-spec-builders.cc&quot;" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="45" sev="3" auth="lyao" locRef="5" rule="PREPROC-08" lnHash="1589397520" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="1589397520" unbViolId="8be671a0-937c-375f-b6d7-dea7ce73ce8e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cfe5da26-29be-3610-a7b1-4f63c18b3286" locEndPos="1" locType="sr" hash="1220095087" locEndLn="45" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-spec-builders.cc&quot;" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="45" sev="2" auth="lyao" locRef="5" rule="PREPROC-09" lnHash="1589397520" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1589397520" unbViolId="6f7bfba3-7c89-39fc-922c-4a83495f88d1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2dbc1622-0b4b-3b2f-a3ae-8c63af5b3b3e" locEndPos="1" locType="sr" hash="1220095087" locEndLn="45" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock-spec-builders.cc&quot;" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="45" sev="2" auth="lyao" locRef="5" rule="JSF-033" lnHash="1589397520" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1589397520" unbViolId="1f81d6ad-277e-3c9f-9026-cf2a86cd88cf" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="df9eaad9-73de-35c7-83dd-febb74d2f5b0" locEndPos="1" locType="sr" hash="1220095087" locEndLn="45" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="46" sev="3" auth="lyao" locRef="5" rule="NAMING-53" lnHash="642954707" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="642954707" unbViolId="bc887233-3680-3f0b-ab55-b8a2496d8a4e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7dd88866-8dfb-369f-a225-e9d1e14aea95" locEndPos="1" locType="sr" hash="1220095087" locEndLn="46" goals="0,"/>
    <StdViol msg="Header file &quot;src/gmock.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="46" sev="2" auth="lyao" locRef="5" rule="AUTOSAR-A3_1_2-a" lnHash="642954707" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="642954707" unbViolId="d7460bbd-3efc-3ed6-8105-f336b1bde25c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="595d9be7-1649-35c1-a3f7-48b59649ce47" locEndPos="1" locType="sr" hash="1220095087" locEndLn="46" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock.cc&quot;" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="46" sev="3" auth="lyao" locRef="5" rule="JSF-032" lnHash="642954707" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="642954707" unbViolId="dedd11b4-d576-3bdd-b335-3cd935def3ac" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="074f787e-124c-3060-b20f-4b28d9d15502" locEndPos="1" locType="sr" hash="1220095087" locEndLn="46" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gmock.cc&quot;" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="46" sev="3" auth="lyao" locRef="5" rule="PREPROC-08" lnHash="642954707" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="642954707" unbViolId="395bff63-fee0-3e5c-bc36-c4a17c2f19d3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="be569332-fc1c-3cb1-a0ec-828234815891" locEndPos="1" locType="sr" hash="1220095087" locEndLn="46" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock.cc&quot;" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="46" sev="2" auth="lyao" locRef="5" rule="PREPROC-09" lnHash="642954707" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="642954707" unbViolId="a1a9a4b4-475a-319c-b407-baec1f8ade0f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1003762b-8a3a-3c8e-8318-d570ee963e08" locEndPos="1" locType="sr" hash="1220095087" locEndLn="46" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gmock.cc&quot;" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locStartln="46" sev="2" auth="lyao" locRef="5" rule="JSF-033" lnHash="642954707" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="642954707" unbViolId="47a46332-ee45-36b0-b91c-e072dfad5312" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="96eac361-0a10-3c79-9dd6-ac0f18b40365" locEndPos="1" locType="sr" hash="1220095087" locEndLn="46" goals="0,"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="3" auth="lyao" locRef="6" rule="METRICS-31" lnHash="1129189924" rule.header="The assertion density of the code should average to a minimum of two assertions per function" tool="c++test" lineHash="1129189924" unbViolId="62a9503f-f3a5-3431-826c-e2723d5addc0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5af5af40-bd6a-3ab1-b810-b0ae5df7ca92" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="'gmock_main.cc' filename extension does not adhere to naming conventions" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="3" auth="lyao" locRef="6" rule="NAMING-43" lnHash="1129189924" rule.header="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" tool="c++test" lineHash="1129189924" unbViolId="bf44525c-3f6c-3109-b41f-0511c7de3bb6" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="51bbbc55-5dd0-3163-86e7-68d3aaa920bb" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock_main.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="3" auth="lyao" locRef="6" rule="JSF-054" lnHash="1129189924" rule.header="Implementation files will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="5deef889-ec78-31b3-9340-aaef71f211e8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0ff6bc92-917d-3f03-b5a1-376ae1e16f35" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock_main.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="4" auth="lyao" locRef="6" rule="AUTOSAR-A3_1_3-a" lnHash="1129189924" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="a1396a1f-37a2-3210-bd6d-e710d5187492" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="51b3bcae-332f-3e5c-881a-6971a68f1841" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock_main.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="4" auth="lyao" locRef="6" rule="NAMING-49" lnHash="1129189924" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="3e333b98-6653-3057-bc95-003e58e0a0f2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="831c2a52-56e6-3a5c-a385-5e8bc3dbb880" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gmock_main.cc' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="5" auth="lyao" locRef="6" rule="PFO-04" lnHash="1129189924" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="1129189924" unbViolId="47cf6d65-bf29-3157-ae20-b50f599bf1fc" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a47afe5a-c771-3311-a24f-ac8664d7d34a" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'gmock_main.cc'" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="3" auth="lyao" locRef="6" rule="COMMENT-03" lnHash="1129189924" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1129189924" unbViolId="ee453117-bf6e-3514-9d6e-1f808e195af2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3742b958-a7c4-3a28-b31b-1f318995cf48" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'gmock_main.cc'" ln="1" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="1" sev="3" auth="lyao" locRef="6" rule="JSF-133_a" lnHash="1129189924" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="1129189924" unbViolId="3e0c2717-36eb-3211-802e-2dad291cb05c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="947bda5a-9147-3ba0-80cc-c7592d639f4e" locEndPos="1" locType="sr" hash="1953665929" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gmock/gmock.h&quot;" ln="32" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="32" sev="2" auth="lyao" locRef="6" rule="PREPROC-09" lnHash="-1004506916" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1004506916" unbViolId="f305972a-0e02-3008-b1c2-c5183aecf8cd" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4edb4291-0f45-3dc5-a9f6-a7b5f4c03e25" locEndPos="1" locType="sr" hash="1953665929" locEndLn="32" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gmock/gmock.h&quot;" ln="32" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="32" sev="2" auth="lyao" locRef="6" rule="JSF-033" lnHash="-1004506916" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1004506916" unbViolId="343ed82a-9f72-3d8a-8d75-2bc90947a8f8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a2c4ad09-9c0b-3b89-ad27-f27b5d540c20" locEndPos="1" locType="sr" hash="1953665929" locEndLn="32" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="33" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="33" sev="2" auth="lyao" locRef="6" rule="PREPROC-09" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="3aff14f7-ef21-33fd-b57f-4b8d8ce54496" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9eb4c660-f363-3954-962f-19bfeeac9789" locEndPos="1" locType="sr" hash="1953665929" locEndLn="33" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="33" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="33" sev="2" auth="lyao" locRef="6" rule="JSF-033" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="651fc279-a9c5-3cd1-9cb7-7427b4cac174" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="094ced44-8e16-3665-a94c-ec3e9bb5a4f8" locEndPos="1" locType="sr" hash="1953665929" locEndLn="33" goals="0,"/>
    <StdViol msg="Line has over 79 characters" ln="39" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="39" sev="3" auth="lyao" locRef="6" rule="FORMAT-04" lnHash="-377543556" rule.header="Physical lines should be less than eighty characters" tool="c++test" lineHash="-377543556" unbViolId="f4f676ec-16f2-3933-87d9-620c0f929162" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="12896726-fedb-391e-8cc4-8807a60a68de" locEndPos="1" locType="sr" hash="1953665929" locEndLn="39" goals="0,"/>
    <StdViol msg="Line contains more than 120 characters: 143" ln="39" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="39" sev="3" auth="lyao" locRef="6" rule="JSF-041" lnHash="-377543556" rule.header="Source lines will be kept to a length of 120 characters or less" tool="c++test" lineHash="-377543556" unbViolId="c0260881-48f1-3521-ace4-19f71ca512b1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6733fa42-5de0-3588-93e4-f14992cb1c77" locEndPos="1" locType="sr" hash="1953665929" locEndLn="39" goals="0,"/>
    <StdViol msg="Line contains more than 120 characters: 143" ln="39" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="39" sev="3" auth="lyao" locRef="6" rule="METRICS-26" lnHash="-377543556" rule.header="Source lines will be kept to a length of 120 characters or less" tool="c++test" lineHash="-377543556" unbViolId="c69e22f4-f8c3-3de6-bd13-8bfc0f274987" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="19a86c29-f73b-3942-90c8-b669f7314c87" locEndPos="1" locType="sr" hash="1953665929" locEndLn="39" goals="0,"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="41" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="41" sev="3" auth="lyao" locRef="6" rule="PREPROC-10_c" lnHash="251863219" rule.header="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="251863219" unbViolId="da510eca-de7f-35d6-bacf-e4b38218405b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="570103c5-14fc-3393-adcd-0398d50432ce" locEndPos="1" locType="sr" hash="1953665929" locEndLn="41" goals="0,"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="41" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="41" sev="2" auth="lyao" locRef="6" rule="MISRA2008-16_2_1_e" lnHash="251863219" rule.header="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="251863219" unbViolId="87449eae-527e-30bf-9e27-a651aea0b056" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="89eb84e8-a6ec-3015-84fe-4e506cae8d69" locEndPos="1" locType="sr" hash="1953665929" locEndLn="41" goals="0,"/>
    <StdViol msg="#if pre-processor directive should not be used" ln="41" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="41" sev="3" auth="lyao" locRef="6" rule="HICPP-16_1_1-f" lnHash="251863219" rule.header="The #if pre-processor directive will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="251863219" unbViolId="708bcb17-cdb4-3cc1-8591-bcc44e213c62" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c7f3e919-e1d2-388a-9091-a4e8d0e6b02a" locEndPos="1" locType="sr" hash="1953665929" locEndLn="41" goals="0,"/>
    <StdViol msg="The #if preprocessor directive is used" ln="41" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="41" sev="3" auth="lyao" locRef="6" rule="PREPROC-11_b" lnHash="251863219" rule.header="The #if preprocessor directive should not be used" tool="c++test" lineHash="251863219" unbViolId="a1d381d7-05a1-36f7-92cb-14d9e62b8bde" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="63ae73ed-dea8-32bc-9442-27722a029897" locEndPos="1" locType="sr" hash="1953665929" locEndLn="41" goals="0,"/>
    <StdViol msg="The #if preprocessor directive is used" ln="41" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="41" sev="2" auth="lyao" locRef="6" rule="JSF-026_b" lnHash="251863219" rule.header="The #if preprocessor directive should not be used" tool="c++test" lineHash="251863219" unbViolId="079d4210-3bab-34b7-94b0-e17a8534d177" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3b8861ec-e894-311c-8b18-e07c3a7fb694" locEndPos="1" locType="sr" hash="1953665929" locEndLn="41" goals="0,"/>
    <StdViol msg="Macro might be not defined: GTEST_OS_WINDOWS_MOBILE" ln="41" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="41" sev="3" auth="lyao" locRef="6" rule="PREPROC-24" lnHash="251863219" rule.header="All macro identifiers in preprocessor directives shall be defined before use, except in #ifdef and #ifndef preprocessor directives and the defined() operator" tool="c++test" lineHash="251863219" unbViolId="6f7ce998-d057-3937-b901-47c01df1c4e0" locStartPos="4" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c1af2cef-55a2-3948-8d5b-6f9c127d84a7" locEndPos="5" locType="sr" hash="1953665929" locEndLn="41" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="FORMAT-02" lnHash="1150797800" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="1150797800" unbViolId="06b09f10-4c5f-39d9-b89a-25892ac5d08b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ae8b0db1-f358-3ef7-adcc-22dade102206" locEndPos="1" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="4" auth="lyao" locRef="6" rule="MISRA2008-3_9_2" lnHash="1150797800" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1150797800" unbViolId="22d076ee-0fda-36ab-b73e-39600743addd" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="826b0116-bc95-3166-84e9-13717031859c" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="MISRA-013" lnHash="1150797800" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1150797800" unbViolId="c9ff92a8-6181-3942-9c29-f614302dd9ac" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e4f9c264-edb7-38ff-a360-5bf39b7667c3" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'int' basic numerical type" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="CODSTA-223" lnHash="1150797800" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="1150797800" unbViolId="b0f3bf58-2a51-3d65-b87f-4cf7c7240f27" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="97a9d12e-bce8-33c3-a480-e51590625a27" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'int' basic numerical type" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A3_9_1-b" lnHash="1150797800" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="1150797800" unbViolId="c40cac46-342e-3a08-8d32-f29cbd3e88ab" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="489f0bd4-267a-364c-9239-41dd76ab31cc" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="HICPP-7_1_6-b" lnHash="1150797800" rule.header="Use class types or typedefs to abstract scalar quantities and standard integer types" tool="c++test" lineHash="1150797800" unbViolId="33b0e7fc-434f-3b08-a9e5-3f67fb226234" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c731c53f-c7f5-3343-8153-62c39b65affb" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="4" auth="lyao" locRef="6" rule="MISRAC2012-DIR_4_6-b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="0a232471-2bd3-32d0-af77-046b2b8f19c3" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="823fed7c-4d90-33a5-a6da-033cdec11df0" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="2" auth="lyao" locRef="6" rule="JSF-209_b" lnHash="1150797800" rule.header="Typedefs that indicate size and signedness shall be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="6a5ba9d8-5aa7-370a-a742-6dc534e627f5" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="49150984-0131-3a81-9a5d-d67e80bffa32" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="MISRA2004-6_3_b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="9a413b87-6634-3542-a0c5-f48f3143917d" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="726ca38c-200c-3d71-94c4-6affd2b86ed2" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="4" auth="lyao" locRef="6" rule="MISRA2012-DIR-4_6_b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="ef93a4c9-7a35-3908-a05b-c37fe419bfb2" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6d4476ef-2089-3819-aeff-37b55bd1ffc0" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="HICPP-3_5_1-b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="c8a6349c-ae48-396e-8bb7-043f7f84f5b4" locStartPos="11" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bdf9cfa8-a994-3bb2-af21-5a606f1ace99" locEndPos="12" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="4" auth="lyao" locRef="6" rule="MISRA2008-3_9_2" lnHash="1150797800" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1150797800" unbViolId="4d1988a3-ac63-3b32-811f-5ebe228b01f0" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4c0306f1-da48-3dc4-8c76-b754c9118765" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="MISRA-013" lnHash="1150797800" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1150797800" unbViolId="db2b0fb3-5c99-3cab-bf7e-b272f9cb5299" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e20cebb0-d897-3a06-aa90-dc3028b2f5e6" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'int' basic numerical type" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="CODSTA-223" lnHash="1150797800" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="1150797800" unbViolId="999aa35e-abdd-370f-a10f-a3ce557667a6" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="df83f812-9034-38d4-820a-8d8d8a4766d6" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="Use the fixed width integer type from &lt;cstdint> instead of the 'int' basic numerical type" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A3_9_1-b" lnHash="1150797800" rule.header="Fixed width integer types from &lt;cstdint>, indicating the size and signedness, shall be used in place of the basic numerical types" tool="c++test" lineHash="1150797800" unbViolId="8f24effd-1520-3c1c-a084-265747006c0a" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d7804dfa-70e4-3a05-a3ee-e1320c2b159d" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="HICPP-7_1_6-b" lnHash="1150797800" rule.header="Use class types or typedefs to abstract scalar quantities and standard integer types" tool="c++test" lineHash="1150797800" unbViolId="ede20d52-14f4-3f49-8bf6-9a9d8a93f8d4" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="19d045b3-36f9-366c-b230-6e29d3c1e6af" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="4" auth="lyao" locRef="6" rule="MISRAC2012-DIR_4_6-b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="ff6ddcd3-8a60-3c88-a6ce-29ff610bd707" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5ea1cebd-22cf-3cb4-bb67-7ba0e55ff2a2" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="2" auth="lyao" locRef="6" rule="JSF-209_b" lnHash="1150797800" rule.header="Typedefs that indicate size and signedness shall be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="fed53c13-17f4-3e61-b1a0-6042a1071f92" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="29d1223c-44aa-3901-a133-755209a0b7fa" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="MISRA2004-6_3_b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="41eb2c81-55f4-38c2-9c35-9cd2af6e40f5" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="32da8c77-4365-3c29-b15e-b8f8dcf51d36" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="4" auth="lyao" locRef="6" rule="MISRA2012-DIR-4_6_b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="8b0d5df1-e8a2-372f-bf14-9e0b8dfef46e" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f9c78f3-6d20-37f4-ba56-b1a20162ef32" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="44" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="44" sev="3" auth="lyao" locRef="6" rule="HICPP-3_5_1-b" lnHash="1150797800" rule.header="typedefs should be used in place of the basic types" tool="c++test" lineHash="1150797800" unbViolId="2ddd4e70-e874-39f5-8531-d71cb63d3240" locStartPos="22" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a13ac9a1-c682-3b84-aba3-1eafdd632e12" locEndPos="23" locType="sr" hash="1953665929" locEndLn="44" goals="0,"/>
    <StdViol msg="#else pre-processor directive should not be used" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="45" sev="3" auth="lyao" locRef="6" rule="PREPROC-26" lnHash="35439580" rule.header="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" tool="c++test" lineHash="35439580" unbViolId="72d509de-9821-3116-be54-1c738608db22" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0e7157d2-9737-3645-b94b-8501307cb03f" locEndPos="1" locType="sr" hash="1953665929" locEndLn="45" goals="0,"/>
    <StdViol msg="#else pre-processor directive should not be used" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="45" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A16_0_1-a" lnHash="35439580" rule.header="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" tool="c++test" lineHash="35439580" unbViolId="b04b1f51-71c5-3a70-8299-2e1b618c214e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="79ab5729-0241-361a-a467-f1a187fbc548" locEndPos="1" locType="sr" hash="1953665929" locEndLn="45" goals="0,"/>
    <StdViol msg="The #else preprocessor directive is used" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="45" sev="2" auth="lyao" locRef="6" rule="MISRA2008-16_2_1_c" lnHash="35439580" rule.header="The #ifdef, #else, #elif preprocessor directives should not be used" tool="c++test" lineHash="35439580" unbViolId="b3962ec9-f17a-3f61-a7ed-4d22d54ccea4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9ad6148b-92eb-3a68-a182-770c0caaf9ad" locEndPos="1" locType="sr" hash="1953665929" locEndLn="45" goals="0,"/>
    <StdViol msg="The #else preprocessor directive is used" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="45" sev="3" auth="lyao" locRef="6" rule="HICPP-16_1_1-c" lnHash="35439580" rule.header="The #ifdef, #else, #elif preprocessor directives should not be used" tool="c++test" lineHash="35439580" unbViolId="0eaf7913-b494-39f4-b47b-920738236d2b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15182af9-1911-3c83-8ab5-68729a2007ae" locEndPos="1" locType="sr" hash="1953665929" locEndLn="45" goals="0,"/>
    <StdViol msg="The #else preprocessor directive is used" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="45" sev="2" auth="lyao" locRef="6" rule="JSF-026" lnHash="35439580" rule.header="The #ifdef, #else, #elif preprocessor directives should not be used" tool="c++test" lineHash="35439580" unbViolId="e5a8711f-97e4-3af2-9c3d-a8e8c7e74168" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="261e0a0c-331f-3275-b671-5a86513d7b4e" locEndPos="1" locType="sr" hash="1953665929" locEndLn="45" goals="0,"/>
    <StdViol msg="The #else preprocessor directive is used" ln="45" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="45" sev="3" auth="lyao" locRef="6" rule="PREPROC-11" lnHash="35439580" rule.header="The #ifdef, #else, #elif preprocessor directives should not be used" tool="c++test" lineHash="35439580" unbViolId="c7c9f623-5df5-39ac-8c68-98307e1fb4de" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="731148fe-87fa-3aba-a16f-5b185b9592e4" locEndPos="1" locType="sr" hash="1953665929" locEndLn="45" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="JSF-061" lnHash="1844331829" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1844331829" unbViolId="409515a2-fa6c-31c5-b73a-e3c0611b6e58" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c8c7be64-c582-36c8-9b41-09be795ae2a7" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="FORMAT-42" lnHash="1844331829" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1844331829" unbViolId="752db9d7-313f-38bf-9959-c9598f3e8d5e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4ef15eb8-5cc6-3720-801e-6342a827c152" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="JSF-060_a" lnHash="1844331829" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="1844331829" unbViolId="3c2d6e6d-60cf-3d16-95be-1a0d8b3118c6" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5c9746c0-e9ed-301f-81bc-322990903a04" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="FORMAT-43" lnHash="1844331829" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1844331829" unbViolId="84a95b91-e3bc-36b6-8fea-504e9b308618" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d7bc0c36-dac6-321a-8124-a2c8e2e7001d" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="JSF-060_b" lnHash="1844331829" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="1844331829" unbViolId="222c5828-3090-3f6a-a925-205c6f415e78" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5aa548fe-8850-394f-9289-efb716a8431f" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="FORMAT-02" lnHash="1844331829" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="1844331829" unbViolId="9f760e6e-6498-3c54-8993-af11ef5b54f1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8b20f98e-14ca-3ff0-969d-b40b202066de" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="FORMAT-34" lnHash="1844331829" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="1844331829" unbViolId="a2ba733d-d285-3a08-acf0-e93f3392cfb2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="16cb5796-37e5-314a-b1dc-d2573b1f722e" locEndPos="1" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="4" auth="lyao" locRef="6" rule="MISRA2008-3_9_2" lnHash="1844331829" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1844331829" unbViolId="99743300-93f7-3d1b-af9d-3173e983b90f" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8f9898db-e2f8-3d66-96a9-e62dee615b33" locEndPos="21" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="MISRA-013" lnHash="1844331829" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1844331829" unbViolId="9c15b379-f24a-3009-b16b-11f156c74a45" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f25eb6a5-2ff1-3edb-a187-e37f14f6b8c5" locEndPos="21" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="4" auth="lyao" locRef="6" rule="MISRA2008-3_9_2" lnHash="1844331829" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="1844331829" unbViolId="ce702f86-e752-3777-bc22-de57f440857c" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4c1218aa-37ce-3ba5-abbb-a44456a3ab1b" locEndPos="31" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="MISRA-013" lnHash="1844331829" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="1844331829" unbViolId="20114c52-c0a5-3d91-a292-ab365c6a4c26" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3620d1e6-9388-3d57-af46-36d946883963" locEndPos="31" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="COMMENT-04" lnHash="1844331829" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="1844331829" unbViolId="aa9def52-8ba1-3d24-8d3c-8758d587d99f" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e320114a-ac07-3a3c-bfe3-d2aedca7b261" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="4" auth="lyao" locRef="6" rule="JSF-134" lnHash="1844331829" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="1844331829" unbViolId="ac548d79-9a90-308d-a71a-c841695f1720" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d4e2a055-5a66-3091-ae9d-2ab354bd7da1" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The parameter of pointer or array type is declared: argv" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CODSTA-94" lnHash="1844331829" rule.header="Do not declare pointer or array type" tool="c++test" lineHash="1844331829" unbViolId="3ffc4b61-7cf4-3064-98bd-b7cb6c9e9d72" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="246dfdab-2541-3573-a9d5-dbbab517743e" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The parameter of pointer type is declared: argv" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CODSTA-95" lnHash="1844331829" rule.header="Do not declare pointer type" tool="c++test" lineHash="1844331829" unbViolId="533ad048-12f9-357e-901f-d2175c00a840" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="84f6c0f1-e17b-315a-bf8c-72951dc77b90" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="COMMENT-14" lnHash="1844331829" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="1844331829" unbViolId="e738e4af-5860-3fa1-a44a-abd72662af1c" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6b8ecb69-9477-317f-bdfb-64c85171a1c3" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A2_7_3-a" lnHash="1844331829" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="1844331829" unbViolId="e7f5c5be-4ca0-3e6f-a2a2-3070f8b435a7" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1459f441-6a8f-3f72-9749-1db4774e24f5" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A2_7_3-b" lnHash="1844331829" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1844331829" unbViolId="e561f315-952a-39d9-99ab-993c877f9008" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="460c1821-c167-38c7-a1fb-22c80fc92ec7" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="COMMENT-14_b" lnHash="1844331829" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1844331829" unbViolId="62575c56-3487-339e-8415-fc57aaaddb3d" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9a97414e-8cc9-3a7a-bd2f-26109b1f8046" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A2_7_3-b" lnHash="1844331829" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1844331829" unbViolId="05b95f08-933d-34ff-aad6-0ac3b9bac385" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b9cc1fbb-9619-3472-9ca5-10a01ef2d625" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="COMMENT-14_b" lnHash="1844331829" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1844331829" unbViolId="da003f7c-bcb2-3ef9-9fae-3e4bcbfe43df" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="37ec3675-761a-3860-8fb2-5a59306fcaf8" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A2_7_3-b" lnHash="1844331829" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1844331829" unbViolId="0759c943-438c-38d1-92dd-c9fec1ac130a" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="76b3c51b-97b7-3466-a85f-2dca96716d00" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="COMMENT-14_b" lnHash="1844331829" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="1844331829" unbViolId="c538fd01-c43e-3123-a9a6-db6fc6431bbf" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4b0555fe-3c49-3392-8913-2d82540f59d8" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="'main' shall be declared as unsigned int or signed int" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="PORT-13" lnHash="1844331829" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="1844331829" unbViolId="eab3aadd-0fed-376c-8c05-9a758a66a147" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d549b71b-aee2-3bbf-85ff-d25d9fd78e7f" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="'argc' shall be declared as unsigned int or signed int" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="PORT-13" lnHash="1844331829" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="1844331829" unbViolId="988d50dc-d013-360c-91ad-960719d43449" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8cad714c-71fd-3223-ba9a-6d03c221ad6a" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Parameter 'argc' is not validated before use" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CERT_C-API00-a" lnHash="1844331829" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1844331829" unbViolId="a930fb14-b26b-335f-97e7-7922d397e5be" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5f61dc07-87eb-3cba-8091-ec6b2b74f642" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Parameter 'argc' is not validated before use" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CODSTA-86" lnHash="1844331829" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1844331829" unbViolId="a9256093-fedb-321b-aa56-9ecc672bb256" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d48f7bb8-8b54-3151-af5d-bdd93bebc203" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CERT_C-API00-a" lnHash="1844331829" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1844331829" unbViolId="9c4b26a2-0e2e-3708-ad2a-3c1e590dd40c" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a0e8e100-f43f-3273-8228-80b8cd33860a" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CODSTA-86" lnHash="1844331829" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="1844331829" unbViolId="01a4d91b-0b79-3e60-9966-2cef3b129492" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4f7cd522-a15d-3ad7-935d-6dcbccd3c900" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="CERT_CPP-ERR50-d" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="fdcdf604-75d2-37bd-bde2-18e919b5f629" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="421df402-ba72-3b68-869b-e89512a97593" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A15_3_3-a" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="25b5f666-d6cb-3b8f-81d1-2b0e5c4f591e" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="300c9fe6-f6c1-3ac5-a474-87fc214d1ed4" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="HICPP-15_3_2-b" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="215bac04-e4d1-39f2-9dcc-8ca632b01b9e" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9e10c3ec-be12-3f0a-af70-e0d4d82c4d42" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="4" auth="lyao" locRef="6" rule="MISRA2008-15_3_2" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="a4f19edc-1a56-36b8-aa8b-dd898abb229f" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9cd79128-6272-3e7b-bbfd-a4fc6e3aa091" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A15_5_3-d" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="a73c32c7-a372-3cab-8a3e-ccf4ddc3e199" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1ed8d195-4da5-352f-ad88-9b5d7aa72818" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="EXCEPT-06" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="2fd78b66-a108-3c48-968f-e2833ca52b37" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="222f74bf-9918-3fd5-bdc2-c6f84791461f" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="MISRA2008-15_5_3_d" lnHash="1844331829" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="1844331829" unbViolId="353f73be-560f-33ba-ba0c-f54692e91e10" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e6a3f448-1937-303c-913f-d850f85dacc5" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Function 'main' has Cyclomatic Complexity value: 1" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="5" auth="lyao" locRef="6" rule="METRICS-29" lnHash="1844331829" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="1844331829" unbViolId="8a2d619f-83c6-3904-adb7-87b7583fa19b" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bba397e4-fde9-38ee-b8a6-38716a4b3710" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="Function 'main' has Essential Complexity value: 1" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="5" auth="lyao" locRef="6" rule="METRICS-33" lnHash="1844331829" rule.header="Report Essential Complexity" tool="c++test" lineHash="1844331829" unbViolId="8bb3e1a4-6f3e-3887-b3f5-36b940f42de3" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7db247b7-90ba-3910-b7c9-21838a4725b4" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="NAMING-HN-22" lnHash="1844331829" rule.header="Hungarian notation for int types" tool="c++test" lineHash="1844331829" unbViolId="9c22b687-72ce-325a-aed3-18b1f77970a3" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ebb568df-7030-3920-9ae1-967a13aa7b6b" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="NAMING-HN-30" lnHash="1844331829" rule.header="Hungarian notation for int types" tool="c++test" lineHash="1844331829" unbViolId="88d40386-48d1-3a9e-8f5b-e333ca486a7a" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6ac0fc12-622b-3611-bce3-bb5622feb3f1" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="NAMING-HN-43" lnHash="1844331829" rule.header="Hungarian notation for word types" tool="c++test" lineHash="1844331829" unbViolId="3edc4e71-7742-39b0-90e0-10e50adcf829" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1efd031d-8bfd-3010-a1f0-7893870c08d0" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'argv' identifier should have the 'p' prefix" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="NAMING-HN-34" lnHash="1844331829" rule.header="Hungarian notation for pointer" tool="c++test" lineHash="1844331829" unbViolId="153d1bac-28a9-3032-83c0-566672c18ce8" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b26ed1b4-a134-3a34-b202-2283fd142df4" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="MISRA2012-RULE-8_6" lnHash="1844331829" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="1844331829" unbViolId="ecab9ef5-25dd-340a-ad78-7508bd69a09b" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="00ffc93b-281d-33dc-83fe-88d8e62a6862" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-M3_2_4-a" lnHash="1844331829" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1844331829" unbViolId="1356bffc-58db-342c-b2dc-433c7734193b" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="84e6b1c3-7473-3116-8743-eff630019d48" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="GLOBAL-ONEEXTERNDEF" lnHash="1844331829" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1844331829" unbViolId="c1e452c8-a3f3-3906-b2f1-e4b3397cd32b" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="e3773b8c-eba7-30d8-8903-ef84d643611a" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="MISRA2008-3_2_4" lnHash="1844331829" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="1844331829" unbViolId="15f5f5ce-cf38-34cb-84c1-4c288d9cc751" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="0526f8e7-df2d-376e-8459-d50fbb672bd9" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="MISRAC2012-RULE_8_6-a" lnHash="1844331829" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="1844331829" unbViolId="17ab6a28-8679-381f-9357-e2b6c125cb39" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="6614ea1f-653e-3ee7-aee7-5316613abe1a" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="GLOBAL-ONEFILEDECL" lnHash="1844331829" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1844331829" unbViolId="9398a989-48e1-3dea-b522-f5b4f06ca998" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="7ae7f3ba-3d62-3690-a405-bd790d960eee" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-M3_2_3-a" lnHash="1844331829" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1844331829" unbViolId="7c681b50-e837-35e8-8c16-311ee257f4db" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="082bcd86-d580-33bf-821e-cedcb5d257a6" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="3" auth="lyao" locRef="6" rule="HICPP-7_4_3-a" lnHash="1844331829" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1844331829" unbViolId="c5907f5c-72e3-3437-a50b-12f8f9c7730f" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="37858fce-4aac-3ebf-81e5-54d2694e66bd" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="2" auth="lyao" locRef="6" rule="MISRA2008-3_2_3" lnHash="1844331829" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="1844331829" unbViolId="b4c8153d-465c-3f8a-ae88-9164f754d868" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="85f074c7-a02d-384b-91dc-02076d996d5b" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="4" auth="lyao" locRef="6" rule="AUTOSAR-A2_10_5-b" lnHash="1844331829" rule.header="Identifiers that define functions with external linkage shall be unique" tool="c++test" lineHash="1844331829" unbViolId="f045f719-6b91-3e12-85a3-387c06ecad5d" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="9ef157b1-ca05-3539-9e5f-083521a9bb76" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="46" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="46" sev="4" auth="lyao" locRef="6" rule="MISRA2008-2_10_5_b" lnHash="1844331829" rule.header="The identifier name of a non-member object or function with static storage duration should not be reused" tool="c++test" lineHash="1844331829" unbViolId="34ff1ec8-dba1-3fbb-a1cd-53be61c792de" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="2f528fc6-14c6-3271-aa53-9e164a480806" locEndPos="44" locType="sr" hash="1953665929" locEndLn="46" goals="0,"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="47" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="47" sev="3" auth="lyao" locRef="6" rule="PREPROC-10_b" lnHash="425300360" rule.header="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="425300360" unbViolId="9a6e3fb2-d177-3fd0-8b0c-48876cf9808d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="108ebf10-fa93-3020-92f7-06af1fe58c7f" locEndPos="1" locType="sr" hash="1953665929" locEndLn="47" goals="0,"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="47" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="47" sev="2" auth="lyao" locRef="6" rule="MISRA2008-16_2_1_d" lnHash="425300360" rule.header="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="425300360" unbViolId="883bc50b-1ca0-3c87-a694-c19160113abe" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="be04179c-6090-32c6-91c4-703a70a0353f" locEndPos="1" locType="sr" hash="1953665929" locEndLn="47" goals="0,"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="47" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="47" sev="3" auth="lyao" locRef="6" rule="JSF-028_b" lnHash="425300360" rule.header="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="425300360" unbViolId="a281d878-b581-3345-8508-35541de36241" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="618d1a4f-c63c-39f8-aeef-a5bbe71f2950" locEndPos="1" locType="sr" hash="1953665929" locEndLn="47" goals="0,"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="47" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="47" sev="3" auth="lyao" locRef="6" rule="HICPP-16_1_1-e" lnHash="425300360" rule.header="The #endif pre-processor directives will only be used to prevent multiple inclusions of the same header file" tool="c++test" lineHash="425300360" unbViolId="8898fd97-b5fd-36a7-922b-4d42a98f3921" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dee1716f-fd7c-35c3-8bfd-884b731f704f" locEndPos="1" locType="sr" hash="1953665929" locEndLn="47" goals="0,"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="47" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="47" sev="3" auth="lyao" locRef="6" rule="PREPROC-26" lnHash="425300360" rule.header="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" tool="c++test" lineHash="425300360" unbViolId="8858e567-8702-3a95-ab89-2371ac3fb77b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c660b95c-3a05-34ce-93db-4a6c64b4f201" locEndPos="1" locType="sr" hash="1953665929" locEndLn="47" goals="0,"/>
    <StdViol msg="#endif pre-processor directive should not be used" ln="47" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="47" sev="2" auth="lyao" locRef="6" rule="AUTOSAR-A16_0_1-a" lnHash="425300360" rule.header="The #ifndef, #ifdef, #if, #elif, #else, and #endif pre-processor directives shall only be used for conditional file inclusion and include guards" tool="c++test" lineHash="425300360" unbViolId="4c405f08-265f-344f-a775-35837d597626" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="73c1d614-d72b-34fc-aa9e-004168b41066" locEndPos="1" locType="sr" hash="1953665929" locEndLn="47" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="48" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="48" sev="3" auth="lyao" locRef="6" rule="FORMAT-27" lnHash="-2078105395" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-2078105395" unbViolId="c9300ea7-53cd-31ee-b324-608cb5baab76" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f3757d56-8106-314a-bdcc-134196d81daf" locEndPos="1" locType="sr" hash="1953665929" locEndLn="48" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="49" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="49" sev="3" auth="lyao" locRef="6" rule="FORMAT-27" lnHash="764035996" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="764035996" unbViolId="169ceb92-e66f-30e9-b3db-a209ab374f76" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a1b350ad-7f1b-34e9-a28b-f5d70a2017f3" locEndPos="1" locType="sr" hash="1953665929" locEndLn="49" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="50" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="50" sev="3" auth="lyao" locRef="6" rule="FORMAT-27" lnHash="1827173794" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1827173794" unbViolId="362c6d1c-f82a-36ea-8582-8ae5bc153731" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="be399dbe-702f-3596-a2aa-5c58f5eea332" locEndPos="1" locType="sr" hash="1953665929" locEndLn="50" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="51" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="51" sev="3" auth="lyao" locRef="6" rule="FORMAT-27" lnHash="-1547128852" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-1547128852" unbViolId="a0032f88-6629-31f0-a1fa-898dddc7022a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4309a9f5-2b71-379a-8e10-0c53c16bf19c" locEndPos="1" locType="sr" hash="1953665929" locEndLn="51" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="52" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="52" sev="3" auth="lyao" locRef="6" rule="FORMAT-27" lnHash="-602190572" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-602190572" unbViolId="a90fa957-6e04-3eeb-8c15-a3be372e614f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="760ebf30-181a-3009-aefe-e4c5027c313c" locEndPos="1" locType="sr" hash="1953665929" locEndLn="52" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="52" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="52" sev="2" auth="lyao" locRef="6" rule="SECURITY-35" lnHash="-602190572" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-602190572" unbViolId="001a2e00-7b76-39a3-974c-6ffb8b4fa18e" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="819cd9ec-afe8-3dee-80ab-f69bdc799b45" locEndPos="3" locType="sr" hash="1953665929" locEndLn="52" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="52" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="52" sev="2" auth="lyao" locRef="6" rule="SECURITY-35" lnHash="-602190572" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="-602190572" unbViolId="6c6ed11d-1f9b-33a2-8b82-d34208c69e1c" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="941b33ee-c322-3cce-9c6f-1a544579d037" locEndPos="27" locType="sr" hash="1953665929" locEndLn="52" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="53" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="53" sev="3" auth="lyao" locRef="6" rule="FORMAT-27" lnHash="-545848069" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-545848069" unbViolId="420e7eb6-37d5-35dc-8614-213af13e5b2b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="90c6d3d9-ddf5-37db-bebf-e75032c5ed5f" locEndPos="1" locType="sr" hash="1953665929" locEndLn="53" goals="0,"/>
    <DupViol msg="Duplicated code: 'return RUN_ALL_TESTS();'" ln="53" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="53" sev="3" auth="lyao" locRef="6" rule="CDD-DUPC" lnHash="-545848069" rule.header="Avoid code duplication" tool="c++test" lineHash="-545848069" unbViolId="b8d2812e-af7a-3b10-96b2-8db765428d76" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.dupcode" lang="cpp" violId="d058742a-de21-3375-8a26-7f7cb4536c70" locType="sr" locEndPos="25" urgent="true" hash="1953665929" locEndLn="53" goals="1,">
      <ElDescList>
        <ElDesc lineHash="-545848069" ln="53" srcRngStartPos="2" srcRngEndPos="25" locRef="6" locType="sr" srcRnghash="1953665929" srcRngStartln="53" srcRngEndLn="53" srcRngFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" desc="[Line 53] Duplicated code in file 'gmock_main.cc'" rngLn="53"/>
        <ElDesc lineHash="-545848069" ln="36" srcRngStartPos="2" srcRngEndPos="25" locRef="8" locType="sr" srcRnghash="-1256976007" srcRngStartln="36" srcRngEndLn="36" srcRngFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" desc="[Line 36] Duplicated code in file 'gtest_main.cc'" rngLn="36"/>
        <ElDesc lineHash="-545848069" ln="5" srcRngStartPos="2" srcRngEndPos="25" locRef="3" locType="sr" srcRnghash="1598712918" srcRngStartln="5" srcRngEndLn="5" srcRngFile="/test/../../../../../../../../test/main.cpp" desc="[Line 5] Duplicated code in file 'main.cpp'" rngLn="5"/>
      </ElDescList>
    </DupViol>
    <StdViol msg="'return' statement should be used with parenthesis" ln="53" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="53" sev="3" auth="lyao" locRef="6" rule="FORMAT-25_b" lnHash="-545848069" rule.header="Parenthesis shall be used with the &quot;return&quot; statement" tool="c++test" lineHash="-545848069" unbViolId="428fed01-6603-31f4-9297-15b9e1e02adb" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a5368cc7-2e37-3ceb-b309-f41596c49228" locEndPos="3" locType="sr" hash="1953665929" locEndLn="53" goals="0,"/>
    <StdViol msg="The global function 'RUN_ALL_TESTS' is called without scope resolution operator '::'" ln="53" locFile="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locStartln="53" sev="5" auth="lyao" locRef="6" rule="CODSTA-CPP-23" lnHash="-545848069" rule.header="Whenever a global function  is  referenced, use the :: operator" tool="c++test" lineHash="-545848069" unbViolId="875ee45a-b317-3598-948f-770eaae09199" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="67e13a17-cda1-33f5-85e8-9201d47c0b9a" locEndPos="10" locType="sr" hash="1953665929" locEndLn="53" goals="0,"/>
    <StdViol msg="'gtest-all.cc' filename extension does not adhere to naming conventions" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="1" sev="3" auth="lyao" locRef="7" rule="NAMING-43" lnHash="1129189924" rule.header="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" tool="c++test" lineHash="1129189924" unbViolId="c0ae8b84-95f3-307d-95e0-78216c5545f4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7e8a21e5-1174-3d24-9756-cea5359c4589" locEndPos="1" locType="sr" hash="662837937" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest-all.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="1" sev="3" auth="lyao" locRef="7" rule="JSF-054" lnHash="1129189924" rule.header="Implementation files will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="31920d8d-9a4e-3b87-b383-92299852aafa" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0c425005-cc3a-3a49-9e68-e37ad772d4d7" locEndPos="1" locType="sr" hash="662837937" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest-all.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="1" sev="4" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_3-a" lnHash="1129189924" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="530a499c-1e6c-3ba5-b33d-5c09b9fa51c8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e8e0f31a-3248-3bfb-96db-96663b3c4ff6" locEndPos="1" locType="sr" hash="662837937" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest-all.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="1" sev="4" auth="lyao" locRef="7" rule="NAMING-49" lnHash="1129189924" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="1129189924" unbViolId="baa7ac5c-3330-38f3-9631-021c3d728006" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dd900bc3-4c84-3191-8fd5-2d534617338b" locEndPos="1" locType="sr" hash="662837937" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest-all.cc' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="1" sev="5" auth="lyao" locRef="7" rule="PFO-04" lnHash="1129189924" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="1129189924" unbViolId="934f9917-b04f-3afa-a701-b28c01098de3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4bd59a63-1f9f-3c65-9d6c-2fbfcc849770" locEndPos="1" locType="sr" hash="662837937" locEndLn="1" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="38" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="38" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="3bb61d26-5a01-3707-8de7-855a4efef4b9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b2ebe2e5-0653-3460-b773-f2a55d978fcc" locEndPos="1" locType="sr" hash="662837937" locEndLn="38" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="38" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="38" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="d238e37f-c918-3c7a-8081-f2d9e2280611" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4718ea72-4c96-3130-93a7-ada21b782b07" locEndPos="1" locType="sr" hash="662837937" locEndLn="38" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="41" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="41" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="139001051" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="139001051" unbViolId="4776f696-50ad-3aba-a253-3288debde5bb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a2ec1fe0-7519-365e-93d9-e400d2ae196b" locEndPos="1" locType="sr" hash="662837937" locEndLn="41" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="41" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="41" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="139001051" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="139001051" unbViolId="5e3dc212-072a-362f-8d37-c02beb23c151" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0b25d90c-f028-3cd2-8ff9-4d6663c2f9dd" locEndPos="1" locType="sr" hash="662837937" locEndLn="41" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest.cc&quot;" ln="41" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="41" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="139001051" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="139001051" unbViolId="38464739-009f-3c0b-8178-9324f8465d31" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="18e89878-5419-3b39-a292-3d53f3e312ae" locEndPos="1" locType="sr" hash="662837937" locEndLn="41" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest.cc&quot;" ln="41" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="41" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="139001051" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="139001051" unbViolId="ed4cbaa6-0a23-3de8-a225-ae285c49e092" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="52d3f9e8-1332-33ff-9023-5a5ba2e1dda7" locEndPos="1" locType="sr" hash="662837937" locEndLn="41" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest.cc&quot;" ln="41" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="41" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="139001051" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="139001051" unbViolId="7ed9f995-3f07-3071-b6f7-93e454fd1f65" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c0505482-7e08-33f8-a013-3c6576b27519" locEndPos="1" locType="sr" hash="662837937" locEndLn="41" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest.cc&quot;" ln="41" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="41" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="139001051" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="139001051" unbViolId="1ecf94d8-718a-3541-8a9a-1b97721f44e3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2d01f5e6-7411-38c8-9317-af23f05b041d" locEndPos="1" locType="sr" hash="662837937" locEndLn="41" goals="0,"/>
    <StdViol msg="Include &quot;src/gtest-death-test.cc&quot; should be placed before &quot;src/gtest.cc&quot;" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="4" auth="lyao" locRef="7" rule="FORMAT-39" lnHash="-1186158939" rule.header="Sort #include directives in alphabetical order" tool="c++test" lineHash="-1186158939" unbViolId="e5d1caf8-95e5-3e9f-b732-f34d9ab63e6b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="323d41c7-6ae6-3230-9aa3-c607bb9bf42a" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-death-test.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="-1186158939" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-1186158939" unbViolId="a83c92be-ee92-399d-bffa-589886566b72" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="85e2f22c-faf5-3636-9c85-4247c8324353" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-death-test.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="-1186158939" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-1186158939" unbViolId="d9089e64-a56c-3f5a-944c-fe1e37dbe473" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a0c12655-6053-386a-9ef6-a5e76b4edd84" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-death-test.cc&quot;" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="-1186158939" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-1186158939" unbViolId="1093224a-2d99-327d-a481-7b7fb0afa58d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9e543254-bd48-35ff-b920-e00340c9b2ce" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-death-test.cc&quot;" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="-1186158939" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-1186158939" unbViolId="a58204e0-2480-35d8-b9a7-7054b31c4a96" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="66e1fbb7-7841-37d0-ba2d-2fcdfdb95c1a" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-death-test.cc&quot;" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="-1186158939" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1186158939" unbViolId="675e433e-9188-3b2b-894f-7c5216f4817d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7a521959-4868-3934-a3cb-0e32e204fb9a" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-death-test.cc&quot;" ln="42" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="42" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="-1186158939" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-1186158939" unbViolId="12281f03-9b7e-3f89-81f9-2f7ae35cebcb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9e650a6c-89b6-3ede-a1b9-c703b77ab7a5" locEndPos="1" locType="sr" hash="662837937" locEndLn="42" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-filepath.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="43" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="43" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="445715579" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="445715579" unbViolId="f0a7c66a-0957-37bf-9aa0-5ae2bcb3f68e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cf2653cb-8342-3267-a628-1c5df0bf3976" locEndPos="1" locType="sr" hash="662837937" locEndLn="43" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-filepath.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="43" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="43" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="445715579" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="445715579" unbViolId="e7c5ca8d-1427-3820-9c2f-63bcec412a87" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7564c49e-a825-3993-bb37-7e703c85aee6" locEndPos="1" locType="sr" hash="662837937" locEndLn="43" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-filepath.cc&quot;" ln="43" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="43" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="445715579" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="445715579" unbViolId="da40689b-3144-3f49-b2fb-d187fec59685" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dd912e18-421b-3605-b78c-70a6d2533119" locEndPos="1" locType="sr" hash="662837937" locEndLn="43" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-filepath.cc&quot;" ln="43" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="43" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="445715579" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="445715579" unbViolId="a8e2f265-b992-373d-a103-4a18bf461b51" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="42124bbb-592c-363b-b59c-81a4a6beb6b3" locEndPos="1" locType="sr" hash="662837937" locEndLn="43" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-filepath.cc&quot;" ln="43" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="43" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="445715579" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="445715579" unbViolId="bf090cbb-a2e5-378b-920b-711d4a3e4ce9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6d47bbc4-2cca-36f1-961b-90fb11e28305" locEndPos="1" locType="sr" hash="662837937" locEndLn="43" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-filepath.cc&quot;" ln="43" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="43" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="445715579" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="445715579" unbViolId="f4655c2e-bf6c-3dcb-b747-46baaabb8a58" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="56ff7814-a7f2-3749-80a2-fb541b5d199c" locEndPos="1" locType="sr" hash="662837937" locEndLn="43" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-port.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="44" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="44" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="463221851" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="463221851" unbViolId="1eaede50-3799-3c73-8616-db32d8b257ec" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="95b37853-5444-3a83-a08a-a91011790bb8" locEndPos="1" locType="sr" hash="662837937" locEndLn="44" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-port.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="44" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="44" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="463221851" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="463221851" unbViolId="06253dd2-5eaf-30d6-9490-406752a923a7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="84d835f2-e78f-3c61-a610-7b55bd78aeb1" locEndPos="1" locType="sr" hash="662837937" locEndLn="44" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-port.cc&quot;" ln="44" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="44" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="463221851" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="463221851" unbViolId="628e2f14-e91d-3b5d-bbf8-857b0f0755f9" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b497dab4-d40c-3979-b1a5-ff1b4f697164" locEndPos="1" locType="sr" hash="662837937" locEndLn="44" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-port.cc&quot;" ln="44" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="44" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="463221851" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="463221851" unbViolId="d6b51c8d-c77f-3679-bc3f-de1b2db1eba4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cb65624b-527a-3bf0-9c38-83c3e80618e3" locEndPos="1" locType="sr" hash="662837937" locEndLn="44" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-port.cc&quot;" ln="44" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="44" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="463221851" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="463221851" unbViolId="71bdff54-12e3-335c-a40a-705ea9540b21" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6be82609-44de-32ef-ad19-33ec291db792" locEndPos="1" locType="sr" hash="662837937" locEndLn="44" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-port.cc&quot;" ln="44" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="44" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="463221851" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="463221851" unbViolId="a9ff217a-c3bd-3a57-bca5-368f5db521a4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0b7a7f1d-cf69-35ca-aa57-51f8304c2eab" locEndPos="1" locType="sr" hash="662837937" locEndLn="44" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-printers.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="45" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="45" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="1835423859" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="1835423859" unbViolId="8de86035-af5a-39c2-af8c-7b4bbf620b65" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="47791de5-a293-3179-9ca2-6cec0f518d96" locEndPos="1" locType="sr" hash="662837937" locEndLn="45" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-printers.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="45" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="45" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="1835423859" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="1835423859" unbViolId="f9b3484b-a393-34ee-818a-a85b6c01dd0e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d433b66d-5176-311d-81b0-1a6336c863e2" locEndPos="1" locType="sr" hash="662837937" locEndLn="45" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-printers.cc&quot;" ln="45" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="45" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="1835423859" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="1835423859" unbViolId="e4b70c23-84f6-3850-9b6c-be76e93a4dd3" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1cd61c52-6b51-3f4b-9449-28e3c7ed02da" locEndPos="1" locType="sr" hash="662837937" locEndLn="45" goals="0,"/><StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-printers.cc&quot;" ln="45" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="45" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="1835423859" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="1835423859" unbViolId="d4eceec2-5d28-35bf-a0fb-5c61407cdec1" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7f6914fb-cbd2-39e2-b9ac-8ecc99a6e154" locEndPos="1" locType="sr" hash="662837937" locEndLn="45" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-printers.cc&quot;" ln="45" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="45" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="1835423859" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1835423859" unbViolId="8624270f-0df8-37aa-9240-141c28fccbd4" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8656375b-0399-3785-a5d6-d5c75a26456f" locEndPos="1" locType="sr" hash="662837937" locEndLn="45" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-printers.cc&quot;" ln="45" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="45" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="1835423859" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1835423859" unbViolId="723e148a-d71e-3f71-8c46-3d579154334d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="075e2c99-a98f-308a-8f07-6dc7d0e05f2f" locEndPos="1" locType="sr" hash="662837937" locEndLn="45" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-test-part.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="46" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="46" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="-158808484" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-158808484" unbViolId="e1ff9f14-42c4-376e-91b4-d558f6ac3195" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6baf80b4-1bf8-39c8-acef-ec063645fbfb" locEndPos="1" locType="sr" hash="662837937" locEndLn="46" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-test-part.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="46" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="46" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="-158808484" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="-158808484" unbViolId="c761d4d9-2b44-3b29-b580-01a339bddaed" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fab748cb-a2fe-3adc-bf28-403165e8595e" locEndPos="1" locType="sr" hash="662837937" locEndLn="46" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-test-part.cc&quot;" ln="46" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="46" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="-158808484" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-158808484" unbViolId="68b8e180-6cb1-3cb1-be20-2db44901c7c7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c754618c-0610-390a-a69d-dbea18e04f71" locEndPos="1" locType="sr" hash="662837937" locEndLn="46" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-test-part.cc&quot;" ln="46" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="46" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="-158808484" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="-158808484" unbViolId="1787605c-5676-33f4-8871-8c833421aeae" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="17382843-2606-34cb-8eaa-8434f1c9037d" locEndPos="1" locType="sr" hash="662837937" locEndLn="46" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-test-part.cc&quot;" ln="46" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="46" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="-158808484" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-158808484" unbViolId="e7a15aac-75fa-3098-a820-80c547fa4399" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c0fbe90e-aa32-3877-8ee3-53aa6f2f3aed" locEndPos="1" locType="sr" hash="662837937" locEndLn="46" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-test-part.cc&quot;" ln="46" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="46" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="-158808484" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="-158808484" unbViolId="d5a0e102-0393-3bf4-b08a-00b45ff159ce" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3113b1d6-1e8c-3918-b783-6799700db27f" locEndPos="1" locType="sr" hash="662837937" locEndLn="46" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-typed-test.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="47" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="47" sev="3" auth="lyao" locRef="7" rule="NAMING-53" lnHash="1648506223" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="1648506223" unbViolId="b43ff2bf-ad42-30bb-aacd-0ebe141cdeb2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cf5d04ea-8106-3132-95e2-66790d481388" locEndPos="1" locType="sr" hash="662837937" locEndLn="47" goals="0,"/>
    <StdViol msg="Header file &quot;src/gtest-typed-test.cc&quot; does not have a standard file extension '.h', '.hpp', or '.hxx'" ln="47" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="47" sev="2" auth="lyao" locRef="7" rule="AUTOSAR-A3_1_2-a" lnHash="1648506223" rule.header="Header files should have a file extension of: &quot;.h&quot;, &quot;.hpp&quot; or &quot;.hxx&quot;" tool="c++test" lineHash="1648506223" unbViolId="90b13d5e-2b94-3a5b-b822-618f155f1d90" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7e86e95b-21d6-30f3-b0d8-0d5b7a4e7656" locEndPos="1" locType="sr" hash="662837937" locEndLn="47" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-typed-test.cc&quot;" ln="47" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="47" sev="3" auth="lyao" locRef="7" rule="JSF-032" lnHash="1648506223" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="1648506223" unbViolId="9a093e60-ba9e-3a79-8091-9df1d1e52d96" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="373b52dc-4f21-30f5-8e27-a59da832af67" locEndPos="1" locType="sr" hash="662837937" locEndLn="47" goals="0,"/>
    <StdViol msg="Not a proper header file (*.h ) is being included: &quot;src/gtest-typed-test.cc&quot;" ln="47" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="47" sev="3" auth="lyao" locRef="7" rule="PREPROC-08" lnHash="1648506223" rule.header="The #include pre-processor directive will only be used to include header (*.h) files" tool="c++test" lineHash="1648506223" unbViolId="f12aa193-c35d-364d-927c-d64c1cd20315" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0b25d02d-0193-31f2-83f1-2b8fcf2f7ac3" locEndPos="1" locType="sr" hash="662837937" locEndLn="47" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-typed-test.cc&quot;" ln="47" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="47" sev="2" auth="lyao" locRef="7" rule="PREPROC-09" lnHash="1648506223" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1648506223" unbViolId="bef94b2b-8c38-3b38-b1bb-d2d13d47e782" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fa2511b7-2645-3f18-b317-c15f4ca1d4c1" locEndPos="1" locType="sr" hash="662837937" locEndLn="47" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;src/gtest-typed-test.cc&quot;" ln="47" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locStartln="47" sev="2" auth="lyao" locRef="7" rule="JSF-033" lnHash="1648506223" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1648506223" unbViolId="17912cb9-6f95-372e-b764-40c5b317de63" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c42dc26d-e92a-3370-9b09-9124f778e0cb" locEndPos="1" locType="sr" hash="662837937" locEndLn="47" goals="0,"/>
    <StdViol msg="The assertion density is lower than two assertions per function" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="3" auth="lyao" locRef="8" rule="METRICS-31" lnHash="2140307174" rule.header="The assertion density of the code should average to a minimum of two assertions per function" tool="c++test" lineHash="2140307174" unbViolId="3cde755d-01e4-3720-b67a-900ebff15329" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="3dc421c1-b0c4-3b01-9ef4-3ebcd3782796" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="'gtest_main.cc' filename extension does not adhere to naming conventions" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="3" auth="lyao" locRef="8" rule="NAMING-43" lnHash="2140307174" rule.header="File name extension, if present, should be &quot;*.cpp&quot; or &quot;*.h&quot;" tool="c++test" lineHash="2140307174" unbViolId="e26a47a9-7ba5-37ff-926b-5a313d83e41a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="bb50255b-f47f-3edb-bcfe-beea8ded401c" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest_main.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="3" auth="lyao" locRef="8" rule="JSF-054" lnHash="2140307174" rule.header="Implementation files will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="2140307174" unbViolId="cf653df5-e7a1-3a0e-bc0d-e83f810934bb" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="87f17f5c-3815-3a12-9700-c4bcdaf27927" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest_main.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="4" auth="lyao" locRef="8" rule="AUTOSAR-A3_1_3-a" lnHash="2140307174" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="2140307174" unbViolId="5ed32893-3b11-34b6-95b8-3206eccc4e71" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="59caabfd-d377-31bf-9bf8-c4d6cd5802ed" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest_main.cc' should have the file name extension &quot;.cpp&quot;" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="4" auth="lyao" locRef="8" rule="NAMING-49" lnHash="2140307174" rule.header="Implementation files in C++ will always have a file name extension of &quot;.cpp&quot;" tool="c++test" lineHash="2140307174" unbViolId="d4f61586-50fc-3531-a055-20b9c3c5c685" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a7e1bf8c-2e25-3471-b90f-42e50bbcb4c3" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="Implementation file 'gtest_main.cc' should declare a local constant string that begins from characters &quot;@(#)&quot; " ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="5" auth="lyao" locRef="8" rule="PFO-04" lnHash="2140307174" rule.header="Every implementation file should declare a local constant string that describes the file" tool="c++test" lineHash="2140307174" unbViolId="56cc7be7-88e1-3364-a967-817bfe11e12f" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cbc46b42-5b5d-3a21-a916-83b2cb0e4eae" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'gtest_main.cc'" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="3" auth="lyao" locRef="8" rule="COMMENT-03" lnHash="2140307174" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="2140307174" unbViolId="ddf02d3c-7517-3708-aede-581e9572dac6" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f16bc67d-4ef5-3887-852d-302eb029b1cd" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="Add comment containing the information on the file at the begin of file 'gtest_main.cc'" ln="1" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="1" sev="3" auth="lyao" locRef="8" rule="JSF-133_a" lnHash="2140307174" rule.header="Every source file will be documented with an introductory comment that provides information on the file" tool="c++test" lineHash="2140307174" unbViolId="c125cbaa-f6c9-3468-a1da-ca795d77216d" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f285d6ed-c763-3b6e-b325-08491772b82b" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="1" goals="0,"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="3" auth="lyao" locRef="8" rule="PREPROC-18" lnHash="1233725276" rule.header="The input/output library stdio.h shall not be included" tool="c++test" lineHash="1233725276" unbViolId="daf6f7f9-0c58-33e0-a8c0-f18c85e16a1e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f6fdf58f-d925-3aa7-be90-85b73befdaa1" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="2" auth="lyao" locRef="8" rule="JSF-022" lnHash="1233725276" rule.header="The input/output library &lt;stdio.h> shall not be used" tool="c++test" lineHash="1233725276" unbViolId="7d7baeb5-de5e-384d-99a5-62d70203adff" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4fb9ac85-6d48-3b22-a9b7-e89d72a20378" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Instead of C library header '&lt;stdio.h>' the corresponding C++ library header should be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="2" auth="lyao" locRef="8" rule="MISRA2008-18_0_1" lnHash="1233725276" rule.header="The C library shall not be used" tool="c++test" lineHash="1233725276" unbViolId="99673643-68f8-3e1a-8bd4-815d37bde235" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8c3999f1-ffab-3d0a-a1c1-fede8e26e5e1" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Instead of C library header '&lt;stdio.h>' the corresponding C++ library header should be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="3" auth="lyao" locRef="8" rule="HICPP-1_3_3-a" lnHash="1233725276" rule.header="The C library shall not be used" tool="c++test" lineHash="1233725276" unbViolId="c322dd3e-d27a-30ee-a01d-8fb9a6d35b12" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4bd784d3-3f56-3a97-b730-b80b9e4710bb" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Instead of C library header '&lt;stdio.h>' the corresponding C++ library header should be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A18_0_1-a" lnHash="1233725276" rule.header="The C library shall not be used" tool="c++test" lineHash="1233725276" unbViolId="dc461c78-483c-3729-9f94-b5d0d323a9d7" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b66300f3-953f-3aa8-ada3-20521c97e7a2" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Instead of C library header '&lt;stdio.h>' the corresponding C++ library header should be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="3" auth="lyao" locRef="8" rule="CODSTA-CPP-59" lnHash="1233725276" rule.header="The C library shall not be used" tool="c++test" lineHash="1233725276" unbViolId="9b1f372f-1381-3d06-8524-66556f9d6820" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="eca91e8c-6e10-313f-bfd2-80722d2613f0" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Instead of C library header '&lt;stdio.h>' the corresponding C++ library header should be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A1_1_1-d" lnHash="1233725276" rule.header="The C library shall not be used" tool="c++test" lineHash="1233725276" unbViolId="23f931b6-9ad8-3720-aed0-0fbea89eee0b" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="dc14d350-6cf8-3a3a-8d98-9f337e25858e" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Ensure that C Standard Library is securely used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="4" auth="lyao" locRef="8" rule="HICPP-17_2_1-a" lnHash="1233725276" rule.header="Wrap use of the C Standard Library" tool="c++test" lineHash="1233725276" unbViolId="58a7557a-2a19-30a6-a39c-e2c87c19975a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="afbbf7f6-f40b-3949-bc4b-3e31586bdf6e" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-M27_0_1-a" lnHash="1233725276" rule.header="The input/output library stdio.h shall not be used" tool="c++test" lineHash="1233725276" unbViolId="908cd5d5-7145-3f64-930a-669aa20340bf" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="fcb81e48-75a4-3d4f-9ed6-f597545f2ef2" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="2" auth="lyao" locRef="8" rule="MISRA2008-27_0_1" lnHash="1233725276" rule.header="The stream input/output library &lt;cstdio> shall not be used" tool="c++test" lineHash="1233725276" unbViolId="1539342b-7232-3637-a7ca-16e2fec03e3e" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e873685b-4c1c-36da-bae5-6d1df5e73cec" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="&lt;stdio.h> library shall not be used" ln="30" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="30" sev="3" auth="lyao" locRef="8" rule="MISRA2004-20_9" lnHash="1233725276" rule.header="The input/output library stdio.h shall not be used" tool="c++test" lineHash="1233725276" unbViolId="56eacf91-11d3-35b5-8669-47fa3b4c664c" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4ff5c98b-922e-3da6-92b8-2462732c1556" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="30" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="31" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="31" sev="2" auth="lyao" locRef="8" rule="PREPROC-09" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="cb68bc4f-36ba-3959-aaac-0dcf912313c8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="be3f1007-9094-3dbb-ad31-98c014992d81" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="31" goals="0,"/>
    <StdViol msg="Disallowed #include notation is being used: &quot;gtest/gtest.h&quot;" ln="31" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="31" sev="2" auth="lyao" locRef="8" rule="JSF-033" lnHash="1137051340" rule.header="The #include directive shall use the &lt;filename.h> notation to include header files" tool="c++test" lineHash="1137051340" unbViolId="d16762e0-5810-30df-9ed9-e07057da8dfa" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="de402d52-9a96-3316-b5d7-ffac94cd4b0c" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="31" goals="0,"/>
    <StdViol msg="Percentage of comment lines vs. all method's lines is: 0" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="METRICS-19" lnHash="-237266251" rule.header="The percentage of comment lines versus the total number of module lines should be between 20 and 60" tool="c++test" lineHash="-237266251" unbViolId="2890b4cf-4fe5-32ef-b2f2-ad6894cfc88a" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15dfcb23-92fc-3cb7-9956-6473fe372eba" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="JSF-061" lnHash="-237266251" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-237266251" unbViolId="f72db791-a3da-3657-a293-9de85f8f58d8" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a823a30-2326-3676-bc4d-f078b7a3959d" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="FORMAT-42" lnHash="-237266251" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-237266251" unbViolId="3fd2b24e-0e12-377d-9993-d490af31b9d0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ec69d566-79d6-3e59-b718-05f745fa0c27" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="JSF-060_a" lnHash="-237266251" rule.header="Braces (&quot;{}&quot;) which enclose a block will have nothing else on the line except comments" tool="c++test" lineHash="-237266251" unbViolId="1811dd95-393e-354a-a079-c0e3780d4ea6" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7f05eb45-4b08-3909-95f5-221ccd775278" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="FORMAT-43" lnHash="-237266251" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-237266251" unbViolId="c15e18b4-2809-3ac1-ac37-23a27baa8157" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="075b2d2f-5a63-3060-a73c-d3fbc72b00c5" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' braces are not placed in the same column" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="JSF-060_b" lnHash="-237266251" rule.header="Braces (&quot;{}&quot;) which enclose a block will be placed in the same column" tool="c++test" lineHash="-237266251" unbViolId="fd179a1c-e1e1-374c-8f58-0422483b1348" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a044395c-c569-3fcc-b53c-b28c85c72611" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Put the opening brace '{' on its own line" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="FORMAT-02" lnHash="-237266251" rule.header="Place an opening brace '{' on its own line" tool="c++test" lineHash="-237266251" unbViolId="65533f26-77a7-3417-b3fe-71c455ffb2ca" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b1060a77-4899-31ab-87d0-f8e60f4ef084" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Opening '{' and closing '}' should be in the same column" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="FORMAT-34" lnHash="-237266251" rule.header="Braces &quot;{}&quot; which enclose a block should be placed in the same column" tool="c++test" lineHash="-237266251" unbViolId="2fbeb833-5638-3ef9-a1db-6d6dd31fa1a2" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0f5753fd-5634-30ed-b734-acb18f1ea078" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="MISRA2008-3_9_2" lnHash="-237266251" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="-237266251" unbViolId="a3195c8c-76a1-3ac6-a008-50f986dab9cd" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6da8351b-0aa6-3a7a-9ba1-9737e8f87d13" locEndPos="21" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The basic numerical type 'int' should not be used" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="MISRA-013" lnHash="-237266251" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="-237266251" unbViolId="9b46342e-7fe3-3395-b3ae-07b509c96b86" locStartPos="20" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1b79bf1d-d8db-35b6-8c02-829aadbd6485" locEndPos="21" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="MISRA2008-3_9_2" lnHash="-237266251" rule.header="typedefs that indicate size and signedness should be used in place of the basic numerical types" tool="c++test" lineHash="-237266251" unbViolId="d155d099-e869-382b-a075-b62bfd4eb3f7" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e2d477df-4e1e-33c1-b653-656150e24b35" locEndPos="31" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The basic numerical type 'char' should not be used" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="MISRA-013" lnHash="-237266251" rule.header="The basic types of char, int, short, long, float and double should not be used, but specific-length equivalents should be typedef'd" tool="c++test" lineHash="-237266251" unbViolId="ca027190-edcc-3cb2-bc5a-957e7f94d1be" locStartPos="30" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="1235e182-cacb-335a-9f34-92405d2cf0a1" locEndPos="31" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="JSF-062" lnHash="-237266251" rule.header="The dereference operator '*' and the address-of operator '&amp;' will be directly connected with the type-specifier" tool="c++test" lineHash="-237266251" unbViolId="e8732e8c-5510-3c47-9ce7-f1f0ac4a719d" locStartPos="35" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ed0c647d-2dc5-31f5-9407-7981e802c95d" locEndPos="36" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="FORMAT-32" lnHash="-237266251" rule.header="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" tool="c++test" lineHash="-237266251" unbViolId="977bb883-1767-3769-bffb-620ec55a39ed" locStartPos="35" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0769c6ad-a9de-319f-80c4-d778023d243d" locEndPos="36" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type, not the identifier" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="JSF-062" lnHash="-237266251" rule.header="The dereference operator '*' and the address-of operator '&amp;' will be directly connected with the type-specifier" tool="c++test" lineHash="-237266251" unbViolId="4e742b4f-df1f-3626-9496-e61393ec3cc5" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a1d9bbe-23df-3518-b5ac-06bee32ab151" locEndPos="37" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The operator '*', used for 'argv' declaration, should be directly connected with the type, not the identifier" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="FORMAT-32" lnHash="-237266251" rule.header="The dereference operator '*' and the address-of operator '&amp;' should be directly connected with the type" tool="c++test" lineHash="-237266251" unbViolId="c10311f0-f731-3a97-8108-68e91607e8d8" locStartPos="36" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9e630d74-043f-336c-96df-c060bfa46dec" locEndPos="37" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="COMMENT-04" lnHash="-237266251" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="-237266251" unbViolId="96630156-8290-3475-9dc6-33b25e701e12" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="808acbc7-ad4b-34d6-ab3f-aa0632b41098" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The definition of the 'main' function is not preceded by a comment" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="JSF-134" lnHash="-237266251" rule.header="Document functions in comments that precede function definitions" tool="c++test" lineHash="-237266251" unbViolId="647630fc-463f-3b7d-b1bd-418644c6d876" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7c1372b6-96a7-358d-bbe4-a9d7dd1fba0a" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The parameter of pointer or array type is declared: argv" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CODSTA-94" lnHash="-237266251" rule.header="Do not declare pointer or array type" tool="c++test" lineHash="-237266251" unbViolId="59beac5b-29cb-3cd5-9019-a1f236f1d91c" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="75fd294c-5250-3363-b258-490366010fd9" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The parameter of pointer type is declared: argv" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CODSTA-95" lnHash="-237266251" rule.header="Do not declare pointer type" tool="c++test" lineHash="-237266251" unbViolId="66d2ab75-89c0-3c81-b189-46f76cda7e34" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c39b338f-63a3-3d80-b4c2-84f200fbe9f5" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="COMMENT-14" lnHash="-237266251" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-237266251" unbViolId="6260ed5d-eb57-375d-ad35-9cc6a4cadc53" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="518f58b0-47f7-3eca-b871-5a7b85510860" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@brief' tag" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A2_7_3-a" lnHash="-237266251" rule.header="All declarations of types, data members, and functions should be preceded by a comment annotated with the '@brief' tag" tool="c++test" lineHash="-237266251" unbViolId="16a8f794-2acc-3a30-8766-fa7e8a53c8e2" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="aa068abc-a126-3409-a2bc-b26867bda692" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A2_7_3-b" lnHash="-237266251" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-237266251" unbViolId="137b1a7e-05e8-34b5-8470-aefc0e03b7be" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5d4ac1fb-ac3b-320e-9354-01f2a72caf65" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argc' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="COMMENT-14_b" lnHash="-237266251" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-237266251" unbViolId="048be0ab-dc8e-3fdd-8603-1fb7b7717eb8" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="f5b3d215-ef55-3613-841d-71496a1bce56" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A2_7_3-b" lnHash="-237266251" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-237266251" unbViolId="a861422e-69de-3f9b-906e-758c473d2192" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b6f86660-b664-3552-9fae-02b6918a387b" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argv' parameter does not have a corresponding '@param' tag in the comment before the function declaration" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="COMMENT-14_b" lnHash="-237266251" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-237266251" unbViolId="7df791d6-675f-3078-865b-c2dfc3b2f6a4" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6fc1ed1d-7db6-332d-9f62-d927c650a091" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A2_7_3-b" lnHash="-237266251" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-237266251" unbViolId="0c547f55-3bd4-3b65-8a5f-7739eea10f77" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="084cf412-b34a-3117-9c67-f6e9029842c0" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function should be preceded by a comment that contains the '@return' tag" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="COMMENT-14_b" lnHash="-237266251" rule.header="Function parameters and return type should be documented in a comment that precedes the function declaration" tool="c++test" lineHash="-237266251" unbViolId="7ec38645-22c5-36e8-825e-62e32f9b3c36" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2ffdbbee-5e86-39fb-8bfa-68c75ef61006" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="'main' shall be declared as unsigned int or signed int" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="PORT-13" lnHash="-237266251" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="-237266251" unbViolId="a455ff8d-9ffe-34fe-9524-b59e1e05764f" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="69ca0a91-e1c9-35e3-9307-85e2b8da18e9" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="'argc' shall be declared as unsigned int or signed int" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="PORT-13" lnHash="-237266251" rule.header="The type int shall always be declared as unsigned int or signed int" tool="c++test" lineHash="-237266251" unbViolId="a0357f3e-2a69-3658-a64a-8b604bd04755" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a06922d8-d421-32d6-85a5-b435690af458" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Parameter 'argc' is not validated before use" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CERT_C-API00-a" lnHash="-237266251" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="-237266251" unbViolId="c88da7bb-1808-38ef-9a7d-4d2c0169ac84" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="91268b9e-d364-342d-9487-adae017140b5" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Parameter 'argc' is not validated before use" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CODSTA-86" lnHash="-237266251" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="-237266251" unbViolId="ecd4b761-4953-39b8-8bd1-e9545275a43c" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2764169b-c9ae-3073-9c50-f0f7aa121d03" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CERT_C-API00-a" lnHash="-237266251" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="-237266251" unbViolId="b1dfca78-ca96-3570-9b0a-5fc51005ff4c" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="06bd9103-4215-3663-980d-e1e718e74e37" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Parameter 'argv' is not validated before use" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CODSTA-86" lnHash="-237266251" rule.header="The validity of parameters must be checked inside each function" tool="c++test" lineHash="-237266251" unbViolId="ba649b15-c420-3ba9-9065-0d8ee50291a0" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="15b27f51-7bcb-3a45-b43a-49e2e5ea6941" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="CERT_CPP-ERR50-d" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="e5acae6b-0302-3970-a25f-9e12e4c6d8bd" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c816f2b5-cd9c-368d-b325-84c7625db019" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A15_3_3-a" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="5f6dab4b-bb92-3601-8d98-f694b7990b7d" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="41eb27e5-5156-3164-ae6e-d0cd075464f9" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="HICPP-15_3_2-b" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="f0287237-063a-3563-abc8-51caebe6dcb1" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e1306074-e213-3b25-998a-d2fcaaef548c" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="MISRA2008-15_3_2" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="defa0925-1bff-37e3-a0e8-ef8df49b8363" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="60688c9a-7c26-3230-81b6-27043e4c3eae" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A15_5_3-d" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="42d27290-cf28-390b-b280-865e8ac4e5ad" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ae8ef134-6ab8-3222-9b92-37aa9f54bbae" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="EXCEPT-06" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="1a1a25b2-1c8e-3d88-b407-d406fd2b042f" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="234580d6-1640-3b23-9fd8-e9e65eae531d" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function does not contain a catch(...) to catch all unhandled exceptions" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="MISRA2008-15_5_3_d" lnHash="-237266251" rule.header="There should be at least one exception handler to catch all otherwise unhandled exceptions" tool="c++test" lineHash="-237266251" unbViolId="101defc0-998d-36f9-a4bb-dc1810f57a95" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5f571620-411d-3f21-a323-f199d0d629e2" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Function 'main' has Cyclomatic Complexity value: 1" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="5" auth="lyao" locRef="8" rule="METRICS-29" lnHash="-237266251" rule.header="Report Cyclomatic Complexity" tool="c++test" lineHash="-237266251" unbViolId="43174dff-c8ad-3f11-b912-35d6dac31830" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="815d82a3-f715-39dd-9305-7b2a534e5368" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Function 'main' has Essential Complexity value: 1" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="5" auth="lyao" locRef="8" rule="METRICS-33" lnHash="-237266251" rule.header="Report Essential Complexity" tool="c++test" lineHash="-237266251" unbViolId="c26a25f7-69e3-3bd8-9fd3-a6c1a46b0e78" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="9206b903-82e5-34aa-9da8-bf07c32e898c" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="NAMING-HN-22" lnHash="-237266251" rule.header="Hungarian notation for int types" tool="c++test" lineHash="-237266251" unbViolId="99d2f1fd-1e48-3f85-b0a1-84e13d5a9df2" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="a80b5dca-03d8-3480-a52f-2c84ffab20a6" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'n' prefix followed by a capital letter or an underscore" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="NAMING-HN-30" lnHash="-237266251" rule.header="Hungarian notation for int types" tool="c++test" lineHash="-237266251" unbViolId="afbca55f-9d32-308d-bac8-217396e6ca4e" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b202c7e4-0c79-3a5a-90ec-f02fea1bd4aa" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argc' identifier should have the 'i' prefix followed by a capital letter or an underscore" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="NAMING-HN-43" lnHash="-237266251" rule.header="Hungarian notation for word types" tool="c++test" lineHash="-237266251" unbViolId="d66133c7-8dd2-3c13-af07-77d203c63ceb" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d2fe1dc2-8132-3e93-a7fc-9dba5754bee9" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'argv' identifier should have the 'p' prefix" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="NAMING-HN-34" lnHash="-237266251" rule.header="Hungarian notation for pointer" tool="c++test" lineHash="-237266251" unbViolId="0f8167a0-9758-3e68-b01d-d77179bc9c6b" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="603b0b0c-4c6f-3ac2-8f75-643190c7040f" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="MISRA2012-RULE-8_6" lnHash="-237266251" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="-237266251" unbViolId="95a7c193-fa30-3755-8d8f-a1a545bcdfb7" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="16b89cab-64d5-349c-940f-cd66f4fa7663" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-M3_2_4-a" lnHash="-237266251" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="-237266251" unbViolId="fbca8989-91f2-3c2a-8ae2-47570585186f" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="dc23c11b-0585-32e1-96eb-48fe7c6afa33" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="GLOBAL-ONEEXTERNDEF" lnHash="-237266251" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="-237266251" unbViolId="ea4c8539-6627-332e-af2a-460f0fabc691" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="2fd39998-cc96-3af5-8a00-a22791927f87" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="MISRA2008-3_2_4" lnHash="-237266251" rule.header="An identifier with external linkage shall have exactly one external definition" tool="c++test" lineHash="-237266251" unbViolId="3d4fa40b-da9d-3132-9644-ac071cb87e6c" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="b8dcdaa1-f492-32a7-b260-7c84d817c640" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is also defined in other translation units" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="MISRAC2012-RULE_8_6-a" lnHash="-237266251" rule.header="An identifier with external linkage shall have no more then one external definition" tool="c++test" lineHash="-237266251" unbViolId="48722adb-0650-307a-bace-e49346d3ff96" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="59ea8527-43e2-3dc9-a26b-2df0b1cf9872" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="GLOBAL-ONEFILEDECL" lnHash="-237266251" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="-237266251" unbViolId="622c20e4-6ad0-3722-a180-bf14203b39f1" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="ef9fc275-07e0-3f39-8bc9-9c33fdad079f" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-M3_2_3-a" lnHash="-237266251" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="-237266251" unbViolId="76fe1458-af69-3eda-bc95-26b13dc7fff0" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="16b7d6f8-0af4-3f5d-a7fb-269f3cfb2410" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="3" auth="lyao" locRef="8" rule="HICPP-7_4_3-a" lnHash="-237266251" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="-237266251" unbViolId="1ae78a4f-b29b-33cf-a716-0fb970b00555" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="b3830a25-ec77-36e7-a363-c316e0734c90" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function is declared in more than one file" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="2" auth="lyao" locRef="8" rule="MISRA2008-3_2_3" lnHash="-237266251" rule.header="A type, object or function that is used in multiple translation units shall be declared in one and only one file" tool="c++test" lineHash="-237266251" unbViolId="56f5ef2c-df0c-37f4-8f8b-d24827ff2f0e" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="bb313d59-58f7-3a12-9824-681aaa86f140" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="AUTOSAR-A2_10_5-b" lnHash="-237266251" rule.header="Identifiers that define functions with external linkage shall be unique" tool="c++test" lineHash="-237266251" unbViolId="07884f4d-b19b-374c-a4fc-fb4a4529130e" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="a71c2bbb-d468-356b-91ce-ceca7607a445" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="The 'main' function with external linkage is not a unique identifier in the testing scope" ln="33" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="33" sev="4" auth="lyao" locRef="8" rule="MISRA2008-2_10_5_b" lnHash="-237266251" rule.header="The identifier name of a non-member object or function with static storage duration should not be reused" tool="c++test" lineHash="-237266251" unbViolId="2ba70364-9614-3483-8380-c3bc92ee66eb" locStartPos="43" analyzer="com.parasoft.xtest.cpp.analyzer.static.global" lang="cpp" violId="61f79ad1-2d62-3c2b-a5b7-f32f7f1358a4" locEndPos="44" locType="sr" hash="-1256976007" locEndLn="33" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="FORMAT-27" lnHash="-1524206720" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-1524206720" unbViolId="b89a62c3-4890-3893-9aed-1df7190091c0" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="4a6598eb-91bb-3f8a-926f-5c2681492832" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="MISRAC2012-RULE_21_6-a" lnHash="-1524206720" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1524206720" unbViolId="5d38817e-9fe1-3461-8eeb-a36cd908ba37" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8a30ef5c-3e0c-3fa4-a4b0-ac6187d56eff" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="MISRA2012-RULE-21_6" lnHash="-1524206720" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1524206720" unbViolId="b715861d-7c6c-3d87-8d99-919f1995bf54" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="5c2da532-c14f-3c4e-b6c9-56ba2fb9121d" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="CERT_C-ERR02-a" lnHash="-1524206720" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1524206720" unbViolId="4f51f414-5067-3947-80cb-9f2d8263e2bd" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7e6c2690-413d-3519-b1ad-b7db47842bef" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Usage of 'printf' function is not allowed" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="CODSTA-110" lnHash="-1524206720" rule.header="The Standard Library input/output functions shall not be used" tool="c++test" lineHash="-1524206720" unbViolId="930877fe-f5c6-39f9-80fb-c2b05989615b" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2c34977a-e31e-38d9-909b-b98a79a2cece" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's 'printf' return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A0_1_2-a" lnHash="-1524206720" rule.header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-1524206720" unbViolId="3ad5ba68-16fe-36bd-87df-7a720dffe71f" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="7566d10a-509f-3f61-90b1-982c5adc9d84" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's 'printf' return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="CODSTA-CPP-58" lnHash="-1524206720" rule.header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-1524206720" unbViolId="02f250d9-574f-34b1-bc63-22c71d344fd0" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="0102cd71-e31b-326b-ac4b-e81b91c010db" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's 'printf' return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="MISRA2008-0_1_7" lnHash="-1524206720" rule.header="The value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-1524206720" unbViolId="a08c2ea4-2636-321a-aeaa-23155c2cd2c6" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="57d772cc-c291-3f20-8564-49b97c4f80de" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's 'printf' return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="4" auth="lyao" locRef="8" rule="JSF-115_a" lnHash="-1524206720" rule.header="Value returned by a function having a non-void return type that is not an overloaded operator shall always be used" tool="c++test" lineHash="-1524206720" unbViolId="2366351c-8418-3977-b4db-e46f480ed1b9" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="da0dd632-9b14-3ef8-8dc4-7345d86a384f" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="CODSTA-122_a" lnHash="-1524206720" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1524206720" unbViolId="e4ca2089-55e0-3b2d-a51f-6bcdc3e38d74" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="87ed843d-eaac-37df-8f9a-87824017bf5d" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="MISRAC2012-RULE_17_7-a" lnHash="-1524206720" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1524206720" unbViolId="c26bfe5d-4009-3d26-82bb-ccdfa25cdb38" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="af1bcbce-c00f-3407-baf4-7f888cd3a5cb" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="CERT_C-EXP12-a" lnHash="-1524206720" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1524206720" unbViolId="ad99fece-dfaf-337f-b17f-b1180407ec82" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e0422b50-2165-30b4-b4d9-c1a456043fc8" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="MISRA2012-RULE-17_7_a" lnHash="-1524206720" rule.header="The value returned by a function having non-void return type shall be used" tool="c++test" lineHash="-1524206720" unbViolId="b7e0a3f9-fe89-337a-8b3b-6e84fbe6132f" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e62a5b32-dd05-3ca9-8b48-43c70a40475b" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="MISRA2004-16_10" lnHash="-1524206720" rule.header="If a function returns error information, then that error information shall be tested" tool="c++test" lineHash="-1524206720" unbViolId="9eb62458-1d5e-348f-85a2-c54db80e7abf" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="6b150a8c-dbae-3aec-93a4-ec2c62ce94fb" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-M0_3_2-a" lnHash="-1524206720" rule.header="If a function returns error information, then that error information shall be tested" tool="c++test" lineHash="-1524206720" unbViolId="45a46fe5-fa2c-366e-a780-61189648dca5" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="200a15f6-c7fc-385e-a555-5e5a68104588" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="MISRA2008-0_3_2" lnHash="-1524206720" rule.header="If a function generates error information, then that error information shall be tested" tool="c++test" lineHash="-1524206720" unbViolId="017b4779-794a-39b5-9ddb-bbb45a4b59b9" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="ac3635c4-1579-3868-9019-189903fbbe46" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Unused function's &quot;printf&quot; return value" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="JSF-115" lnHash="-1524206720" rule.header="If a function returns error information, then that error information will be tested" tool="c++test" lineHash="-1524206720" unbViolId="c463b373-7210-3be9-9221-3fd2e908ca9c" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="e38174af-1863-300f-a1bc-fbe7e42eb1fc" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Prefer iostream.h to stdio.h" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="5" auth="lyao" locRef="8" rule="CODSTA-CPP-01" lnHash="-1524206720" rule.header="Prefer iostream.h to stdio.h" tool="c++test" lineHash="-1524206720" unbViolId="0142ab66-6685-35b7-a199-641259dc8fc6" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="893230ca-c82d-3a29-8deb-fb46421d3d21" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="The string literal should not be passed as an argument of the 'const char *' type in the 'printf' function call" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="2" auth="lyao" locRef="8" rule="AUTOSAR-A27_0_4-d" lnHash="-1524206720" rule.header="C-style strings shall not be used" tool="c++test" lineHash="-1524206720" unbViolId="72c96752-37dc-3aa5-bd57-169aabd9cec5" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="90299fba-508b-3ebc-8eed-8b6faabe8dd2" locEndPos="10" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="The string literal should not be passed as an argument of the 'const char *' type in the 'printf' function call" ln="34" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="34" sev="3" auth="lyao" locRef="8" rule="PB-76" lnHash="-1524206720" rule.header="C-style strings shall not be used" tool="c++test" lineHash="-1524206720" unbViolId="64bbd3f5-85e0-3093-ba58-608b1a81e092" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="2adc5bf1-aa74-3cbb-b52b-1b48faba0aa8" locEndPos="10" locType="sr" hash="-1256976007" locEndLn="34" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="35" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="35" sev="3" auth="lyao" locRef="8" rule="FORMAT-27" lnHash="1464494620" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="1464494620" unbViolId="7e2f6f19-4a8c-32e7-95ef-c81f7fe2bc39" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="cb30d912-4f3c-3c62-84ef-25f070ff382a" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="35" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="35" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="35" sev="2" auth="lyao" locRef="8" rule="SECURITY-35" lnHash="1464494620" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="1464494620" unbViolId="c6ece713-7608-305c-b0d7-b50a7128a1f1" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="d51563c9-3cac-399c-892d-3efab95619f6" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="35" goals="0,"/>
    <StdViol msg="No value of command line should be trusted: argc" ln="35" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="35" sev="2" auth="lyao" locRef="8" rule="SECURITY-35" lnHash="1464494620" rule.header="Don't trust any value of command line if attacker can set them" tool="c++test" lineHash="1464494620" unbViolId="5056922a-25e2-368d-bd60-310e34ad6c78" locStartPos="26" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b6b46752-ea82-35af-a86b-f15671671c65" locEndPos="27" locType="sr" hash="-1256976007" locEndLn="35" goals="0,"/>
    <StdViol msg="Line is incorrectly indented" ln="36" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="36" sev="3" auth="lyao" locRef="8" rule="FORMAT-27" lnHash="-545848069" rule.header="Line should be indented by a multiple of four spaces" tool="c++test" lineHash="-545848069" unbViolId="545aace4-8620-3670-8678-be0670904803" locStartPos="0" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="c785b705-570d-3aa9-b06e-a4559ee3da99" locEndPos="1" locType="sr" hash="-1256976007" locEndLn="36" goals="0,"/>
    <StdViol msg="'return' statement should be used with parenthesis" ln="36" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="36" sev="3" auth="lyao" locRef="8" rule="FORMAT-25_b" lnHash="-545848069" rule.header="Parenthesis shall be used with the &quot;return&quot; statement" tool="c++test" lineHash="-545848069" unbViolId="1ec74d3c-ad3a-3b5e-972f-d21ba8171943" locStartPos="2" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="b5ca67bd-ee49-3252-ac9e-025e6acf7182" locEndPos="3" locType="sr" hash="-1256976007" locEndLn="36" goals="0,"/>
    <StdViol msg="The global function 'RUN_ALL_TESTS' is called without scope resolution operator '::'" ln="36" locFile="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locStartln="36" sev="5" auth="lyao" locRef="8" rule="CODSTA-CPP-23" lnHash="-545848069" rule.header="Whenever a global function  is  referenced, use the :: operator" tool="c++test" lineHash="-545848069" unbViolId="0293025d-882f-306a-9e77-5f0b6bb93101" locStartPos="9" analyzer="com.parasoft.xtest.cpp.analyzer.static.pattern" lang="cpp" violId="8e09b470-dc1a-3c9b-9cb7-560174cfc9cd" locEndPos="10" locType="sr" hash="-1256976007" locEndLn="36" goals="0,"/></StdViols>
      <TestedFilesDetails>
         <Total name="Total (Suppressed)" supp="0" total="1204">
            <Project id="src" name="src" supp="0" total="301">
               <Res name=".." supp="0" total="301">
                  <Res name=".." supp="0" total="301">
                     <Res name=".." supp="0" total="301">
                        <Res name=".." supp="0" total="301">
                           <Res name=".." supp="0" total="301">
                              <Res name=".." supp="0" total="301">
                                 <Res name=".." supp="0" total="301">
                                    <Res name=".." supp="0" total="301">
                                       <Res name="src" supp="0" total="301">
                                          <Res loc="/src/../../../../../../../../src/main.cpp" locRef="1" locType="sr" name="main.cpp" supp="0" total="301"/>
                                       </Res>
                                    </Res>
                                 </Res>
                              </Res>
                           </Res>
                        </Res>
                     </Res>
                  </Res>
               </Res>
            </Project>
            <Project id="division" name="division" supp="0" total="55">
               <Res name=".." supp="0" total="55">
                  <Res name=".." supp="0" total="55">
                     <Res name=".." supp="0" total="55">
                        <Res name=".." supp="0" total="55">
                           <Res name=".." supp="0" total="55">
                              <Res name=".." supp="0" total="55">
                                 <Res name=".." supp="0" total="55">
                                    <Res name=".." supp="0" total="55">
                                       <Res name="src" supp="0" total="55">
                                          <Res name="division" supp="0" total="55">
                                             <Res loc="/division/../../../../../../../../src/division/division.cpp" locRef="2" locType="sr" name="division.cpp" supp="0" total="55"/>
                                          </Res>
                                       </Res>
                                    </Res>
                                 </Res>
                              </Res>
                           </Res>
                        </Res>
                     </Res>
                  </Res>
               </Res>
            </Project>
            <Project id="test" name="test" supp="0" total="538">
               <Res name=".." supp="0" total="538">
                  <Res name=".." supp="0" total="538">
                     <Res name=".." supp="0" total="538">
                        <Res name=".." supp="0" total="538">
                           <Res name=".." supp="0" total="538">
                              <Res name=".." supp="0" total="538">
                                 <Res name=".." supp="0" total="538">
                                    <Res name=".." supp="0" total="538">
                                       <Res name="test" supp="0" total="538">
                                          <Res loc="/test/../../../../../../../../test/main.cpp" locRef="3" locType="sr" name="main.cpp" supp="0" total="75"/>
                                          <Res name="src" supp="0" total="463">
                                             <Res loc="/test/../../../../../../../../test/src/divider_tests.cpp" locRef="4" locType="sr" name="divider_tests.cpp" supp="0" total="463"/>
                                          </Res>
                                       </Res>
                                    </Res>
                                 </Res>
                              </Res>
                           </Res>
                        </Res>
                     </Res>
                  </Res>
               </Res>
            </Project>
            <Project id="googlemock" name="googlemock" supp="0" total="155">
               <Res name=".." supp="0" total="155">
                  <Res name=".." supp="0" total="155">
                     <Res name=".." supp="0" total="155">
                        <Res name=".." supp="0" total="155">
                           <Res name=".." supp="0" total="155">
                              <Res name=".." supp="0" total="155">
                                 <Res name=".." supp="0" total="155">
                                    <Res name=".." supp="0" total="155">
                                       <Res name="test" supp="0" total="155">
                                          <Res name="lib" supp="0" total="155">
                                             <Res name="googletest" supp="0" total="155">
                                                <Res name="googlemock" supp="0" total="155">
                                                   <Res name="src" supp="0" total="155">
                                                      <Res loc="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock-all.cc" locRef="5" locType="sr" name="gmock-all.cc" supp="0" total="37"/>
                                                      <Res loc="/googlemock/../../../../../../../../test/lib/googletest/googlemock/src/gmock_main.cc" locRef="6" locType="sr" name="gmock_main.cc" supp="0" total="118"/>
                                                   </Res>
                                                </Res>
                                             </Res>
                                          </Res>
                                       </Res>
                                    </Res>
                                 </Res>
                              </Res>
                           </Res>
                        </Res>
                     </Res>
                  </Res>
               </Res>
            </Project>
            <Project id="gtest" name="gtest" supp="0" total="155">
               <Res name=".." supp="0" total="155">
                  <Res name=".." supp="0" total="155">
                     <Res name=".." supp="0" total="155">
                        <Res name=".." supp="0" total="155">
                           <Res name=".." supp="0" total="155">
                              <Res name=".." supp="0" total="155">
                                 <Res name=".." supp="0" total="155">
                                    <Res name=".." supp="0" total="155">
                                       <Res name="test" supp="0" total="155">
                                          <Res name="lib" supp="0" total="155">
                                             <Res name="googletest" supp="0" total="155">
                                                <Res name="googletest" supp="0" total="155">
                                                   <Res name="src" supp="0" total="155">
                                                      <Res loc="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest-all.cc" locRef="7" locType="sr" name="gtest-all.cc" supp="0" total="50"/>
                                                      <Res loc="/gtest/../../../../../../../../test/lib/googletest/googletest/src/gtest_main.cc" locRef="8" locType="sr" name="gtest_main.cc" supp="0" total="105"/>
                                                   </Res>
                                                </Res>
                                             </Res>
                                          </Res>
                                       </Res>
                                    </Res>
                                 </Res>
                              </Res>
                           </Res>
                        </Res>
                     </Res>
                  </Res>
               </Res>
            </Project>
         </Total>
      </TestedFilesDetails>
   </CodingStandards>
   <Statistics>
      
   </Statistics>
</ResultsSession>